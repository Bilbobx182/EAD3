{"version":3,"sources":["../src/index.js"],"names":["getAliasFromResolveInfo","parseResolveInfo","simplifyParsedResolveInfoFragmentWithType","debug","resolveInfo","asts","fieldNodes","fieldASTs","alias","reduce","val","kind","value","name","Error","options","parentType","keepRoot","deep","tree","fieldTreeFromAST","undefined","typeKey","firstKey","fieldKey","getFieldFromAST","ast","fieldNode","fieldName","type","getFields","iNum","inASTs","initTree","depth","instance","variableValues","fragments","Array","isArray","outerDepth","selectionVal","idx","length","isReserved","substr","field","fieldGqlType","args","newTreeRoot","fieldsByTypeName","selectionSet","newParentType","selections","fragment","fragmentType","typeCondition","getType","obj","key","schema","typeName","parsedResolveInfoFragment","Type","fields","StrippedType","ObjectType","getInterfaces","Interface","parse","simplify","getAlias"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\n\nimport assert from \"assert\";\nimport { getArgumentValues } from \"graphql/execution/values\";\nimport {\n  getNamedType,\n  isCompositeType,\n  GraphQLObjectType,\n  GraphQLUnionType,\n} from \"graphql\";\nimport debugFactory from \"debug\";\n\nimport type {\n  GraphQLResolveInfo,\n  GraphQLField,\n  GraphQLCompositeType,\n  GraphQLInterfaceType,\n  GraphQLType,\n} from \"graphql/type/definition\";\n\nimport type {\n  ASTNode,\n  FieldNode,\n  SelectionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n} from \"graphql/language/ast\";\n\nexport type FieldsByTypeName = {\n  [string]: {\n    [string]: ResolveTree,\n  },\n};\n\nexport type ResolveTree = {\n  name: string,\n  alias: string,\n  args: {\n    [string]: mixed,\n  },\n  fieldsByTypeName: FieldsByTypeName,\n};\n\nconst debug = debugFactory(\"graphql-parse-resolve-info\");\n\n// Originally based on https://github.com/tjmehta/graphql-parse-fields\n\nexport function getAliasFromResolveInfo(\n  resolveInfo: GraphQLResolveInfo\n): string {\n  const asts = resolveInfo.fieldNodes || resolveInfo.fieldASTs;\n  const alias = asts.reduce(function(alias, val) {\n    if (!alias) {\n      if (val.kind === \"Field\") {\n        alias = val.alias ? val.alias.value : val.name && val.name.value;\n      }\n    }\n    return alias;\n  }, null);\n  if (!alias) {\n    throw new Error(\"Could not determine alias?!\");\n  }\n  return alias;\n}\n\nexport function parseResolveInfo(\n  resolveInfo: GraphQLResolveInfo,\n  options: { keepRoot?: boolean, deep?: boolean } = {}\n): ResolveTree | FieldsByTypeName | null | void {\n  const fieldNodes: Array<FieldNode> =\n    resolveInfo.fieldNodes || resolveInfo.fieldASTs;\n\n  const { parentType } = resolveInfo;\n  if (!fieldNodes) {\n    throw new Error(\"No fieldNodes provided!\");\n  }\n  if (options.keepRoot == null) {\n    options.keepRoot = false;\n  }\n  if (options.deep == null) {\n    options.deep = true;\n  }\n  let tree = fieldTreeFromAST(\n    fieldNodes,\n    resolveInfo,\n    undefined,\n    options,\n    parentType\n  );\n  if (!options.keepRoot) {\n    const typeKey = firstKey(tree);\n    if (!typeKey) {\n      return null;\n    }\n    tree = tree[typeKey];\n    const fieldKey = firstKey(tree);\n    if (!fieldKey) {\n      return null;\n    }\n    tree = tree[fieldKey];\n  }\n  return tree;\n}\n\nfunction getFieldFromAST(\n  ast: ASTNode,\n  parentType: GraphQLCompositeType\n): ?GraphQLField<*, *> {\n  if (ast.kind === \"Field\") {\n    const fieldNode: FieldNode = ast;\n    const fieldName = fieldNode.name.value;\n    if (!(parentType instanceof GraphQLUnionType)) {\n      const type: GraphQLObjectType | GraphQLInterfaceType = parentType;\n      return type.getFields()[fieldName];\n    } else {\n      // XXX: TODO: Handle GraphQLUnionType\n    }\n  }\n  return;\n}\n\nlet iNum = 1;\nfunction fieldTreeFromAST<T: SelectionNode>(\n  inASTs: Array<T> | T,\n  resolveInfo: GraphQLResolveInfo,\n  initTree: FieldsByTypeName = {},\n  options = {},\n  parentType: GraphQLCompositeType,\n  depth = \"\"\n): FieldsByTypeName {\n  const instance = iNum++;\n  debug(\n    \"%s[%d] Entering fieldTreeFromAST with parent type '%s'\",\n    depth,\n    instance,\n    parentType\n  );\n  let { variableValues } = resolveInfo;\n  const fragments = resolveInfo.fragments || {};\n  const asts: Array<T> = Array.isArray(inASTs) ? inASTs : [inASTs];\n  initTree[parentType.name] = initTree[parentType.name] || {};\n  const outerDepth = depth;\n  return asts.reduce(function(tree, selectionVal: SelectionNode, idx) {\n    const depth = `${outerDepth}  `;\n    debug(\n      \"%s[%d] Processing AST %d of %d; kind = %s\",\n      depth,\n      instance,\n      idx + 1,\n      asts.length,\n      selectionVal.kind\n    );\n    if (selectionVal.kind === \"Field\") {\n      const val: FieldNode = selectionVal;\n      const name = val.name && val.name.value;\n      const isReserved = name && name !== \"__id\" && name.substr(0, 2) === \"__\";\n      if (isReserved) {\n        debug(\n          \"%s[%d] IGNORING because field '%s' is reserved\",\n          depth,\n          instance,\n          name\n        );\n      } else {\n        const alias: string =\n          val.alias && val.alias.value ? val.alias.value : val.name.value;\n        debug(\"%s[%d] Field '%s' (alias = '%s')\", depth, instance, name, alias);\n        const field = getFieldFromAST(val, parentType);\n        if (!field) {\n          return tree;\n        }\n        const fieldGqlType = getNamedType(field.type);\n        if (!fieldGqlType) {\n          return tree;\n        }\n        const args = getArgumentValues(field, val, variableValues) || {};\n        if (parentType.name && !tree[parentType.name][alias]) {\n          const newTreeRoot: ResolveTree = {\n            name,\n            alias,\n            args,\n            fieldsByTypeName: isCompositeType(fieldGqlType)\n              ? {\n                  [fieldGqlType.name]: {},\n                }\n              : {},\n          };\n          tree[parentType.name][alias] = newTreeRoot;\n        }\n        const selectionSet = val.selectionSet;\n        if (\n          selectionSet != null &&\n          options.deep &&\n          isCompositeType(fieldGqlType)\n        ) {\n          const newParentType: GraphQLCompositeType = fieldGqlType;\n          debug(\"%s[%d] Recursing into subfields\", depth, instance);\n          fieldTreeFromAST(\n            selectionSet.selections,\n            resolveInfo,\n            tree[parentType.name][alias].fieldsByTypeName,\n            options,\n            newParentType,\n            `${depth}  `\n          );\n        } else {\n          // No fields to add\n          debug(\"%s[%d] Exiting (no fields to add)\", depth, instance);\n        }\n      }\n    } else if (selectionVal.kind === \"FragmentSpread\" && options.deep) {\n      const val: FragmentSpreadNode = selectionVal;\n      const name = val.name && val.name.value;\n      debug(\"%s[%d] Fragment spread '%s'\", depth, instance, name);\n      const fragment = fragments[name];\n      assert(fragment, 'unknown fragment \"' + name + '\"');\n      let fragmentType = parentType;\n      if (fragment.typeCondition) {\n        fragmentType = getType(resolveInfo, fragment.typeCondition);\n      }\n      if (fragmentType && isCompositeType(fragmentType)) {\n        const newParentType: GraphQLCompositeType = fragmentType;\n        fieldTreeFromAST(\n          fragment.selectionSet.selections,\n          resolveInfo,\n          tree,\n          options,\n          newParentType,\n          `${depth}  `\n        );\n      }\n    } else if (selectionVal.kind === \"InlineFragment\" && options.deep) {\n      const val: InlineFragmentNode = selectionVal;\n      const fragment = val;\n      let fragmentType = parentType;\n      if (fragment.typeCondition) {\n        fragmentType = getType(resolveInfo, fragment.typeCondition);\n      }\n      debug(\n        \"%s[%d] Inline fragment (parent = '%s', type = '%s')\",\n        depth,\n        instance,\n        parentType,\n        fragmentType\n      );\n      if (fragmentType && isCompositeType(fragmentType)) {\n        const newParentType: GraphQLCompositeType = fragmentType;\n        fieldTreeFromAST(\n          fragment.selectionSet.selections,\n          resolveInfo,\n          tree,\n          options,\n          newParentType,\n          `${depth}  `\n        );\n      }\n    } else {\n      debug(\n        \"%s[%d] IGNORING because kind '%s' not understood\",\n        depth,\n        instance,\n        selectionVal.kind\n      );\n    }\n    // Ref: https://github.com/postgraphql/postgraphql/pull/342/files#diff-d6702ec9fed755c88b9d70b430fda4d8R148\n    return tree;\n  }, initTree);\n}\n\nfunction firstKey(obj) {\n  for (const key in obj) {\n    return key;\n  }\n}\n\nfunction getType(resolveInfo, typeCondition) {\n  const { schema } = resolveInfo;\n  const { kind, name } = typeCondition;\n  if (kind === \"NamedType\") {\n    const typeName = name.value;\n    return schema.getType(typeName);\n  }\n}\n\nexport function simplifyParsedResolveInfoFragmentWithType(\n  parsedResolveInfoFragment: ResolveTree,\n  Type: GraphQLType\n) {\n  const { fieldsByTypeName } = parsedResolveInfoFragment;\n  const fields = {};\n  const StrippedType = getNamedType(Type);\n  if (isCompositeType(StrippedType)) {\n    Object.assign(fields, fieldsByTypeName[StrippedType.name]);\n    if (StrippedType instanceof GraphQLObjectType) {\n      const ObjectType: GraphQLObjectType = StrippedType;\n      // GraphQL ensures that the subfields cannot clash, so it's safe to simply overwrite them\n      for (const Interface of ObjectType.getInterfaces()) {\n        Object.assign(fields, fieldsByTypeName[Interface.name]);\n      }\n    }\n  }\n  return Object.assign({}, parsedResolveInfoFragment, {\n    fields,\n  });\n}\n\nexport const parse = parseResolveInfo;\nexport const simplify = simplifyParsedResolveInfoFragmentWithType;\nexport const getAlias = getAliasFromResolveInfo;\n"]}