"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _defineProperty = require("babel-runtime/core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _toArray2 = require("babel-runtime/helpers/toArray");

var _toArray3 = _interopRequireDefault(_toArray2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var base64 = function base64(str) {
  return new Buffer(String(str)).toString("base64");
};
var base64Decode = function base64Decode(str) {
  return new Buffer(String(str), "base64").toString("utf8");
};

exports.default = function NodePlugin(builder, _ref) {
  var inNodeIdFieldName = _ref.nodeIdFieldName;

  var nodeIdFieldName = inNodeIdFieldName ? String(inNodeIdFieldName) : "id";
  builder.hook("build", function (build) {
    var nodeFetcherByTypeName = {};
    var nodeAliasByTypeName = {};
    var nodeTypeNameByAlias = {};
    return build.extend(build, {
      nodeIdFieldName,
      $$nodeType: (0, _symbol2.default)("nodeType"),
      nodeFetcherByTypeName,
      getNodeIdForTypeAndIdentifiers(Type) {
        for (var _len = arguments.length, identifiers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          identifiers[_key - 1] = arguments[_key];
        }

        return base64((0, _stringify2.default)([this.getNodeAlias(Type)].concat(identifiers)));
      },
      addNodeFetcherForTypeName(typeName, fetcher) {
        if (nodeFetcherByTypeName[typeName]) {
          throw new Error("There's already a fetcher for this type");
        }
        if (!fetcher) {
          throw new Error("No fetcher specified");
        }
        nodeFetcherByTypeName[typeName] = fetcher;
      },
      getNodeAlias(typeName) {
        return nodeAliasByTypeName[typeName] || typeName;
      },
      getNodeType(alias) {
        return this.getTypeByName(nodeTypeNameByAlias[alias] || alias);
      },
      setNodeAlias(typeName, alias) {
        nodeAliasByTypeName[typeName] = alias;
        nodeTypeNameByAlias[alias] = typeName;
      }
    }, `Adding 'Node' interface support to the Build`);
  });

  builder.hook("init", function defineNodeInterfaceType(_, _ref2) {
    var $$isQuery = _ref2.$$isQuery,
        $$nodeType = _ref2.$$nodeType,
        getTypeByName = _ref2.getTypeByName,
        newWithHooks = _ref2.newWithHooks,
        _ref2$graphql = _ref2.graphql,
        GraphQLNonNull = _ref2$graphql.GraphQLNonNull,
        GraphQLID = _ref2$graphql.GraphQLID,
        GraphQLInterfaceType = _ref2$graphql.GraphQLInterfaceType,
        getNullableType = _ref2$graphql.getNullableType;

    newWithHooks(GraphQLInterfaceType, {
      name: "Node",
      description: "An object with a globally unique `ID`.",
      resolveType: function resolveType(value) {
        if (value === $$isQuery) {
          return getTypeByName("Query");
        } else if (value[$$nodeType]) {
          return getNullableType(value[$$nodeType]);
        }
      },
      fields: {
        [nodeIdFieldName]: {
          description: "A globally unique identifier. Can be used in various places throughout the system to identify this single value.",
          type: new GraphQLNonNull(GraphQLID)
        }
      }
    }, {});
    return _;
  });

  builder.hook("GraphQLObjectType:interfaces", function addNodeIdToQuery(interfaces, _ref3, _ref4) {
    var getTypeByName = _ref3.getTypeByName;
    var isRootQuery = _ref4.scope.isRootQuery;

    if (!isRootQuery) {
      return interfaces;
    }
    var Type = getTypeByName("Node");
    if (Type) {
      return [].concat((0, _toConsumableArray3.default)(interfaces), [Type]);
    } else {
      return interfaces;
    }
  });

  builder.hook("GraphQLObjectType:fields", function (fields, _ref5, _ref6) {
    var $$isQuery = _ref5.$$isQuery,
        $$nodeType = _ref5.$$nodeType,
        parseResolveInfo = _ref5.parseResolveInfo,
        getTypeByName = _ref5.getTypeByName,
        extend = _ref5.extend,
        nodeFetcherByTypeName = _ref5.nodeFetcherByTypeName,
        getNodeType = _ref5.getNodeType,
        _ref5$graphql = _ref5.graphql,
        GraphQLNonNull = _ref5$graphql.GraphQLNonNull,
        GraphQLID = _ref5$graphql.GraphQLID,
        getNamedType = _ref5$graphql.getNamedType;
    var isRootQuery = _ref6.scope.isRootQuery,
        fieldWithHooks = _ref6.fieldWithHooks;

    if (!isRootQuery) {
      return fields;
    }
    return extend(fields, {
      [nodeIdFieldName]: {
        description: "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.",
        type: new GraphQLNonNull(GraphQLID),
        resolve() {
          return "query";
        }
      },
      node: fieldWithHooks("node", function (_ref7) {
        var getDataFromParsedResolveInfoFragment = _ref7.getDataFromParsedResolveInfoFragment;
        return {
          description: "Fetches an object given its globally unique `ID`.",
          type: getTypeByName("Node"),
          args: {
            [nodeIdFieldName]: {
              description: "The globally unique `ID`.",
              type: new GraphQLNonNull(GraphQLID)
            }
          },
          resolve(data, args, context, resolveInfo) {
            var _this = this;

            return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
              var nodeId, _JSON$parse, _JSON$parse2, _alias, _identifiers, _Type, resolver, _parsedResolveInfoFragment, _resolveData, node;

              return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      nodeId = args[nodeIdFieldName];

                      if (!(nodeId === "query")) {
                        _context.next = 3;
                        break;
                      }

                      return _context.abrupt("return", $$isQuery);

                    case 3:
                      _context.prev = 3;
                      _JSON$parse = JSON.parse(base64Decode(nodeId)), _JSON$parse2 = (0, _toArray3.default)(_JSON$parse), _alias = _JSON$parse2[0], _identifiers = _JSON$parse2.slice(1);
                      _Type = getNodeType(_alias);

                      if (_Type) {
                        _context.next = 8;
                        break;
                      }

                      throw new Error("Type not found");

                    case 8:
                      resolver = nodeFetcherByTypeName[getNamedType(_Type).name];
                      _parsedResolveInfoFragment = parseResolveInfo(resolveInfo, {}, _Type);
                      _resolveData = getDataFromParsedResolveInfoFragment(_parsedResolveInfoFragment, getNamedType(_Type));
                      _context.next = 13;
                      return resolver(data, _identifiers, context, _parsedResolveInfoFragment, resolveInfo.returnType, _resolveData);

                    case 13:
                      node = _context.sent;

                      (0, _defineProperty2.default)(node, $$nodeType, {
                        enumerable: false,
                        configurable: false,
                        value: _Type
                      });
                      return _context.abrupt("return", node);

                    case 18:
                      _context.prev = 18;
                      _context.t0 = _context["catch"](3);
                      return _context.abrupt("return", null);

                    case 21:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, _this, [[3, 18]]);
            }))();
          }
        };
      }, {
        isRootNodeField: true
      })
    }, `Adding node helpers to the root Query`);
  });
};
//# sourceMappingURL=NodePlugin.js.map