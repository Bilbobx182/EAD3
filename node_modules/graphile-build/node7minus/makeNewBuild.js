"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _isFrozen = require("babel-runtime/core-js/object/is-frozen");

var _isFrozen2 = _interopRequireDefault(_isFrozen);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.default = makeNewBuild;

var _graphql = require("graphql");

var graphql = _interopRequireWildcard(_graphql);

var _graphqlParseResolveInfo = require("graphql-parse-resolve-info");

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

var _extend = require("./extend");

var _extend2 = _interopRequireDefault(_extend);

var _package = require("../package.json");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isString = function isString(str) {
  return typeof str === "string";
};

var isDev = ["test", "development"].indexOf(process.env.NODE_ENV) >= 0;
var debug = (0, _debug2.default)("graphile-build");
var debugWarn = (0, _debug2.default)("graphile-build:warn");

function getNameFromType(Type) {
  if (Type instanceof GraphQLSchema) {
    return "schema";
  } else {
    return Type.name;
  }
}

var GraphQLSchema = graphql.GraphQLSchema,
    GraphQLObjectType = graphql.GraphQLObjectType,
    GraphQLInputObjectType = graphql.GraphQLInputObjectType,
    GraphQLEnumType = graphql.GraphQLEnumType,
    getNamedType = graphql.getNamedType,
    isCompositeType = graphql.isCompositeType,
    isAbstractType = graphql.isAbstractType;


var mergeData = function mergeData(data, gen, ReturnType, arg) {
  var results = ensureArray(gen(arg, ReturnType, data));
  if (!results) {
    return;
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(results), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var result = _step.value;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(result)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var k = _step2.value;

          data[k] = data[k] || [];
          var value = result[k];
          var newData = ensureArray(value);
          if (newData) {
            var _data$k;

            (_data$k = data[k]).push.apply(_data$k, (0, _toConsumableArray3.default)(newData));
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

var knownTypes = [GraphQLSchema, GraphQLObjectType, GraphQLInputObjectType, GraphQLEnumType];
var knownTypeNames = knownTypes.map(function (k) {
  return k.name;
});

function ensureArray(val) {
  if (val == null) {
    return;
  } else if (Array.isArray(val)) {
    return val;
  } else {
    return [val];
  }
}

// eslint-disable-next-line no-unused-vars
var ensureName = function ensureName(fn) {};
if (["development", "test"].indexOf(process.env.NODE_ENV) >= 0) {
  ensureName = function ensureName(fn) {
    if (isDev && !fn.displayName && !fn.name && debug.enabled) {
      // eslint-disable-next-line no-console
      console.trace("WARNING: you've added a function with no name as an argDataGenerator, doing so may make debugging more challenging");
    }
  };
}

function makeNewBuild(builder) {
  var allTypes = {};

  // Every object type gets fieldData associated with each of its
  // fields.

  // When a field is defined, it may add to this field data.

  // When something resolves referencing this type, the resolver may
  // request the fieldData, e.g. to perform optimisations.

  // fieldData is an object whose keys are the fields on this
  // GraphQLObjectType and whose values are an object (whose keys are
  // arbitrary namespaced keys and whose values are arrays of
  // information of this kind)
  var fieldDataGeneratorsByFieldNameByType = new _map2.default();
  var fieldArgDataGeneratorsByFieldNameByType = new _map2.default();

  return {
    graphileBuildVersion: _package.version,
    graphql,
    parseResolveInfo: _graphqlParseResolveInfo.parseResolveInfo,
    simplifyParsedResolveInfoFragmentWithType: _graphqlParseResolveInfo.simplifyParsedResolveInfoFragmentWithType,
    getAliasFromResolveInfo: _graphqlParseResolveInfo.getAliasFromResolveInfo,
    resolveAlias(data, _args, _context, resolveInfo) {
      var alias = (0, _graphqlParseResolveInfo.getAliasFromResolveInfo)(resolveInfo);
      return data[alias];
    },
    addType(type) {
      if (!type.name) {
        throw new Error(`addType must only be called with named types, try using require('graphql').getNamedType`);
      }
      if (allTypes[type.name] && allTypes[type.name] !== type) {
        throw new Error(`There's already a type with the name: ${type.name}`);
      }
      allTypes[type.name] = type;
    },
    getTypeByName(typeName) {
      return allTypes[typeName];
    },
    extend: _extend2.default,
    newWithHooks(Type, spec, inScope) {
      var _this = this;

      var returnNullOnInvalid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var scope = inScope || {};
      if (!inScope) {
        // eslint-disable-next-line no-console
        console.warn(`No scope was provided to new ${getNameFromType(Type)}[name=${spec.name}], it's highly recommended that you add a scope so other hooks can easily reference your object - please check usage of 'newWithHooks'. To mute this message, just pass an empty object.`);
      }
      if (!Type) {
        throw new Error("No type specified!");
      }
      if (!this.newWithHooks || !(0, _isFrozen2.default)(this)) {
        throw new Error("Please do not generate the schema during the build building phase, use 'init' instead");
      }
      var fieldDataGeneratorsByFieldName = {};
      var fieldArgDataGeneratorsByFieldName = {};
      var newSpec = spec;
      if (knownTypes.indexOf(Type) === -1 && knownTypeNames.indexOf(Type.name) >= 0) {
        throw new Error(`GraphQL conflict for '${Type.name}' detected! Multiple versions of graphql exist in your node_modules?`);
      }
      if (Type === GraphQLSchema) {
        newSpec = builder.applyHooks(this, "GraphQLSchema", newSpec, {
          type: "GraphQLSchema",
          scope
        });
      } else if (Type === GraphQLObjectType) {
        var addDataGeneratorForField = function addDataGeneratorForField(fieldName, fn) {
          fn.displayName = fn.displayName || `${getNameFromType(Self)}:${fieldName}[${fn.name || "anonymous"}]`;
          fieldDataGeneratorsByFieldName[fieldName] = fieldDataGeneratorsByFieldName[fieldName] || [];
          fieldDataGeneratorsByFieldName[fieldName].push(fn);
        };
        var recurseDataGeneratorsForField = function recurseDataGeneratorsForField(fieldName) {
          var fn = function fn(parsedResolveInfoFragment, ReturnType) {
            for (var _len = arguments.length, rest = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              rest[_key - 2] = arguments[_key];
            }

            var args = parsedResolveInfoFragment.args;

            var _simplifyParsedResolv = _this.simplifyParsedResolveInfoFragmentWithType(parsedResolveInfoFragment, ReturnType),
                fields = _simplifyParsedResolv.fields;

            var results = [];
            var StrippedType = getNamedType(ReturnType);
            var fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(StrippedType);
            var argDataGeneratorsForSelfByFieldName = fieldArgDataGeneratorsByFieldNameByType.get(Self);
            if (argDataGeneratorsForSelfByFieldName) {
              var argDataGenerators = argDataGeneratorsForSelfByFieldName[fieldName];
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = (0, _getIterator3.default)(argDataGenerators), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var gen = _step3.value;

                  var local = ensureArray(gen.apply(undefined, [args, ReturnType].concat(rest)));
                  if (local) {
                    results.push.apply(results, (0, _toConsumableArray3.default)(local));
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
            if (fieldDataGeneratorsByFieldName && isCompositeType(StrippedType) && !isAbstractType(StrippedType)) {
              var typeFields = StrippedType.getFields();
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(fields)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var alias = _step4.value;

                  var field = fields[alias];
                  // Run generators with `field` as the `parsedResolveInfoFragment`, pushing results to `results`
                  var gens = fieldDataGeneratorsByFieldName[field.name];
                  if (gens) {
                    var _iteratorNormalCompletion5 = true;
                    var _didIteratorError5 = false;
                    var _iteratorError5 = undefined;

                    try {
                      for (var _iterator5 = (0, _getIterator3.default)(gens), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var _gen = _step5.value;

                        var _local = ensureArray(_gen.apply(undefined, [field, typeFields[field.name].type].concat(rest)));
                        if (_local) {
                          results.push.apply(results, (0, _toConsumableArray3.default)(_local));
                        }
                      }
                    } catch (err) {
                      _didIteratorError5 = true;
                      _iteratorError5 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                          _iterator5.return();
                        }
                      } finally {
                        if (_didIteratorError5) {
                          throw _iteratorError5;
                        }
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }
            }
            return results;
          };
          fn.displayName = `recurseDataGeneratorsForField(${getNameFromType(Self)}:${fieldName})`;
          addDataGeneratorForField(fieldName, fn);
          // get type from field, get
        };

        var commonContext = {
          type: "GraphQLObjectType",
          scope
        };
        newSpec = builder.applyHooks(this, "GraphQLObjectType", newSpec, (0, _assign2.default)({}, commonContext, {
          addDataGeneratorForField,
          recurseDataGeneratorsForField
        }), `|${newSpec.name}`);

        var rawSpec = newSpec;
        newSpec = (0, _assign2.default)({}, newSpec, {
          interfaces: function interfaces() {
            var interfacesContext = (0, _assign2.default)({}, commonContext, {
              Self,
              GraphQLObjectType: rawSpec
            });
            var rawInterfaces = rawSpec.interfaces || [];
            if (typeof rawInterfaces === "function") {
              rawInterfaces = rawInterfaces(interfacesContext);
            }
            return builder.applyHooks(_this, "GraphQLObjectType:interfaces", rawInterfaces, interfacesContext, `|${getNameFromType(Self)}`);
          },
          fields: function fields() {
            var processedFields = [];
            var fieldsContext = (0, _assign2.default)({}, commonContext, {
              addDataGeneratorForField,
              recurseDataGeneratorsForField,
              Self,
              GraphQLObjectType: rawSpec,
              fieldWithHooks: function (fieldName, spec, fieldScope) {
                if (!isString(fieldName)) {
                  throw new Error("It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.");
                }
                if (!fieldScope) {
                  throw new Error("All calls to `fieldWithHooks` must specify a `fieldScope` " + "argument that gives additional context about the field so " + "that further plugins may more easily understand the field. " + "Keys within this object should contain the phrase 'field' " + "since they will be merged into the parent objects scope and " + "are not allowed to clash. If you really have no additional " + "information to give, please just pass `{}`.");
                }

                var argDataGenerators = [];
                fieldArgDataGeneratorsByFieldName[fieldName] = argDataGenerators;

                var newSpec = spec;
                var context = (0, _assign2.default)({}, commonContext, {
                  Self,
                  addDataGenerator(fn) {
                    return addDataGeneratorForField(fieldName, fn);
                  },
                  addArgDataGenerator(fn) {
                    ensureName(fn);
                    argDataGenerators.push(fn);
                  },
                  getDataFromParsedResolveInfoFragment: function getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, ReturnType) {
                    var Type = getNamedType(ReturnType);
                    var data = {};

                    var _simplifyParsedResolv2 = _this.simplifyParsedResolveInfoFragmentWithType(parsedResolveInfoFragment, ReturnType),
                        fields = _simplifyParsedResolv2.fields,
                        args = _simplifyParsedResolv2.args;

                    // Args -> argDataGenerators


                    var _iteratorNormalCompletion6 = true;
                    var _didIteratorError6 = false;
                    var _iteratorError6 = undefined;

                    try {
                      for (var _iterator6 = (0, _getIterator3.default)(argDataGenerators), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                        var gen = _step6.value;

                        try {
                          mergeData(data, gen, ReturnType, args);
                        } catch (e) {
                          debug("Failed to execute argDataGenerator '%s' on %s of %s", gen.displayName || gen.name || "anonymous", fieldName, getNameFromType(Self));
                          throw e;
                        }
                      }

                      // finalSpec.type -> fieldData
                    } catch (err) {
                      _didIteratorError6 = true;
                      _iteratorError6 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion6 && _iterator6.return) {
                          _iterator6.return();
                        }
                      } finally {
                        if (_didIteratorError6) {
                          throw _iteratorError6;
                        }
                      }
                    }

                    if (!finalSpec) {
                      throw new Error("It's too early to call this! Call from within resolve");
                    }
                    var fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(Type);
                    if (fieldDataGeneratorsByFieldName && isCompositeType(Type) && !isAbstractType(Type)) {
                      var typeFields = Type.getFields();
                      var _iteratorNormalCompletion7 = true;
                      var _didIteratorError7 = false;
                      var _iteratorError7 = undefined;

                      try {
                        for (var _iterator7 = (0, _getIterator3.default)((0, _keys2.default)(fields)), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                          var alias = _step7.value;

                          var field = fields[alias];
                          var gens = fieldDataGeneratorsByFieldName[field.name];
                          if (gens) {
                            var FieldReturnType = typeFields[field.name].type;
                            var _iteratorNormalCompletion8 = true;
                            var _didIteratorError8 = false;
                            var _iteratorError8 = undefined;

                            try {
                              for (var _iterator8 = (0, _getIterator3.default)(gens), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                                var _gen2 = _step8.value;

                                mergeData(data, _gen2, FieldReturnType, field);
                              }
                            } catch (err) {
                              _didIteratorError8 = true;
                              _iteratorError8 = err;
                            } finally {
                              try {
                                if (!_iteratorNormalCompletion8 && _iterator8.return) {
                                  _iterator8.return();
                                }
                              } finally {
                                if (_didIteratorError8) {
                                  throw _iteratorError8;
                                }
                              }
                            }
                          }
                        }
                      } catch (err) {
                        _didIteratorError7 = true;
                        _iteratorError7 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion7 && _iterator7.return) {
                            _iterator7.return();
                          }
                        } finally {
                          if (_didIteratorError7) {
                            throw _iteratorError7;
                          }
                        }
                      }
                    }
                    return data;
                  },
                  scope: (0, _extend2.default)((0, _extend2.default)(scope, {
                    fieldName
                  }, `Within context for GraphQLObjectType '${rawSpec.name}'`), fieldScope, `Extending scope for field '${fieldName}' within context for GraphQLObjectType '${rawSpec.name}'`)
                });
                if (typeof newSpec === "function") {
                  newSpec = newSpec(context);
                }
                newSpec = builder.applyHooks(_this, "GraphQLObjectType:fields:field", newSpec, context, `|${getNameFromType(Self)}.fields.${fieldName}`);
                newSpec.args = newSpec.args || {};
                newSpec = (0, _assign2.default)({}, newSpec, {
                  args: builder.applyHooks(_this, "GraphQLObjectType:fields:field:args", newSpec.args, (0, _assign2.default)({}, context, {
                    field: newSpec,
                    returnType: newSpec.type
                  }), `|${getNameFromType(Self)}.fields.${fieldName}`)
                });
                var finalSpec = newSpec;
                processedFields.push(finalSpec);
                return finalSpec;
              }
            });
            var rawFields = rawSpec.fields || {};
            if (typeof rawFields === "function") {
              rawFields = rawFields(fieldsContext);
            }
            var fieldsSpec = builder.applyHooks(_this, "GraphQLObjectType:fields", rawFields, fieldsContext, `|${rawSpec.name}`);
            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.
            for (var _fieldName in fieldsSpec) {
              var fieldSpec = fieldsSpec[_fieldName];
              if (processedFields.indexOf(fieldSpec) < 0) {
                // We've not processed this yet; process it now!
                fieldsSpec[_fieldName] = fieldsContext.fieldWithHooks(_fieldName, fieldSpec, {
                  autoField: true // We don't have any additional information
                });
              }
            }
            return fieldsSpec;
          }
        });
      } else if (Type === GraphQLInputObjectType) {
        var _commonContext = {
          type: "GraphQLInputObjectType",
          scope
        };
        newSpec = builder.applyHooks(this, "GraphQLInputObjectType", newSpec, _commonContext, `|${newSpec.name}`);
        newSpec.fields = newSpec.fields || {};

        var _rawSpec = newSpec;
        newSpec = (0, _assign2.default)({}, newSpec, {
          fields: function fields() {
            var processedFields = [];
            var fieldsContext = (0, _assign2.default)({}, _commonContext, {
              Self,
              GraphQLInputObjectType: _rawSpec,
              fieldWithHooks: function (fieldName, spec) {
                var fieldScope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

                if (!isString(fieldName)) {
                  throw new Error("It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.");
                }
                var context = (0, _assign2.default)({}, _commonContext, {
                  Self,
                  scope: (0, _extend2.default)((0, _extend2.default)(scope, {
                    fieldName
                  }, `Within context for GraphQLInputObjectType '${_rawSpec.name}'`), fieldScope, `Extending scope for field '${fieldName}' within context for GraphQLInputObjectType '${_rawSpec.name}'`)
                });
                var newSpec = spec;
                if (typeof newSpec === "function") {
                  newSpec = newSpec(context);
                }
                newSpec = builder.applyHooks(_this, "GraphQLInputObjectType:fields:field", newSpec, context, `|${getNameFromType(Self)}.fields.${fieldName}`);
                var finalSpec = newSpec;
                processedFields.push(finalSpec);
                return finalSpec;
              }
            });
            var rawFields = _rawSpec.fields;
            if (typeof rawFields === "function") {
              rawFields = rawFields(fieldsContext);
            }
            var fieldsSpec = builder.applyHooks(_this, "GraphQLInputObjectType:fields", rawFields, fieldsContext, `|${getNameFromType(Self)}`);
            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.
            for (var _fieldName2 in fieldsSpec) {
              var fieldSpec = fieldsSpec[_fieldName2];
              if (processedFields.indexOf(fieldSpec) < 0) {
                // We've not processed this yet; process it now!
                fieldsSpec[_fieldName2] = fieldsContext.fieldWithHooks(_fieldName2, fieldSpec, {
                  autoField: true // We don't have any additional information
                });
              }
            }
            return fieldsSpec;
          }
        });
      } else if (Type === GraphQLEnumType) {
        var _commonContext2 = {
          type: "GraphQLEnumType",
          scope
        };
        newSpec = builder.applyHooks(this, "GraphQLEnumType", newSpec, _commonContext2, `|${newSpec.name}`);

        newSpec.values = builder.applyHooks(this, "GraphQLEnumType:values", newSpec.values, _commonContext2, `|${newSpec.name}`);
        var values = newSpec.values;
        newSpec.values = (0, _keys2.default)(values).reduce(function (memo, valueKey) {
          var value = values[valueKey];
          var newValue = builder.applyHooks(_this, "GraphQLEnumType:values:value", value, _commonContext2, `|${newSpec.name}|${valueKey}`);
          memo[valueKey] = newValue;
          return memo;
        }, {});
      }
      var finalSpec = newSpec;

      var Self = new Type(finalSpec);
      if (!(Self instanceof GraphQLSchema) && returnNullOnInvalid) {
        try {
          if (isCompositeType(Self) && !isAbstractType(Self)) {
            Self.getFields();
          }
        } catch (e) {
          // This is the error we're expecting to handle:
          // https://github.com/graphql/graphql-js/blob/831598ba76f015078ecb6c5c1fbaf133302f3f8e/src/type/definition.js#L526-L531
          var isProbablyAnEmptyObjectError = !!e.message.match(/function which returns such an object/);
          if (!isProbablyAnEmptyObjectError) {
            // XXX: Improve this
            // eslint-disable-next-line no-console
            console.warn(`An error occurred, it might be okay but it doesn't look like the error we were expecting... run with envvar 'DEBUG="graphile-build:warn"' to view the error`);
            debugWarn(e);
          }
          return null;
        }
      }

      if (finalSpec.name) {
        if (allTypes[finalSpec.name]) {
          throw new Error(`Type '${finalSpec.name}' has already been registered!`);
        }
        allTypes[finalSpec.name] = Self;
      }
      fieldDataGeneratorsByFieldNameByType.set(Self, fieldDataGeneratorsByFieldName);
      fieldArgDataGeneratorsByFieldNameByType.set(Self, fieldArgDataGeneratorsByFieldName);
      return Self;
    },
    fieldDataGeneratorsByType: fieldDataGeneratorsByFieldNameByType, // @deprecated
    fieldDataGeneratorsByFieldNameByType,
    fieldArgDataGeneratorsByFieldNameByType
  };
}
//# sourceMappingURL=makeNewBuild.js.map