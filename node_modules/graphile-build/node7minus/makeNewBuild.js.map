{"version":3,"sources":["../src/makeNewBuild.js"],"names":["makeNewBuild","graphql","isString","str","isDev","indexOf","process","env","NODE_ENV","debug","debugWarn","getNameFromType","Type","GraphQLSchema","name","GraphQLObjectType","GraphQLInputObjectType","GraphQLEnumType","getNamedType","isCompositeType","isAbstractType","mergeData","data","gen","ReturnType","arg","results","ensureArray","result","k","value","newData","push","knownTypes","knownTypeNames","map","val","Array","isArray","ensureName","fn","displayName","enabled","console","trace","builder","allTypes","fieldDataGeneratorsByFieldNameByType","fieldArgDataGeneratorsByFieldNameByType","graphileBuildVersion","parseResolveInfo","simplifyParsedResolveInfoFragmentWithType","getAliasFromResolveInfo","resolveAlias","_args","_context","resolveInfo","alias","addType","type","Error","getTypeByName","typeName","extend","newWithHooks","spec","inScope","returnNullOnInvalid","scope","warn","fieldDataGeneratorsByFieldName","fieldArgDataGeneratorsByFieldName","newSpec","applyHooks","addDataGeneratorForField","fieldName","Self","recurseDataGeneratorsForField","parsedResolveInfoFragment","rest","args","fields","StrippedType","get","argDataGeneratorsForSelfByFieldName","argDataGenerators","local","typeFields","getFields","field","gens","commonContext","rawSpec","interfaces","interfacesContext","rawInterfaces","processedFields","fieldsContext","fieldWithHooks","fieldScope","context","addDataGenerator","addArgDataGenerator","getDataFromParsedResolveInfoFragment","e","finalSpec","FieldReturnType","returnType","rawFields","fieldsSpec","fieldSpec","autoField","values","reduce","memo","valueKey","newValue","isProbablyAnEmptyObjectError","message","match","set","fieldDataGeneratorsByType"],"mappings":"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","file":"makeNewBuild.js","sourcesContent":["// @flow\n\nimport * as graphql from \"graphql\";\nimport type {\n  GraphQLNamedType,\n  GraphQLInputField,\n  GraphQLFieldResolver,\n  GraphQLType,\n} from \"graphql\";\nimport {\n  parseResolveInfo,\n  simplifyParsedResolveInfoFragmentWithType,\n  getAliasFromResolveInfo,\n} from \"graphql-parse-resolve-info\";\nimport debugFactory from \"debug\";\nimport type { ResolveTree } from \"graphql-parse-resolve-info\";\n\nimport type SchemaBuilder, {\n  Build,\n  Context,\n  Scope,\n  DataForType,\n} from \"./SchemaBuilder\";\n\nimport extend from \"./extend\";\n\nimport { version } from \"../package.json\";\n\nconst isString = str => typeof str === \"string\";\nconst isDev = [\"test\", \"development\"].indexOf(process.env.NODE_ENV) >= 0;\nconst debug = debugFactory(\"graphile-build\");\nconst debugWarn = debugFactory(\"graphile-build:warn\");\n\ntype MetaData = {\n  [string]: Array<mixed>,\n};\ntype DataGeneratorFunction = (\n  parsedResolveInfoFragment: ResolveTree,\n  ReturnType: GraphQLType,\n  ...args: Array<mixed>\n) => Array<MetaData>;\n\ntype FieldSpecIsh = {\n  type?: GraphQLType,\n  args?: {},\n  resolve?: GraphQLFieldResolver<*, *>,\n  deprecationReason?: string,\n  description?: ?string,\n};\n\ntype ContextAndGenerators =\n  | Context\n  | {\n      addDataGenerator: DataGeneratorFunction => void,\n      addArgDataGenerator: DataGeneratorFunction => void,\n      getDataFromParsedResolveInfoFragment: (\n        parsedResolveInfoFragment: ResolveTree,\n        Type: GraphQLType\n      ) => DataForType,\n    };\n\nexport type FieldWithHooksFunction = (\n  fieldName: string,\n  spec: FieldSpecIsh | (ContextAndGenerators => FieldSpecIsh),\n  fieldScope?: {}\n) => {};\n\nexport type InputFieldWithHooksFunction = (\n  fieldName: string,\n  spec: GraphQLInputField,\n  fieldScope?: {}\n) => GraphQLInputField;\n\nfunction getNameFromType(Type: GraphQLNamedType | GraphQLSchema) {\n  if (Type instanceof GraphQLSchema) {\n    return \"schema\";\n  } else {\n    return Type.name;\n  }\n}\n\nconst {\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLEnumType,\n  getNamedType,\n  isCompositeType,\n  isAbstractType,\n} = graphql;\n\nconst mergeData = (\n  data: MetaData,\n  gen: DataGeneratorFunction,\n  ReturnType,\n  arg\n) => {\n  const results: ?Array<MetaData> = ensureArray(gen(arg, ReturnType, data));\n  if (!results) {\n    return;\n  }\n  for (const result: MetaData of results) {\n    for (const k of Object.keys(result)) {\n      data[k] = data[k] || [];\n      const value: mixed = result[k];\n      const newData: ?Array<mixed> = ensureArray(value);\n      if (newData) {\n        data[k].push(...newData);\n      }\n    }\n  }\n};\n\nconst knownTypes = [\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLEnumType,\n];\nconst knownTypeNames = knownTypes.map(k => k.name);\n\nfunction ensureArray<T>(val: void | Array<T> | T): void | Array<T> {\n  if (val == null) {\n    return;\n  } else if (Array.isArray(val)) {\n    return val;\n  } else {\n    return [val];\n  }\n}\n\n// eslint-disable-next-line no-unused-vars\nlet ensureName = fn => {};\nif ([\"development\", \"test\"].indexOf(process.env.NODE_ENV) >= 0) {\n  ensureName = fn => {\n    if (isDev && !fn.displayName && !fn.name && debug.enabled) {\n      // eslint-disable-next-line no-console\n      console.trace(\n        \"WARNING: you've added a function with no name as an argDataGenerator, doing so may make debugging more challenging\"\n      );\n    }\n  };\n}\n\nexport default function makeNewBuild(builder: SchemaBuilder): Build {\n  const allTypes = {};\n\n  // Every object type gets fieldData associated with each of its\n  // fields.\n\n  // When a field is defined, it may add to this field data.\n\n  // When something resolves referencing this type, the resolver may\n  // request the fieldData, e.g. to perform optimisations.\n\n  // fieldData is an object whose keys are the fields on this\n  // GraphQLObjectType and whose values are an object (whose keys are\n  // arbitrary namespaced keys and whose values are arrays of\n  // information of this kind)\n  const fieldDataGeneratorsByFieldNameByType = new Map();\n  const fieldArgDataGeneratorsByFieldNameByType = new Map();\n\n  return {\n    graphileBuildVersion: version,\n    graphql,\n    parseResolveInfo,\n    simplifyParsedResolveInfoFragmentWithType,\n    getAliasFromResolveInfo,\n    resolveAlias(data, _args, _context, resolveInfo) {\n      const alias = getAliasFromResolveInfo(resolveInfo);\n      return data[alias];\n    },\n    addType(type: GraphQLNamedType): void {\n      if (!type.name) {\n        throw new Error(\n          `addType must only be called with named types, try using require('graphql').getNamedType`\n        );\n      }\n      if (allTypes[type.name] && allTypes[type.name] !== type) {\n        throw new Error(`There's already a type with the name: ${type.name}`);\n      }\n      allTypes[type.name] = type;\n    },\n    getTypeByName(typeName) {\n      return allTypes[typeName];\n    },\n    extend,\n    newWithHooks<T: GraphQLNamedType | GraphQLSchema, ConfigType: *>(\n      Type: Class<T>,\n      spec: ConfigType,\n      inScope: Scope,\n      returnNullOnInvalid = false\n    ): ?T {\n      const scope = inScope || {};\n      if (!inScope) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `No scope was provided to new ${getNameFromType(Type)}[name=${\n            spec.name\n          }], it's highly recommended that you add a scope so other hooks can easily reference your object - please check usage of 'newWithHooks'. To mute this message, just pass an empty object.`\n        );\n      }\n      if (!Type) {\n        throw new Error(\"No type specified!\");\n      }\n      if (!this.newWithHooks || !Object.isFrozen(this)) {\n        throw new Error(\n          \"Please do not generate the schema during the build building phase, use 'init' instead\"\n        );\n      }\n      const fieldDataGeneratorsByFieldName = {};\n      const fieldArgDataGeneratorsByFieldName = {};\n      let newSpec = spec;\n      if (\n        knownTypes.indexOf(Type) === -1 &&\n        knownTypeNames.indexOf(Type.name) >= 0\n      ) {\n        throw new Error(\n          `GraphQL conflict for '${\n            Type.name\n          }' detected! Multiple versions of graphql exist in your node_modules?`\n        );\n      }\n      if (Type === GraphQLSchema) {\n        newSpec = builder.applyHooks(this, \"GraphQLSchema\", newSpec, {\n          type: \"GraphQLSchema\",\n          scope,\n        });\n      } else if (Type === GraphQLObjectType) {\n        const addDataGeneratorForField = (\n          fieldName,\n          fn: DataGeneratorFunction\n        ) => {\n          fn.displayName =\n            fn.displayName ||\n            `${getNameFromType(Self)}:${fieldName}[${fn.name || \"anonymous\"}]`;\n          fieldDataGeneratorsByFieldName[fieldName] =\n            fieldDataGeneratorsByFieldName[fieldName] || [];\n          fieldDataGeneratorsByFieldName[fieldName].push(fn);\n        };\n        const recurseDataGeneratorsForField = fieldName => {\n          const fn = (parsedResolveInfoFragment, ReturnType, ...rest) => {\n            const { args } = parsedResolveInfoFragment;\n            const { fields } = this.simplifyParsedResolveInfoFragmentWithType(\n              parsedResolveInfoFragment,\n              ReturnType\n            );\n            const results = [];\n            const StrippedType: GraphQLNamedType = getNamedType(ReturnType);\n            const fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(\n              StrippedType\n            );\n            const argDataGeneratorsForSelfByFieldName = fieldArgDataGeneratorsByFieldNameByType.get(\n              Self\n            );\n            if (argDataGeneratorsForSelfByFieldName) {\n              const argDataGenerators =\n                argDataGeneratorsForSelfByFieldName[fieldName];\n              for (const gen of argDataGenerators) {\n                const local = ensureArray(gen(args, ReturnType, ...rest));\n                if (local) {\n                  results.push(...local);\n                }\n              }\n            }\n            if (\n              fieldDataGeneratorsByFieldName &&\n              isCompositeType(StrippedType) &&\n              !isAbstractType(StrippedType)\n            ) {\n              const typeFields = StrippedType.getFields();\n              for (const alias of Object.keys(fields)) {\n                const field = fields[alias];\n                // Run generators with `field` as the `parsedResolveInfoFragment`, pushing results to `results`\n                const gens = fieldDataGeneratorsByFieldName[field.name];\n                if (gens) {\n                  for (const gen of gens) {\n                    const local = ensureArray(\n                      gen(field, typeFields[field.name].type, ...rest)\n                    );\n                    if (local) {\n                      results.push(...local);\n                    }\n                  }\n                }\n              }\n            }\n            return results;\n          };\n          fn.displayName = `recurseDataGeneratorsForField(${getNameFromType(\n            Self\n          )}:${fieldName})`;\n          addDataGeneratorForField(fieldName, fn);\n          // get type from field, get\n        };\n\n        const commonContext = {\n          type: \"GraphQLObjectType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLObjectType\",\n          newSpec,\n          Object.assign({}, commonContext, {\n            addDataGeneratorForField,\n            recurseDataGeneratorsForField,\n          }),\n          `|${newSpec.name}`\n        );\n\n        const rawSpec = newSpec;\n        newSpec = Object.assign({}, newSpec, {\n          interfaces: () => {\n            const interfacesContext = Object.assign({}, commonContext, {\n              Self,\n              GraphQLObjectType: rawSpec,\n            });\n            let rawInterfaces = rawSpec.interfaces || [];\n            if (typeof rawInterfaces === \"function\") {\n              rawInterfaces = rawInterfaces(interfacesContext);\n            }\n            return builder.applyHooks(\n              this,\n              \"GraphQLObjectType:interfaces\",\n              rawInterfaces,\n              interfacesContext,\n              `|${getNameFromType(Self)}`\n            );\n          },\n          fields: () => {\n            const processedFields = [];\n            const fieldsContext = Object.assign({}, commonContext, {\n              addDataGeneratorForField,\n              recurseDataGeneratorsForField,\n              Self,\n              GraphQLObjectType: rawSpec,\n              fieldWithHooks: ((fieldName, spec, fieldScope) => {\n                if (!isString(fieldName)) {\n                  throw new Error(\n                    \"It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.\"\n                  );\n                }\n                if (!fieldScope) {\n                  throw new Error(\n                    \"All calls to `fieldWithHooks` must specify a `fieldScope` \" +\n                      \"argument that gives additional context about the field so \" +\n                      \"that further plugins may more easily understand the field. \" +\n                      \"Keys within this object should contain the phrase 'field' \" +\n                      \"since they will be merged into the parent objects scope and \" +\n                      \"are not allowed to clash. If you really have no additional \" +\n                      \"information to give, please just pass `{}`.\"\n                  );\n                }\n\n                let argDataGenerators = [];\n                fieldArgDataGeneratorsByFieldName[\n                  fieldName\n                ] = argDataGenerators;\n\n                let newSpec = spec;\n                let context = Object.assign({}, commonContext, {\n                  Self,\n                  addDataGenerator(fn) {\n                    return addDataGeneratorForField(fieldName, fn);\n                  },\n                  addArgDataGenerator(fn) {\n                    ensureName(fn);\n                    argDataGenerators.push(fn);\n                  },\n                  getDataFromParsedResolveInfoFragment: (\n                    parsedResolveInfoFragment,\n                    ReturnType\n                  ): DataForType => {\n                    const Type: GraphQLNamedType = getNamedType(ReturnType);\n                    const data = {};\n\n                    const {\n                      fields,\n                      args,\n                    } = this.simplifyParsedResolveInfoFragmentWithType(\n                      parsedResolveInfoFragment,\n                      ReturnType\n                    );\n\n                    // Args -> argDataGenerators\n                    for (const gen of argDataGenerators) {\n                      try {\n                        mergeData(data, gen, ReturnType, args);\n                      } catch (e) {\n                        debug(\n                          \"Failed to execute argDataGenerator '%s' on %s of %s\",\n                          gen.displayName || gen.name || \"anonymous\",\n                          fieldName,\n                          getNameFromType(Self)\n                        );\n                        throw e;\n                      }\n                    }\n\n                    // finalSpec.type -> fieldData\n                    if (!finalSpec) {\n                      throw new Error(\n                        \"It's too early to call this! Call from within resolve\"\n                      );\n                    }\n                    const fieldDataGeneratorsByFieldName = fieldDataGeneratorsByFieldNameByType.get(\n                      Type\n                    );\n                    if (\n                      fieldDataGeneratorsByFieldName &&\n                      isCompositeType(Type) &&\n                      !isAbstractType(Type)\n                    ) {\n                      const typeFields = Type.getFields();\n                      for (const alias of Object.keys(fields)) {\n                        const field = fields[alias];\n                        const gens = fieldDataGeneratorsByFieldName[field.name];\n                        if (gens) {\n                          const FieldReturnType = typeFields[field.name].type;\n                          for (const gen of gens) {\n                            mergeData(data, gen, FieldReturnType, field);\n                          }\n                        }\n                      }\n                    }\n                    return data;\n                  },\n                  scope: extend(\n                    extend(\n                      scope,\n                      {\n                        fieldName,\n                      },\n                      `Within context for GraphQLObjectType '${rawSpec.name}'`\n                    ),\n                    fieldScope,\n                    `Extending scope for field '${fieldName}' within context for GraphQLObjectType '${\n                      rawSpec.name\n                    }'`\n                  ),\n                });\n                if (typeof newSpec === \"function\") {\n                  newSpec = newSpec(context);\n                }\n                newSpec = builder.applyHooks(\n                  this,\n                  \"GraphQLObjectType:fields:field\",\n                  newSpec,\n                  context,\n                  `|${getNameFromType(Self)}.fields.${fieldName}`\n                );\n                newSpec.args = newSpec.args || {};\n                newSpec = Object.assign({}, newSpec, {\n                  args: builder.applyHooks(\n                    this,\n                    \"GraphQLObjectType:fields:field:args\",\n                    newSpec.args,\n                    Object.assign({}, context, {\n                      field: newSpec,\n                      returnType: newSpec.type,\n                    }),\n                    `|${getNameFromType(Self)}.fields.${fieldName}`\n                  ),\n                });\n                const finalSpec = newSpec;\n                processedFields.push(finalSpec);\n                return finalSpec;\n              }: FieldWithHooksFunction),\n            });\n            let rawFields = rawSpec.fields || {};\n            if (typeof rawFields === \"function\") {\n              rawFields = rawFields(fieldsContext);\n            }\n            const fieldsSpec = builder.applyHooks(\n              this,\n              \"GraphQLObjectType:fields\",\n              rawFields,\n              fieldsContext,\n              `|${rawSpec.name}`\n            );\n            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.\n            for (const fieldName in fieldsSpec) {\n              const fieldSpec = fieldsSpec[fieldName];\n              if (processedFields.indexOf(fieldSpec) < 0) {\n                // We've not processed this yet; process it now!\n                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(\n                  fieldName,\n                  fieldSpec,\n                  {\n                    autoField: true, // We don't have any additional information\n                  }\n                );\n              }\n            }\n            return fieldsSpec;\n          },\n        });\n      } else if (Type === GraphQLInputObjectType) {\n        const commonContext = {\n          type: \"GraphQLInputObjectType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLInputObjectType\",\n          newSpec,\n          commonContext,\n          `|${newSpec.name}`\n        );\n        newSpec.fields = newSpec.fields || {};\n\n        const rawSpec = newSpec;\n        newSpec = Object.assign({}, newSpec, {\n          fields: () => {\n            const processedFields = [];\n            const fieldsContext = Object.assign({}, commonContext, {\n              Self,\n              GraphQLInputObjectType: rawSpec,\n              fieldWithHooks: ((fieldName, spec, fieldScope = {}) => {\n                if (!isString(fieldName)) {\n                  throw new Error(\n                    \"It looks like you forgot to pass the fieldName to `fieldWithHooks`, we're sorry this is current necessary.\"\n                  );\n                }\n                let context = Object.assign({}, commonContext, {\n                  Self,\n                  scope: extend(\n                    extend(\n                      scope,\n                      {\n                        fieldName,\n                      },\n                      `Within context for GraphQLInputObjectType '${\n                        rawSpec.name\n                      }'`\n                    ),\n                    fieldScope,\n                    `Extending scope for field '${fieldName}' within context for GraphQLInputObjectType '${\n                      rawSpec.name\n                    }'`\n                  ),\n                });\n                let newSpec = spec;\n                if (typeof newSpec === \"function\") {\n                  newSpec = newSpec(context);\n                }\n                newSpec = builder.applyHooks(\n                  this,\n                  \"GraphQLInputObjectType:fields:field\",\n                  newSpec,\n                  context,\n                  `|${getNameFromType(Self)}.fields.${fieldName}`\n                );\n                const finalSpec = newSpec;\n                processedFields.push(finalSpec);\n                return finalSpec;\n              }: InputFieldWithHooksFunction),\n            });\n            let rawFields = rawSpec.fields;\n            if (typeof rawFields === \"function\") {\n              rawFields = rawFields(fieldsContext);\n            }\n            const fieldsSpec = builder.applyHooks(\n              this,\n              \"GraphQLInputObjectType:fields\",\n              rawFields,\n              fieldsContext,\n              `|${getNameFromType(Self)}`\n            );\n            // Finally, check through all the fields that they've all been processed; any that have not we should do so now.\n            for (const fieldName in fieldsSpec) {\n              const fieldSpec = fieldsSpec[fieldName];\n              if (processedFields.indexOf(fieldSpec) < 0) {\n                // We've not processed this yet; process it now!\n                fieldsSpec[fieldName] = fieldsContext.fieldWithHooks(\n                  fieldName,\n                  fieldSpec,\n                  {\n                    autoField: true, // We don't have any additional information\n                  }\n                );\n              }\n            }\n            return fieldsSpec;\n          },\n        });\n      } else if (Type === GraphQLEnumType) {\n        const commonContext = {\n          type: \"GraphQLEnumType\",\n          scope,\n        };\n        newSpec = builder.applyHooks(\n          this,\n          \"GraphQLEnumType\",\n          newSpec,\n          commonContext,\n          `|${newSpec.name}`\n        );\n\n        newSpec.values = builder.applyHooks(\n          this,\n          \"GraphQLEnumType:values\",\n          newSpec.values,\n          commonContext,\n          `|${newSpec.name}`\n        );\n        const values = newSpec.values;\n        newSpec.values = Object.keys(values).reduce((memo, valueKey) => {\n          const value = values[valueKey];\n          const newValue = builder.applyHooks(\n            this,\n            \"GraphQLEnumType:values:value\",\n            value,\n            commonContext,\n            `|${newSpec.name}|${valueKey}`\n          );\n          memo[valueKey] = newValue;\n          return memo;\n        }, {});\n      }\n      const finalSpec: ConfigType = newSpec;\n\n      const Self: T = new Type(finalSpec);\n      if (!(Self instanceof GraphQLSchema) && returnNullOnInvalid) {\n        try {\n          if (isCompositeType(Self) && !isAbstractType(Self)) {\n            Self.getFields();\n          }\n        } catch (e) {\n          // This is the error we're expecting to handle:\n          // https://github.com/graphql/graphql-js/blob/831598ba76f015078ecb6c5c1fbaf133302f3f8e/src/type/definition.js#L526-L531\n          const isProbablyAnEmptyObjectError = !!e.message.match(\n            /function which returns such an object/\n          );\n          if (!isProbablyAnEmptyObjectError) {\n            // XXX: Improve this\n            // eslint-disable-next-line no-console\n            console.warn(\n              `An error occurred, it might be okay but it doesn't look like the error we were expecting... run with envvar 'DEBUG=\"graphile-build:warn\"' to view the error`\n            );\n            debugWarn(e);\n          }\n          return null;\n        }\n      }\n\n      if (finalSpec.name) {\n        if (allTypes[finalSpec.name]) {\n          throw new Error(\n            `Type '${finalSpec.name}' has already been registered!`\n          );\n        }\n        allTypes[finalSpec.name] = Self;\n      }\n      fieldDataGeneratorsByFieldNameByType.set(\n        Self,\n        fieldDataGeneratorsByFieldName\n      );\n      fieldArgDataGeneratorsByFieldNameByType.set(\n        Self,\n        fieldArgDataGeneratorsByFieldName\n      );\n      return Self;\n    },\n    fieldDataGeneratorsByType: fieldDataGeneratorsByFieldNameByType, // @deprecated\n    fieldDataGeneratorsByFieldNameByType,\n    fieldArgDataGeneratorsByFieldNameByType,\n  };\n}\n"]}