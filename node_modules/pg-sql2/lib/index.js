"use strict";

if (parseFloat(process.versions.node) < 4) {
  throw new Error("This library requires Node v4 or above; we've detected v${parseFloat(process.versions.node)}");
}

var isSymbol = function isSymbol(sym) {
  return typeof sym === "symbol";
};
var isNil = function isNil(o) {
  return o === null || o === undefined;
};
var debug = require("debug")("pg-sql2");

function debugError(err) {
  debug(err);
  return err;
}

var $$trusted = Symbol("trusted");
/*::
type SQLRawNode = {
  text: string,
  type: 'RAW',
}
type SQLIdentifierNode = {
  names: Array<mixed>,
  type: 'IDENTIFIER',
}
type SQLValueNode = {
  value: mixed,
  type: 'VALUE',
}

export opaque type SQLNode = SQLRawNode | SQLValueNode | SQLIdentifierNode
export opaque type SQLQuery = Array<SQLNode>
export type SQL = SQLNode | SQLQuery;

type QueryConfig = {
  text: string,
  values: Array<mixed>
};
*/

function makeTrustedNode /*:: <Node>*/(node /*: Node */) /*: Node */{
  Object.defineProperty(node, $$trusted, {
    enumerable: false,
    configurable: false,
    value: true
  });
  return node;
}

function makeRawNode(text /*: string */) /*: SQLRawNode */{
  return makeTrustedNode({ type: "RAW", text });
}

function makeIdentifierNode(names /*: Array<mixed> */
) /*: SQLIdentifierNode */{
  return makeTrustedNode({ type: "IDENTIFIER", names });
}

function makeValueNode(value /*: mixed */) /*: SQLValueNode */{
  return makeTrustedNode({ type: "VALUE", value });
}

function ensureNonEmptyArray(array) {
  var allowZeroLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!Array.isArray(array)) {
    throw debugError(new Error("Expected array"));
  }
  if (array.length < 1 && !allowZeroLength) {
    throw debugError(new Error("Expected non-empty array"));
  }
  array.forEach(function (entry, idx) {
    if (entry == null) {
      throw debugError(new Error(`Array index ${idx} is ${String(entry)}`));
    }
  });
  return array;
}

function compile(sql /*: SQLQuery | SQLNode */) /*: QueryConfig*/{
  // Join this to generate the SQL query
  var sqlFragments = [];

  // Values hold the JavaScript values that are represented in the query
  // string by placeholders. They are eager because they were provided before
  // compile time.
  var values = [];

  // When we come accross a symbol in our identifier, we create a unique
  // alias for it that shouldn’t be in the users schema. This helps maintain
  // sanity when constructing large Sql queries with many aliases.
  var nextSymbolId = 0;
  var symbolToIdentifier = new Map();

  var items = Array.isArray(sql) ? sql : [sql];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var rawItem = _step.value;

      var item /*: SQLNode */ = enforceValidNode(rawItem);
      switch (item.type) {
        case "RAW":
          sqlFragments.push(item.text);
          break;
        case "IDENTIFIER":
          if (item.names.length === 0) throw new Error("Identifier must have a name");

          sqlFragments.push(item.names.map(function (rawName) {
            if (typeof rawName === "string") {
              var _name /*: string */ = rawName;
              return escapeSqlIdentifier(_name);
            }
            if (!isSymbol(rawName)) {
              throw debugError(new Error(`Expected string or symbol, received '${String(rawName)}'`));
            }
            var name /*: Symbol */ = /*:: (*/rawName /*: any) */;

            // Get the correct identifier string for this symbol.
            var identifier = symbolToIdentifier.get(name);

            // If there is no identifier, create one and set it.
            if (!identifier) {
              identifier = `__local_${nextSymbolId++}__`;
              symbolToIdentifier.set(name, identifier);
            }

            // Return the identifier. Since we create it, we won’t have to
            // escape it because we know all of the characters are safe.
            return identifier;
          }).join("."));
          break;
        case "VALUE":
          values.push(item.value);
          sqlFragments.push(`$${values.length}`);
          break;
        default:
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var text = sqlFragments.join("");
  return {
    text,
    values
  };
}

function enforceValidNode(node /*: mixed */) /*: SQLNode */{
  if (node != null && typeof node === "object") {
    var isRaw = node.type === "RAW" && typeof node.text === "string";
    var isIdentifier = node.type === "IDENTIFIER" && Array.isArray(node.names) && node.names.every(function (name) {
      return typeof name === "string" || typeof name === "symbol";
    });
    var isValue = node.type === "VALUE";

    // $FlowFixMe: flow doesn't like symbols here?
    var isTrusted = node[$$trusted] === true;
    if ((isRaw || isIdentifier || isValue) && isTrusted) {
      // $FlowFixMe: this has been validated
      return node;
    }
  }
  throw new Error(`Expected SQL item, instead received '${String(node)}'.`);
}

/**
 * A template string tag that creates a `Sql` query out of some strings and
 * some values. Use this to construct all PostgreSQL queries to avoid SQL
 * injection.
 *
 * Note that using this function, the user *must* specify if they are injecting
 * raw text. This makes a SQL injection vulnerability harder to create.
 */
function query(strings /*: mixed */
) /*: Array<mixed> */
/*: SQLQuery */{
  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }

  if (!Array.isArray(strings)) {
    throw new Error("sql.query should be used as a template literal, not a function call!");
  }
  return strings.reduce(function (items, text, i) {
    if (typeof text !== "string") {
      throw new Error("sql.query should be used as a template literal, not a function call.");
    }
    if (!values[i]) {
      return items.concat(makeRawNode(text));
    } else {
      var _value = values[i];
      if (Array.isArray(_value)) {
        var nodes /*: SQLQuery */ = _value.map(enforceValidNode);
        return items.concat(makeRawNode(text), nodes);
      } else {
        var node /*: SQLNode */ = enforceValidNode(_value);
        return items.concat(makeRawNode(text), node);
      }
    }
  }, []);
}

/**
 * Creates a Sql item for some raw Sql text. Just plain ol‘ raw Sql. This
 * method is dangerous though because it involves no escaping, so proceed
 * with caution!
 */
var raw = function raw(text /*: mixed */) {
  return makeRawNode(String(text));
};

/**
 * Creates a Sql item for a Sql identifier. A Sql identifier is anything like
 * a table, schema, or column name. An identifier may also have a namespace,
 * thus why many names are accepted.
 */
var identifier = function identifier() {
  for (var _len2 = arguments.length, names = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    names[_key2] = arguments[_key2];
  }

  return (/*: Array<mixed> */makeIdentifierNode(ensureNonEmptyArray(names))
  );
};

/**
 * Creates a Sql item for a value that will be included in our final query.
 * This value will be added in a way which avoids Sql injection.
 */
var value = function value(val /*: mixed */) {
  return makeValueNode(val);
};

/**
 * If the value is simple will inline it into the query, otherwise will defer
 * to value.
 */
var literal = function literal(val /*: mixed */) {
  if (typeof val === "string" && val.match(/^[a-zA-Z0-9_-]*$/)) {
    return raw(`'${val}'`);
  } else if (typeof val === "number" && Number.isFinite(val)) {
    if (Number.isInteger(val)) {
      return raw(String(val));
    } else {
      return raw(`'${0 + val}'::float`);
    }
  } else if (typeof val === "boolean") {
    if (val) {
      return raw(`TRUE`);
    } else {
      return raw(`FALSE`);
    }
  } else if (isNil(val)) {
    return raw(`NULL`);
  } else {
    return makeValueNode(val);
  }
};

/**
 * Join some Sql items together seperated by a string. Useful when dealing
 * with lists of Sql items that doesn’t make sense as a Sql query.
 */
var join = function join(rawItems /*: mixed */) {
  var rawSeparator /*: mixed */ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

  if (!Array.isArray(rawItems)) {
    throw new Error("Items to join must be an array");
  }
  var items = rawItems;
  if (typeof rawSeparator !== "string") {
    throw new Error("Invalid separator - must be a string");
  }
  var separator = rawSeparator;
  return ensureNonEmptyArray(items, true).reduce(function (currentItems, rawItem, i) {
    var item = void 0 /*: SQLNode | SQLQuery */;
    if (Array.isArray(rawItem)) {
      item = rawItem.map(enforceValidNode);
    } else {
      item = enforceValidNode(rawItem);
    }
    if (i === 0 || !separator) {
      return currentItems.concat(item);
    } else {
      return currentItems.concat(makeRawNode(separator), item);
    }
  }, []);
};

// Copied from https://github.com/brianc/node-postgres/blob/860cccd53105f7bc32fed8b1de69805f0ecd12eb/lib/client.js#L285-L302
// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
function escapeSqlIdentifier(str) {
  var escaped = '"';

  for (var i = 0; i < str.length; i++) {
    var c = str[i];
    if (c === '"') {
      escaped += c + c;
    } else {
      escaped += c;
    }
  }

  escaped += '"';

  return escaped;
}

// The types we export are stricter so people get the right hinting

exports.query = function sqlQuery(strings /*: string[] */
) /*: Array<SQL> */
/*: SQLQuery */{
  for (var _len3 = arguments.length, values = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    values[_key3 - 1] = arguments[_key3];
  }

  return query.apply(undefined, [strings].concat(values));
};

exports.fragment = exports.query;

exports.raw = function sqlRaw(text /*: string */) /*: SQLNode */{
  return raw(text);
};

exports.identifier = function sqlIdentifier() /*: Array<string | Symbol> */
/*: SQLNode */{
  return identifier.apply(undefined, arguments);
};

exports.value = function sqlValue(val /*: mixed */) /*: SQLNode */{
  return value(val);
};

exports.literal = function sqlLiteral(val /*: mixed */) /*: SQLNode */{
  return literal(val);
};

exports.join = function sqlJoin(items /*: Array<SQL> */
) /*: SQLQuery */{
  var separator /*: string */ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

  return join(items, separator);
};

exports.compile = function sqlCompile(sql /*: SQLQuery */) /*: QueryConfig */{
  return compile(sql);
};

exports.null = exports.literal(null);
exports.blank = exports.query``;