{"version":3,"sources":["../../src/plugins/PgJWTPlugin.js"],"names":["PgJWTPlugin","builder","pgInflection","inflection","pgJwtTypeIdentifier","pgJwtSecret","hook","_","newWithHooks","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","pgRegisterGqlTypeByTypeId","pg2GqlMapper","pgTweaksByTypeId","graphql","GraphQLScalarType","Error","namespaceName","typeName","parseTypeIdentifier","compositeClass","class","find","table","isSelectable","isInsertable","isUpdatable","isDeletable","name","compositeType","type","filter","category","namespaceId","classId","id","attributes","attribute","attr","sort","a1","a2","num","compositeTypeName","tableType","cb","JWTType","description","serialize","value","token","reduce","memo","audience","issuer","exp","expiresIn","isPgJwtType","map","values","k","every","v","unmap","fragment","typeIdentifier","match"],"mappings":"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","file":"PgJWTPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport { sign as signJwt } from \"jsonwebtoken\";\n\nexport default (function PgJWTPlugin(\n  builder,\n  { pgInflection: inflection, pgJwtTypeIdentifier, pgJwtSecret }\n) {\n  builder.hook(\n    \"init\",\n    (\n      _,\n      {\n        newWithHooks,\n        pgSql: sql,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgRegisterGqlTypeByTypeId,\n        pg2GqlMapper,\n        pgTweaksByTypeId,\n        graphql: { GraphQLScalarType },\n      }\n    ) => {\n      if (!pgJwtTypeIdentifier) {\n        return _;\n      }\n      if (!pgJwtSecret) {\n        throw new Error(\n          \"pgJwtTypeIdentifier was specified without pgJwtSecret\"\n        );\n      }\n      const { namespaceName, typeName } = parseTypeIdentifier(\n        pgJwtTypeIdentifier\n      );\n\n      const compositeClass = introspectionResultsByKind.class.find(\n        table =>\n          !table.isSelectable &&\n          !table.isInsertable &&\n          !table.isUpdatable &&\n          !table.isDeletable &&\n          table.name === typeName &&\n          table.namespaceName === namespaceName\n      );\n      if (!compositeClass) {\n        throw new Error(\n          `Could not find JWT type '\"${namespaceName}\".\"${typeName}\"'`\n        );\n      }\n      const compositeType = introspectionResultsByKind.type.filter(\n        type =>\n          type.type === \"c\" &&\n          type.category === \"C\" &&\n          type.namespaceId === compositeClass.namespaceId &&\n          type.classId === compositeClass.id\n      )[0];\n      if (!compositeType) {\n        throw new Error(\"Could not determine the type for JWT type\");\n      }\n      if (pg2GqlMapper[compositeType.id]) {\n        throw new Error(\"JWT type has already been overridden?\");\n      }\n      const attributes = introspectionResultsByKind.attribute\n        // TODO: consider adding to pgColumnFilter?\n        .filter(attr => attr.classId === compositeClass.id)\n        .sort((a1, a2) => a1.num - a2.num);\n\n      const compositeTypeName = inflection.tableType(\n        compositeClass.name,\n        compositeClass.namespaceName\n      );\n\n      // NOTE: we deliberately do not create an input type\n      pgRegisterGqlTypeByTypeId(compositeType.id, cb => {\n        const JWTType = newWithHooks(\n          GraphQLScalarType,\n          {\n            name: compositeTypeName,\n            description:\n              \"A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519) which securely represents claims between two parties.\",\n            serialize(value) {\n              const token = attributes.reduce((memo, attr) => {\n                memo[attr.name] = value[attr.name];\n                return memo;\n              }, {});\n              return signJwt(\n                token,\n                pgJwtSecret,\n                Object.assign(\n                  {},\n                  {\n                    audience: \"postgraphql\",\n                    issuer: \"postgraphql\",\n                  },\n                  token.exp\n                    ? null\n                    : {\n                        expiresIn: \"1 day\",\n                      }\n                )\n              );\n            },\n          },\n          {\n            isPgJwtType: true,\n          }\n        );\n        cb(JWTType);\n\n        pg2GqlMapper[compositeType.id] = {\n          map: value => {\n            if (!value) return null;\n            const values = Object.keys(value).map(k => value[k]);\n            if (values.every(v => v == null)) {\n              return null;\n            }\n            return value;\n          },\n          unmap: () => {\n            throw new Error(\n              \"We don't support passing a JWT token into GraphQL currently\"\n            );\n          },\n        };\n\n        pgTweaksByTypeId[compositeType.id] = fragment =>\n          sql.fragment`to_json(${fragment})`;\n      });\n      return _;\n    }\n  );\n}: Plugin);\n\nfunction parseTypeIdentifier(typeIdentifier) {\n  const match = typeIdentifier.match(\n    /^(?:([a-zA-Z0-9_]+)|\"([^\"]*)\")\\.(?:([a-zA-Z0-9_]+)|\"([^\"]*)\")$/\n  );\n\n  if (!match)\n    throw new Error(\n      `Type identifier '${typeIdentifier}' is of the incorrect form.`\n    );\n\n  return {\n    namespaceName: match[1] || match[2],\n    typeName: match[3] || match[4],\n  };\n}\n"]}