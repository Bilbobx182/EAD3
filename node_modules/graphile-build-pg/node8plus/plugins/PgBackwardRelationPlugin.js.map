{"version":3,"sources":["../../src/plugins/PgBackwardRelationPlugin.js"],"names":["debug","PgBackwardRelationPlugin","builder","pgInflection","inflection","hook","fields","extend","getTypeByName","pgGetGqlTypeByTypeId","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getAliasFromResolveInfo","graphql","GraphQLNonNull","scope","isPgRowType","pgIntrospection","foreignTable","fieldWithHooks","Self","kind","foreignKeyConstraints","constraint","filter","con","type","foreignClassId","id","foreignAttributes","attribute","attr","classId","sort","a","b","num","reduce","memo","table","classById","tableTypeName","tableType","name","namespace","gqlTableType","gqlForeignTableType","Error","schema","attributes","keys","keyAttributeNums","map","foreignKeys","foreignKeyAttributeNums","every","_","simpleKeys","k","column","class","fieldName","manyRelationByKeys","primaryKeyConstraint","primaryKeys","getDataFromParsedResolveInfoFragment","addDataGenerator","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","ConnectionType","tableAlias","identifier","foreignTableAlias","getTableAlias","query","withPagination","withPaginationAsFields","innerQueryBuilder","beforeLock","isOrderUnique","data","cursorPrefix","forEach","key","orderBy","fragment","setOrderIsUnique","i","where","alias","connection","description","args","resolve","_args","_context","resolveInfo","isPgFieldConnection","pgFieldIntrospection"],"mappings":"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","file":"PgBackwardRelationPlugin.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport addStartEndCursor from \"./addStartEndCursor\";\n\nimport type { Plugin } from \"graphile-build\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nexport default (function PgBackwardRelationPlugin(\n  builder,\n  { pgInflection: inflection }\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (\n      fields,\n      {\n        extend,\n        getTypeByName,\n        pgGetGqlTypeByTypeId,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        getAliasFromResolveInfo,\n        graphql: { GraphQLNonNull },\n      },\n      {\n        scope: { isPgRowType, pgIntrospection: foreignTable },\n        fieldWithHooks,\n        Self,\n      }\n    ) => {\n      if (!isPgRowType || !foreignTable || foreignTable.kind !== \"class\") {\n        return fields;\n      }\n      // This is a relation in which WE are foreign\n      const foreignKeyConstraints = introspectionResultsByKind.constraint\n        .filter(con => con.type === \"f\")\n        .filter(con => con.foreignClassId === foreignTable.id);\n      const foreignAttributes = introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === foreignTable.id)\n        .sort((a, b) => a.num - b.num);\n\n      return extend(\n        fields,\n        foreignKeyConstraints.reduce((memo, constraint) => {\n          const table =\n            introspectionResultsByKind.classById[constraint.classId];\n          const tableTypeName = inflection.tableType(\n            table.name,\n            table.namespace.name\n          );\n          const gqlTableType = pgGetGqlTypeByTypeId(table.type.id);\n          if (!gqlTableType) {\n            debug(\n              `Could not determine type for table with id ${constraint.classId}`\n            );\n            return memo;\n          }\n          const foreignTable =\n            introspectionResultsByKind.classById[constraint.foreignClassId];\n          const gqlForeignTableType = pgGetGqlTypeByTypeId(\n            foreignTable.type.id\n          );\n          if (!gqlForeignTableType) {\n            debug(\n              `Could not determine type for foreign table with id ${\n                constraint.foreignClassId\n              }`\n            );\n            return memo;\n          }\n          if (!table) {\n            throw new Error(\n              `Could not find the table that referenced us (constraint: ${\n                constraint.name\n              })`\n            );\n          }\n          const schema = table.namespace;\n\n          const attributes = introspectionResultsByKind.attribute.filter(\n            attr => attr.classId === table.id\n          );\n\n          const keys = constraint.keyAttributeNums.map(\n            num => attributes.filter(attr => attr.num === num)[0]\n          );\n          const foreignKeys = constraint.foreignKeyAttributeNums.map(\n            num => foreignAttributes.filter(attr => attr.num === num)[0]\n          );\n          if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n            throw new Error(\"Could not find key columns!\");\n          }\n\n          const simpleKeys = keys.map(k => ({\n            column: k.name,\n            table: k.class.name,\n            schema: k.class.namespace.name,\n          }));\n          const fieldName = inflection.manyRelationByKeys(\n            simpleKeys,\n            table.name,\n            table.namespace.name,\n            foreignTable.name,\n            foreignTable.namespace.name\n          );\n          const primaryKeyConstraint = introspectionResultsByKind.constraint\n            .filter(con => con.classId === table.id)\n            .filter(con => con.type === \"p\")[0];\n          const primaryKeys =\n            primaryKeyConstraint &&\n            primaryKeyConstraint.keyAttributeNums.map(\n              num => attributes.filter(attr => attr.num === num)[0]\n            );\n\n          memo[fieldName] = fieldWithHooks(\n            fieldName,\n            ({ getDataFromParsedResolveInfoFragment, addDataGenerator }) => {\n              addDataGenerator(parsedResolveInfoFragment => {\n                return {\n                  pgQuery: queryBuilder => {\n                    queryBuilder.select(() => {\n                      const resolveData = getDataFromParsedResolveInfoFragment(\n                        parsedResolveInfoFragment,\n                        ConnectionType\n                      );\n                      const tableAlias = sql.identifier(Symbol());\n                      const foreignTableAlias = queryBuilder.getTableAlias();\n                      const query = queryFromResolveData(\n                        sql.identifier(schema.name, table.name),\n                        tableAlias,\n                        resolveData,\n                        {\n                          withPagination: true,\n                          withPaginationAsFields: false,\n                        },\n                        innerQueryBuilder => {\n                          if (primaryKeys) {\n                            innerQueryBuilder.beforeLock(\"orderBy\", () => {\n                              // append order by primary key to the list of orders\n                              if (!innerQueryBuilder.isOrderUnique(false)) {\n                                innerQueryBuilder.data.cursorPrefix = [\n                                  \"primary_key_asc\",\n                                ];\n                                primaryKeys.forEach(key => {\n                                  innerQueryBuilder.orderBy(\n                                    sql.fragment`${innerQueryBuilder.getTableAlias()}.${sql.identifier(\n                                      key.name\n                                    )}`,\n                                    true\n                                  );\n                                });\n                                innerQueryBuilder.setOrderIsUnique();\n                              }\n                            });\n                          }\n\n                          keys.forEach((key, i) => {\n                            innerQueryBuilder.where(\n                              sql.fragment`${tableAlias}.${sql.identifier(\n                                key.name\n                              )} = ${foreignTableAlias}.${sql.identifier(\n                                foreignKeys[i].name\n                              )}`\n                            );\n                          });\n                        }\n                      );\n                      return sql.fragment`(${query})`;\n                    }, parsedResolveInfoFragment.alias);\n                  },\n                };\n              });\n              const ConnectionType = getTypeByName(\n                inflection.connection(gqlTableType.name)\n              );\n              return {\n                description: `Reads and enables pagination through a set of \\`${tableTypeName}\\`.`,\n                type: new GraphQLNonNull(ConnectionType),\n                args: {},\n                resolve: (data, _args, _context, resolveInfo) => {\n                  const alias = getAliasFromResolveInfo(resolveInfo);\n                  return addStartEndCursor(data[alias]);\n                },\n              };\n            },\n            {\n              isPgFieldConnection: true,\n              pgFieldIntrospection: table,\n            }\n          );\n          return memo;\n        }, {}),\n        `Adding backward relations for ${Self.name}`\n      );\n    }\n  );\n}: Plugin);\n"]}