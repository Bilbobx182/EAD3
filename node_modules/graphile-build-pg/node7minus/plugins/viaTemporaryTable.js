"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _pgSql = require("pg-sql2");

var _pgSql2 = _interopRequireDefault(_pgSql);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debugSql = (0, _debug2.default)("graphile-build-pg:sql");

/*
 * Originally we tried this with a CTE, but:
 *
 * > The sub-statements in WITH are executed concurrently with each other and
 * > with the main query. Therefore, when using data-modifying statements in
 * > WITH, the order in which the specified updates actually happen is
 * > unpredictable. All the statements are executed with the same snapshot (see
 * > Chapter 13), so they cannot "see" one another's effects on the target
 * > tables. This alleviates the effects of the unpredictability of the actual
 * > order of row updates, and means that RETURNING data is the only way to
 * > communicate changes between different WITH sub-statements and the main
 * > query.
 *
 * -- https://www.postgresql.org/docs/9.6/static/queries-with.html
 *
 * This caused issues with computed columns that themselves went off and
 * performed selects - because the data within those selects used the old
 * snapshot and thus returned stale data.
 *
 * To solve this, we tried using temporary tables to ensure the mutation and
 * the select execute in different statments. This worked, but temporary tables
 * require elevated priviliges and thus don't work everywhere. We needed a more
 * generic solution.
 *
 * In the end we settled for sending the data we received from the mutations
 * straight back into the PostgreSQL server. It's a bit wasteful but it works.
 *
 * If you can come up with a better solution please open a pull request!
 */

exports.default = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(pgClient, sqlTypeIdentifier, sqlMutationQuery, sqlResultSourceAlias, sqlResultQuery) {
    var performQuery = function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(pgClient, sqlQuery) {
        var _sql$compile, text, values;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // TODO: look into rowMode = 'array'
                _sql$compile = _pgSql2.default.compile(sqlQuery), text = _sql$compile.text, values = _sql$compile.values;

                if (debugSql.enabled) debugSql(text);
                return _context.abrupt("return", pgClient.query(text, values));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function performQuery(_x7, _x8) {
        return _ref2.apply(this, arguments);
      };
    }();

    var isPgClassLike = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var selectionField, result, rows, firstRow, firstKey, values, convertFieldBack;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (sqlTypeIdentifier) {
              _context2.next = 6;
              break;
            }

            _context2.next = 3;
            return performQuery(pgClient, _pgSql2.default.query`
      with ${sqlResultSourceAlias} as (
        ${sqlMutationQuery}
      ) ${sqlResultQuery}`);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 6:
            /*
             * In this code we're converting the rows to a string representation within
             * PostgreSQL itself, then we can send it back into PostgreSQL and have it
             * re-interpret the results cleanly (using it's own serializer/parser
             * combination) so we should be fairly confident that it will work
             * correctly every time assuming none of the PostgreSQL types are broken.
             *
             * If you have a way to improve this, I'd love to see a PR - but please
             * make sure that the integration tests pass with your solution first as
             * there are a log of potential pitfalls!
             */
            selectionField = isPgClassLike ? sqlResultSourceAlias : _pgSql2.default.query`(${sqlResultSourceAlias}.${sqlResultSourceAlias})::${sqlTypeIdentifier}`;
            _context2.next = 9;
            return performQuery(pgClient, _pgSql2.default.query`
      with ${sqlResultSourceAlias} as (
        ${sqlMutationQuery}
      )
      select (${selectionField})::text from ${sqlResultSourceAlias}`);

          case 9:
            result = _context2.sent;
            rows = result.rows;
            firstRow = rows[0];
            // TODO: we should be able to have `pg` not interpret the results as
            // objects and instead just return them as arrays - then we can just do
            // `row[0]`. PR welcome!

            firstKey = firstRow && (0, _keys2.default)(firstRow)[0];
            values = rows.map(function (row) {
              return row[firstKey];
            });
            convertFieldBack = isPgClassLike ? _pgSql2.default.query`(str::${sqlTypeIdentifier}).*` : _pgSql2.default.query`str::${sqlTypeIdentifier} as ${sqlResultSourceAlias}`;
            _context2.next = 17;
            return performQuery(pgClient, _pgSql2.default.query`
      with ${sqlResultSourceAlias} as (
        select ${convertFieldBack}
        from unnest((${_pgSql2.default.value(values)})::text[]) str
      )
      ${sqlResultQuery}`);

          case 17:
            return _context2.abrupt("return", _context2.sent);

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  function viaTemporaryTable(_x2, _x3, _x4, _x5, _x6) {
    return _ref.apply(this, arguments);
  }

  return viaTemporaryTable;
}();
//# sourceMappingURL=viaTemporaryTable.js.map