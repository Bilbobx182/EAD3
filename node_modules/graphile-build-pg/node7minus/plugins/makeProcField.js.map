{"version":3,"sources":["../../src/plugins/makeProcField.js"],"names":["makeProcField","debugSql","firstValue","firstKey","k","obj","fieldName","proc","introspectionResultsByKind","pgIntrospectionResultsByKind","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","getTypeByName","sql","pgSql","parseResolveInfo","getAliasFromResolveInfo","gql2pg","pg2gql","newWithHooks","inflection","pgInflection","strictFunctions","pgStrictFunctions","pgTweakFragmentForType","graphql","GraphQLNonNull","GraphQLList","GraphQLString","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLObjectType","GraphQLInputObjectType","getNamedType","isCompositeType","fieldWithHooks","computed","isMutation","getResultFieldName","gqlType","type","returnsSet","gqlNamedType","name","isPgArray","Error","sliceAmount","argNames","argTypeIds","slice","map","_","idx","argTypes","typeById","typeId","requiredArgCount","Math","max","length","argDefaultsNum","notNullArgCount","isStrict","argGqlTypes","Type","id","rawReturnType","returnTypeId","returnType","arrayItemType","returnTypeTable","classById","classId","fieldScope","payloadTypeScope","pgFieldIntrospection","pgIntrospection","returnFirstValueAsValue","TableType","isTableLike","ConnectionType","connection","isPgFieldConnection","pgFieldIntrospectionTable","pgIntrospectionTable","connectionTypeName","scalarFunctionConnection","namespace","addDataGenerator","getDataFromParsedResolveInfoFragment","addArgDataGenerator","addPgCursorPrefix","pgCursorPrefix","literal","makeMutationCall","parsedResolveInfoFragment","ReturnType","implicitArgs","args","rawArgs","input","sqlArgValues","haveNames","argIndex","argName","gqlArgName","argument","value","sqlValue","sqlArgName","identifier","unshift","fragment","join","makeQuery","sqlMutationQuery","functionAlias","resolveData","query","withPagination","withPaginationAsFields","asJson","addNullCase","innerQueryBuilder","select","pgQuery","queryBuilder","parentTableAlias","getTableAlias","alias","PayloadType","reduce","memo","resultFieldName","isNotVoid","String","functionPayloadType","description","functionName","fields","recurseDataGeneratorsForField","clientMutationId","resolve","data","isMutationPayload","InputType","functionInputType","isMutationInput","_args","_context","resolveInfo","v","pgClient","queryResult","intermediateIdentifier","isVoid","isPgClass","namespaceName","compile","text","values","enabled","rows","row","result"],"mappings":"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","file":"makeProcField.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\nimport camelCase from \"lodash/camelCase\";\nimport pluralize from \"pluralize\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport addStartEndCursor from \"./addStartEndCursor\";\nimport viaTemporaryTable from \"./viaTemporaryTable\";\n\nimport type { Build, FieldWithHooksFunction } from \"graphile-build\";\nimport type { Proc } from \"./PgIntrospectionPlugin\";\nimport type { SQL } from \"pg-sql2\";\n\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\nconst firstValue = obj => {\n  let firstKey;\n  for (const k in obj) {\n    firstKey = k;\n  }\n  return obj[firstKey];\n};\n\nexport default function makeProcField(\n  fieldName: string,\n  proc: Proc,\n  {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgGetGqlTypeByTypeId,\n    pgGetGqlInputTypeByTypeId,\n    getTypeByName,\n    pgSql: sql,\n    parseResolveInfo,\n    getAliasFromResolveInfo,\n    gql2pg,\n    pg2gql,\n    newWithHooks,\n    pgInflection: inflection,\n    pgStrictFunctions: strictFunctions,\n    pgTweakFragmentForType,\n    graphql: {\n      GraphQLNonNull,\n      GraphQLList,\n      GraphQLString,\n      GraphQLInt,\n      GraphQLFloat,\n      GraphQLBoolean,\n      GraphQLObjectType,\n      GraphQLInputObjectType,\n      getNamedType,\n      isCompositeType,\n    },\n  }: {| ...Build |},\n  {\n    fieldWithHooks,\n    computed = false,\n    isMutation = false,\n  }: {\n    fieldWithHooks: FieldWithHooksFunction,\n    computed?: boolean,\n    isMutation?: boolean,\n  }\n) {\n  function getResultFieldName(gqlType, type, returnsSet) {\n    const gqlNamedType = getNamedType(gqlType);\n    let name;\n    if (gqlNamedType === GraphQLInt) {\n      name = \"integer\";\n    } else if (gqlNamedType === GraphQLFloat) {\n      name = \"float\";\n    } else if (gqlNamedType === GraphQLBoolean) {\n      name = \"boolean\";\n    } else if (gqlNamedType === GraphQLString) {\n      name = \"string\";\n    } else {\n      name = camelCase(gqlNamedType.name);\n    }\n    return returnsSet || type.isPgArray ? pluralize(name) : name;\n  }\n  if (computed && isMutation) {\n    throw new Error(\"Mutation procedure cannot be computed\");\n  }\n  const sliceAmount = computed ? 1 : 0;\n  const argNames = proc.argTypeIds\n    .slice(sliceAmount)\n    .map((_, idx) => proc.argNames[idx + sliceAmount] || \"\");\n  const argTypes = proc.argTypeIds\n    .slice(sliceAmount)\n    .map(typeId => introspectionResultsByKind.typeById[typeId]);\n  const requiredArgCount = Math.max(0, argNames.length - proc.argDefaultsNum);\n  const notNullArgCount =\n    proc.isStrict || strictFunctions ? requiredArgCount : 0;\n  const argGqlTypes = argTypes.map((type, idx) => {\n    const Type = pgGetGqlInputTypeByTypeId(type.id) || GraphQLString;\n    if (idx >= notNullArgCount) {\n      return Type;\n    } else {\n      return new GraphQLNonNull(Type);\n    }\n  });\n\n  const rawReturnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n  const returnType = rawReturnType.isPgArray\n    ? rawReturnType.arrayItemType\n    : rawReturnType;\n  const returnTypeTable =\n    introspectionResultsByKind.classById[returnType.classId];\n  if (!returnType) {\n    throw new Error(\n      `Could not determine return type for function '${proc.name}'`\n    );\n  }\n  let type;\n  const fieldScope = {};\n  const payloadTypeScope = {};\n  fieldScope.pgFieldIntrospection = proc;\n  payloadTypeScope.pgIntrospection = proc;\n  let returnFirstValueAsValue = false;\n  const TableType =\n    returnTypeTable && pgGetGqlTypeByTypeId(returnTypeTable.type.id);\n\n  const isTableLike: boolean =\n    (TableType && isCompositeType(TableType)) || false;\n  if (isTableLike) {\n    if (proc.returnsSet) {\n      if (isMutation) {\n        type = new GraphQLList(TableType);\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.connection(TableType.name)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.connection(\n              TableType.name\n            )}' for '${TableType.name}' so cannot create procedure field`\n          );\n        }\n        type = new GraphQLNonNull(ConnectionType);\n        fieldScope.isPgFieldConnection = true;\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    } else {\n      type = TableType;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    }\n  } else {\n    const Type = pgGetGqlTypeByTypeId(returnType.id) || GraphQLString;\n    if (proc.returnsSet) {\n      const connectionTypeName = inflection.scalarFunctionConnection(\n        proc.name,\n        proc.namespace.name\n      );\n      const ConnectionType = getTypeByName(connectionTypeName);\n      if (ConnectionType) {\n        if (isMutation) {\n          // Cannot return a connection because it would have to run the mutation again\n          type = new GraphQLList(Type);\n          returnFirstValueAsValue = true;\n        } else {\n          type = new GraphQLNonNull(ConnectionType);\n          fieldScope.isPgFieldConnection = true;\n        }\n      } else {\n        returnFirstValueAsValue = true;\n        type = new GraphQLList(Type);\n      }\n    } else {\n      returnFirstValueAsValue = true;\n      type = Type;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  }\n  return fieldWithHooks(\n    fieldName,\n    ({\n      addDataGenerator,\n      getDataFromParsedResolveInfoFragment,\n      addArgDataGenerator,\n    }) => {\n      if (\n        proc.returnsSet &&\n        !isTableLike &&\n        !returnFirstValueAsValue &&\n        !isMutation\n      ) {\n        // Natural ordering\n        addArgDataGenerator(function addPgCursorPrefix() {\n          return {\n            pgCursorPrefix: sql.literal(\"natural\"),\n          };\n        });\n      }\n      function makeMutationCall(\n        parsedResolveInfoFragment,\n        ReturnType,\n        { implicitArgs = [] } = {}\n      ): SQL {\n        const { args: rawArgs = {} } = parsedResolveInfoFragment;\n        const args = isMutation ? rawArgs.input : rawArgs;\n        const sqlArgValues = [];\n        let haveNames = true;\n        for (let argIndex = argNames.length - 1; argIndex >= 0; argIndex--) {\n          const argName = argNames[argIndex];\n          const gqlArgName = inflection.argument(argName, argIndex);\n          const value = args[gqlArgName];\n          const sqlValue = gql2pg(value, argTypes[argIndex]);\n          if (argIndex + 1 > requiredArgCount && haveNames && value == null) {\n            // No need to pass argument to function\n            continue;\n          } else if (argIndex + 1 > requiredArgCount && haveNames) {\n            const sqlArgName = argName ? sql.identifier(argName) : null;\n            if (sqlArgName) {\n              sqlArgValues.unshift(sql.fragment`${sqlArgName} := ${sqlValue}`);\n            } else {\n              haveNames = false;\n              sqlArgValues.unshift(sqlValue);\n            }\n          } else {\n            sqlArgValues.unshift(sqlValue);\n          }\n        }\n        return sql.fragment`${sql.identifier(\n          proc.namespace.name,\n          proc.name\n        )}(${sql.join([...implicitArgs, ...sqlArgValues], \", \")})`;\n      }\n      function makeQuery(\n        parsedResolveInfoFragment,\n        ReturnType,\n        sqlMutationQuery,\n        functionAlias\n      ) {\n        const resolveData = getDataFromParsedResolveInfoFragment(\n          parsedResolveInfoFragment,\n          ReturnType\n        );\n        const query = queryFromResolveData(\n          sqlMutationQuery,\n          functionAlias,\n          resolveData,\n          {\n            withPagination: !isMutation && proc.returnsSet,\n            withPaginationAsFields: !isMutation && proc.returnsSet && !computed,\n            asJson: !proc.returnsSet && computed && !returnFirstValueAsValue,\n            addNullCase: !proc.returnsSet && isTableLike,\n          },\n          innerQueryBuilder => {\n            if (!isTableLike) {\n              if (returnTypeTable) {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForType(\n                    sql.fragment`${functionAlias}`,\n                    returnTypeTable.type\n                  ),\n                  \"value\"\n                );\n              } else {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForType(\n                    sql.fragment`${functionAlias}.${functionAlias}`,\n                    returnType\n                  ),\n                  \"value\"\n                );\n              }\n            }\n          }\n        );\n        return query;\n      }\n      if (computed) {\n        addDataGenerator((parsedResolveInfoFragment, ReturnType) => {\n          return {\n            pgQuery: queryBuilder => {\n              queryBuilder.select(() => {\n                const parentTableAlias = queryBuilder.getTableAlias();\n                const functionAlias = sql.identifier(Symbol());\n                const sqlMutationQuery = makeMutationCall(\n                  parsedResolveInfoFragment,\n                  ReturnType,\n                  {\n                    implicitArgs: [parentTableAlias],\n                  }\n                );\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  ReturnType,\n                  sqlMutationQuery,\n                  functionAlias\n                );\n                return sql.fragment`(${query})`;\n              }, parsedResolveInfoFragment.alias);\n            },\n          };\n        });\n      }\n\n      let ReturnType = type;\n      let PayloadType;\n      let args = argNames.reduce((memo, argName, argIndex) => {\n        const gqlArgName = inflection.argument(argName, argIndex);\n        memo[gqlArgName] = {\n          type: argGqlTypes[argIndex],\n        };\n        return memo;\n      }, {});\n      if (isMutation) {\n        const resultFieldName = getResultFieldName(\n          type,\n          rawReturnType,\n          proc.returnsSet\n        );\n        const isNotVoid = String(returnType.id) !== \"2278\";\n        // If set then plural name\n        PayloadType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.functionPayloadType(\n              proc.name,\n              proc.namespace.name\n            ),\n            description: `The output of our \\`${inflection.functionName(\n              proc.name,\n              proc.namespace.name\n            )}\\` mutation.`,\n            fields: ({ recurseDataGeneratorsForField }) => {\n              if (isNotVoid) {\n                recurseDataGeneratorsForField(resultFieldName);\n              }\n              return Object.assign(\n                {},\n                {\n                  clientMutationId: {\n                    type: GraphQLString,\n                  },\n                },\n                isNotVoid\n                  ? {\n                      [resultFieldName]: {\n                        type: type,\n                        resolve(data) {\n                          return data.data;\n                        },\n                      },\n                      // Result\n                    }\n                  : null\n              );\n            },\n          },\n          Object.assign(\n            {},\n            {\n              isMutationPayload: true,\n            },\n            payloadTypeScope\n          )\n        );\n        ReturnType = PayloadType;\n        const InputType = newWithHooks(\n          GraphQLInputObjectType,\n          {\n            name: inflection.functionInputType(proc.name, proc.namespace.name),\n            description: `All input for the \\`${inflection.functionName(\n              proc.name,\n              proc.namespace.name\n            )}\\` mutation.`,\n            fields: Object.assign(\n              {\n                clientMutationId: {\n                  type: GraphQLString,\n                },\n              },\n              args\n            ),\n          },\n          {\n            isMutationInput: true,\n          }\n        );\n        args = {\n          input: {\n            type: new GraphQLNonNull(InputType),\n          },\n        };\n      }\n\n      return {\n        description: proc.description\n          ? proc.description\n          : isTableLike && proc.returnsSet\n            ? `Reads and enables pagination through a set of \\`${\n                TableType.name\n              }\\`.`\n            : null,\n        type: ReturnType,\n        args: args,\n        resolve: computed\n          ? (data, _args, _context, resolveInfo) => {\n              const alias = getAliasFromResolveInfo(resolveInfo);\n              const value = data[alias];\n              if (returnFirstValueAsValue) {\n                if (proc.returnsSet) {\n                  return value.data\n                    .map(firstValue)\n                    .map(v => pg2gql(v, returnType));\n                } else {\n                  return pg2gql(value, returnType);\n                }\n              } else {\n                if (proc.returnsSet && !isMutation) {\n                  return addStartEndCursor(value);\n                } else {\n                  return value;\n                }\n              }\n            }\n          : async (data, args, { pgClient }, resolveInfo) => {\n              const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n              const functionAlias = sql.identifier(Symbol());\n              const sqlMutationQuery = makeMutationCall(\n                parsedResolveInfoFragment,\n                resolveInfo.returnType,\n                {}\n              );\n\n              let queryResult;\n              if (isMutation) {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  functionAlias,\n                  functionAlias\n                );\n                const returnType = rawReturnType;\n                const intermediateIdentifier = sql.identifier(Symbol());\n                const isVoid = returnType.id === \"2278\";\n                const isPgClass =\n                  !returnFirstValueAsValue || returnTypeTable || false;\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  queryResult = await viaTemporaryTable(\n                    pgClient,\n                    isVoid\n                      ? null\n                      : sql.identifier(\n                          returnType.namespaceName,\n                          returnType.name\n                        ),\n                    sql.query`select ${\n                      isPgClass\n                        ? sql.query`${intermediateIdentifier}.*`\n                        : sql.query`${intermediateIdentifier}.${intermediateIdentifier} as ${functionAlias}`\n                    } from ${sqlMutationQuery} ${intermediateIdentifier}`,\n                    functionAlias,\n                    query,\n                    isPgClass\n                  );\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n              } else {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  sqlMutationQuery,\n                  functionAlias\n                );\n                const { text, values } = sql.compile(query);\n                if (debugSql.enabled) debugSql(text);\n                queryResult = await pgClient.query(text, values);\n              }\n              const { rows } = queryResult;\n              const [row] = rows;\n              const result = (() => {\n                if (returnFirstValueAsValue) {\n                  if (proc.returnsSet && !isMutation) {\n                    return row.data\n                      .map(firstValue)\n                      .map(v => pg2gql(v, returnType));\n                  } else if (proc.returnsSet) {\n                    return rows.map(firstValue).map(v => pg2gql(v, returnType));\n                  } else {\n                    return pg2gql(firstValue(row), returnType);\n                  }\n                } else {\n                  if (proc.returnsSet && !isMutation) {\n                    // Connection\n                    return addStartEndCursor(row);\n                  } else if (proc.returnsSet) {\n                    return rows;\n                  } else {\n                    return row;\n                  }\n                }\n              })();\n              if (isMutation) {\n                return {\n                  clientMutationId: args.input.clientMutationId,\n                  data: result,\n                };\n              } else {\n                return result;\n              }\n            },\n      };\n    },\n    fieldScope\n  );\n}\n"]}