{"version":3,"sources":["../../src/plugins/viaTemporaryTable.js"],"names":["debugSql","pgClient","sqlTypeIdentifier","sqlMutationQuery","sqlResultSourceAlias","sqlResultQuery","sqlQuery","compile","text","values","enabled","query","performQuery","isPgClassLike","selectionField","result","rows","firstRow","firstKey","map","row","convertFieldBack","value","viaTemporaryTable"],"mappings":";;;;;;;;;;;;;;;;;;AAEA;;;;AACA;;;;;;AAIA,IAAMA,WAAW,qBAAa,uBAAb,CAAjB;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sFA8Be,kBACbC,QADa,EAEbC,iBAFa,EAGbC,gBAHa,EAIbC,oBAJa,EAKbC,cALa;AAAA;AAAA,2FAQb,iBAA4BJ,QAA5B,EAA8CK,QAA9C;AAAA;;AAAA;AAAA;AAAA;AAAA;AACE;AADF,+BAE2B,gBAAIC,OAAJ,CAAYD,QAAZ,CAF3B,EAEUE,IAFV,gBAEUA,IAFV,EAEgBC,MAFhB,gBAEgBA,MAFhB;;AAGE,oBAAIT,SAASU,OAAb,EAAsBV,SAASQ,IAAT;AAHxB,iDAISP,SAASU,KAAT,CAAeH,IAAf,EAAqBC,MAArB,CAJT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OARa;;AAAA,sBAQEG,YARF;AAAA;AAAA;AAAA;;AAAA,QAMbC,aANa,uEAMY,IANZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAeRX,iBAfQ;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAiBEU,aACXX,QADW,EAEX,gBAAIU,KAAM;aACHP,oBAAqB;UACxBD,gBAAiB;UACjBE,cAAe,EALR,CAjBF;;AAAA;AAAA;;AAAA;AAyBX;;;;;;;;;;;AAWMS,0BApCK,GAoCYD,gBACnBT,oBADmB,GAEnB,gBAAIO,KAAM,IAAGP,oBAAqB,IAAGA,oBAAqB,MAAKF,iBAAkB,EAtC1E;AAAA;AAAA,mBAuCUU,aACnBX,QADmB,EAEnB,gBAAIU,KAAM;aACHP,oBAAqB;UACxBD,gBAAiB;;gBAEXW,cAAe,gBAAeV,oBAAqB,EAN1C,CAvCV;;AAAA;AAuCLW,kBAvCK;AA+CHC,gBA/CG,GA+CMD,MA/CN,CA+CHC,IA/CG;AAgDLC,oBAhDK,GAgDMD,KAAK,CAAL,CAhDN;AAiDX;AACA;AACA;;AACME,oBApDK,GAoDMD,YAAY,oBAAYA,QAAZ,EAAsB,CAAtB,CApDlB;AAqDLR,kBArDK,GAqDIO,KAAKG,GAAL,CAAS;AAAA,qBAAOC,IAAIF,QAAJ,CAAP;AAAA,aAAT,CArDJ;AAsDLG,4BAtDK,GAsDcR,gBACrB,gBAAIF,KAAM,SAAQT,iBAAkB,KADf,GAErB,gBAAIS,KAAM,QAAOT,iBAAkB,OAAME,oBAAqB,EAxDvD;AAAA;AAAA,mBAyDEQ,aACXX,QADW,EAEX,gBAAIU,KAAM;aACHP,oBAAqB;iBACjBiB,gBAAiB;uBACX,gBAAIC,KAAJ,CAAUb,MAAV,CAAkB;;QAEjCJ,cAAe,EAPN,CAzDF;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;WAAekB,iB;;;;SAAAA,iB","file":"viaTemporaryTable.js","sourcesContent":["// @flow\n\nimport sql from \"pg-sql2\";\nimport debugFactory from \"debug\";\nimport type { Client } from \"pg\";\nimport type { SQL, SQLQuery } from \"pg-sql2\";\n\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\n\n/*\n * Originally we tried this with a CTE, but:\n *\n * > The sub-statements in WITH are executed concurrently with each other and\n * > with the main query. Therefore, when using data-modifying statements in\n * > WITH, the order in which the specified updates actually happen is\n * > unpredictable. All the statements are executed with the same snapshot (see\n * > Chapter 13), so they cannot \"see\" one another's effects on the target\n * > tables. This alleviates the effects of the unpredictability of the actual\n * > order of row updates, and means that RETURNING data is the only way to\n * > communicate changes between different WITH sub-statements and the main\n * > query.\n *\n * -- https://www.postgresql.org/docs/9.6/static/queries-with.html\n *\n * This caused issues with computed columns that themselves went off and\n * performed selects - because the data within those selects used the old\n * snapshot and thus returned stale data.\n *\n * To solve this, we tried using temporary tables to ensure the mutation and\n * the select execute in different statments. This worked, but temporary tables\n * require elevated priviliges and thus don't work everywhere. We needed a more\n * generic solution.\n *\n * In the end we settled for sending the data we received from the mutations\n * straight back into the PostgreSQL server. It's a bit wasteful but it works.\n *\n * If you can come up with a better solution please open a pull request!\n */\n\nexport default async function viaTemporaryTable(\n  pgClient: Client,\n  sqlTypeIdentifier: ?SQL,\n  sqlMutationQuery: SQL,\n  sqlResultSourceAlias: SQL,\n  sqlResultQuery: SQL,\n  isPgClassLike: boolean = true\n) {\n  async function performQuery(pgClient: Client, sqlQuery: SQLQuery) {\n    // TODO: look into rowMode = 'array'\n    const { text, values } = sql.compile(sqlQuery);\n    if (debugSql.enabled) debugSql(text);\n    return pgClient.query(text, values);\n  }\n\n  if (!sqlTypeIdentifier) {\n    // It returns void, just perform the query!\n    return await performQuery(\n      pgClient,\n      sql.query`\n      with ${sqlResultSourceAlias} as (\n        ${sqlMutationQuery}\n      ) ${sqlResultQuery}`\n    );\n  } else {\n    /*\n     * In this code we're converting the rows to a string representation within\n     * PostgreSQL itself, then we can send it back into PostgreSQL and have it\n     * re-interpret the results cleanly (using it's own serializer/parser\n     * combination) so we should be fairly confident that it will work\n     * correctly every time assuming none of the PostgreSQL types are broken.\n     *\n     * If you have a way to improve this, I'd love to see a PR - but please\n     * make sure that the integration tests pass with your solution first as\n     * there are a log of potential pitfalls!\n     */\n    const selectionField = isPgClassLike\n      ? sqlResultSourceAlias\n      : sql.query`(${sqlResultSourceAlias}.${sqlResultSourceAlias})::${sqlTypeIdentifier}`;\n    const result = await performQuery(\n      pgClient,\n      sql.query`\n      with ${sqlResultSourceAlias} as (\n        ${sqlMutationQuery}\n      )\n      select (${selectionField})::text from ${sqlResultSourceAlias}`\n    );\n    const { rows } = result;\n    const firstRow = rows[0];\n    // TODO: we should be able to have `pg` not interpret the results as\n    // objects and instead just return them as arrays - then we can just do\n    // `row[0]`. PR welcome!\n    const firstKey = firstRow && Object.keys(firstRow)[0];\n    const values = rows.map(row => row[firstKey]);\n    const convertFieldBack = isPgClassLike\n      ? sql.query`(str::${sqlTypeIdentifier}).*`\n      : sql.query`str::${sqlTypeIdentifier} as ${sqlResultSourceAlias}`;\n    return await performQuery(\n      pgClient,\n      sql.query`\n      with ${sqlResultSourceAlias} as (\n        select ${convertFieldBack}\n        from unnest((${sql.value(values)})::text[]) str\n      )\n      ${sqlResultQuery}`\n    );\n  }\n}\n"]}