{"version":3,"sources":["../../src/plugins/PgJWTPlugin.js"],"names":["PgJWTPlugin","builder","inflection","pgInflection","pgJwtTypeIdentifier","pgJwtSecret","hook","_","newWithHooks","sql","pgSql","introspectionResultsByKind","pgIntrospectionResultsByKind","pgRegisterGqlTypeByTypeId","pg2GqlMapper","pgTweaksByTypeId","GraphQLScalarType","graphql","Error","parseTypeIdentifier","namespaceName","typeName","compositeClass","class","find","table","isSelectable","isInsertable","isUpdatable","isDeletable","name","compositeType","type","filter","category","namespaceId","classId","id","attributes","attribute","attr","sort","a1","a2","num","compositeTypeName","tableType","JWTType","description","serialize","value","token","reduce","memo","audience","issuer","exp","expiresIn","isPgJwtType","cb","map","values","k","every","v","unmap","fragment","typeIdentifier","match"],"mappings":"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","file":"PgJWTPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport { sign as signJwt } from \"jsonwebtoken\";\n\nexport default (function PgJWTPlugin(\n  builder,\n  { pgInflection: inflection, pgJwtTypeIdentifier, pgJwtSecret }\n) {\n  builder.hook(\n    \"init\",\n    (\n      _,\n      {\n        newWithHooks,\n        pgSql: sql,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgRegisterGqlTypeByTypeId,\n        pg2GqlMapper,\n        pgTweaksByTypeId,\n        graphql: { GraphQLScalarType },\n      }\n    ) => {\n      if (!pgJwtTypeIdentifier) {\n        return _;\n      }\n      if (!pgJwtSecret) {\n        throw new Error(\n          \"pgJwtTypeIdentifier was specified without pgJwtSecret\"\n        );\n      }\n      const { namespaceName, typeName } = parseTypeIdentifier(\n        pgJwtTypeIdentifier\n      );\n\n      const compositeClass = introspectionResultsByKind.class.find(\n        table =>\n          !table.isSelectable &&\n          !table.isInsertable &&\n          !table.isUpdatable &&\n          !table.isDeletable &&\n          table.name === typeName &&\n          table.namespaceName === namespaceName\n      );\n      if (!compositeClass) {\n        throw new Error(\n          `Could not find JWT type '\"${namespaceName}\".\"${typeName}\"'`\n        );\n      }\n      const compositeType = introspectionResultsByKind.type.filter(\n        type =>\n          type.type === \"c\" &&\n          type.category === \"C\" &&\n          type.namespaceId === compositeClass.namespaceId &&\n          type.classId === compositeClass.id\n      )[0];\n      if (!compositeType) {\n        throw new Error(\"Could not determine the type for JWT type\");\n      }\n      if (pg2GqlMapper[compositeType.id]) {\n        throw new Error(\"JWT type has already been overridden?\");\n      }\n      const attributes = introspectionResultsByKind.attribute\n        // TODO: consider adding to pgColumnFilter?\n        .filter(attr => attr.classId === compositeClass.id)\n        .sort((a1, a2) => a1.num - a2.num);\n\n      const compositeTypeName = inflection.tableType(\n        compositeClass.name,\n        compositeClass.namespaceName\n      );\n\n      // NOTE: we deliberately do not create an input type\n      pgRegisterGqlTypeByTypeId(compositeType.id, cb => {\n        const JWTType = newWithHooks(\n          GraphQLScalarType,\n          {\n            name: compositeTypeName,\n            description:\n              \"A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519) which securely represents claims between two parties.\",\n            serialize(value) {\n              const token = attributes.reduce((memo, attr) => {\n                memo[attr.name] = value[attr.name];\n                return memo;\n              }, {});\n              return signJwt(\n                token,\n                pgJwtSecret,\n                Object.assign(\n                  {},\n                  {\n                    audience: \"postgraphql\",\n                    issuer: \"postgraphql\",\n                  },\n                  token.exp\n                    ? null\n                    : {\n                        expiresIn: \"1 day\",\n                      }\n                )\n              );\n            },\n          },\n          {\n            isPgJwtType: true,\n          }\n        );\n        cb(JWTType);\n\n        pg2GqlMapper[compositeType.id] = {\n          map: value => {\n            if (!value) return null;\n            const values = Object.keys(value).map(k => value[k]);\n            if (values.every(v => v == null)) {\n              return null;\n            }\n            return value;\n          },\n          unmap: () => {\n            throw new Error(\n              \"We don't support passing a JWT token into GraphQL currently\"\n            );\n          },\n        };\n\n        pgTweaksByTypeId[compositeType.id] = fragment =>\n          sql.fragment`to_json(${fragment})`;\n      });\n      return _;\n    }\n  );\n}: Plugin);\n\nfunction parseTypeIdentifier(typeIdentifier) {\n  const match = typeIdentifier.match(\n    /^(?:([a-zA-Z0-9_]+)|\"([^\"]*)\")\\.(?:([a-zA-Z0-9_]+)|\"([^\"]*)\")$/\n  );\n\n  if (!match)\n    throw new Error(\n      `Type identifier '${typeIdentifier}' is of the incorrect form.`\n    );\n\n  return {\n    namespaceName: match[1] || match[2],\n    typeName: match[3] || match[4],\n  };\n}\n"]}