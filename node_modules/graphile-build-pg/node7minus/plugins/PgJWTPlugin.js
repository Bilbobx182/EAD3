"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _jsonwebtoken = require("jsonwebtoken");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function PgJWTPlugin(builder, _ref) {
  var inflection = _ref.pgInflection,
      pgJwtTypeIdentifier = _ref.pgJwtTypeIdentifier,
      pgJwtSecret = _ref.pgJwtSecret;

  builder.hook("init", function (_, _ref2) {
    var newWithHooks = _ref2.newWithHooks,
        sql = _ref2.pgSql,
        introspectionResultsByKind = _ref2.pgIntrospectionResultsByKind,
        pgRegisterGqlTypeByTypeId = _ref2.pgRegisterGqlTypeByTypeId,
        pg2GqlMapper = _ref2.pg2GqlMapper,
        pgTweaksByTypeId = _ref2.pgTweaksByTypeId,
        GraphQLScalarType = _ref2.graphql.GraphQLScalarType;

    if (!pgJwtTypeIdentifier) {
      return _;
    }
    if (!pgJwtSecret) {
      throw new Error("pgJwtTypeIdentifier was specified without pgJwtSecret");
    }

    var _parseTypeIdentifier = parseTypeIdentifier(pgJwtTypeIdentifier),
        namespaceName = _parseTypeIdentifier.namespaceName,
        typeName = _parseTypeIdentifier.typeName;

    var compositeClass = introspectionResultsByKind.class.find(function (table) {
      return !table.isSelectable && !table.isInsertable && !table.isUpdatable && !table.isDeletable && table.name === typeName && table.namespaceName === namespaceName;
    });
    if (!compositeClass) {
      throw new Error(`Could not find JWT type '"${namespaceName}"."${typeName}"'`);
    }
    var compositeType = introspectionResultsByKind.type.filter(function (type) {
      return type.type === "c" && type.category === "C" && type.namespaceId === compositeClass.namespaceId && type.classId === compositeClass.id;
    })[0];
    if (!compositeType) {
      throw new Error("Could not determine the type for JWT type");
    }
    if (pg2GqlMapper[compositeType.id]) {
      throw new Error("JWT type has already been overridden?");
    }
    var attributes = introspectionResultsByKind.attribute
    // TODO: consider adding to pgColumnFilter?
    .filter(function (attr) {
      return attr.classId === compositeClass.id;
    }).sort(function (a1, a2) {
      return a1.num - a2.num;
    });

    var compositeTypeName = inflection.tableType(compositeClass.name, compositeClass.namespaceName);

    // NOTE: we deliberately do not create an input type
    pgRegisterGqlTypeByTypeId(compositeType.id, function (cb) {
      var JWTType = newWithHooks(GraphQLScalarType, {
        name: compositeTypeName,
        description: "A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519) which securely represents claims between two parties.",
        serialize(value) {
          var token = attributes.reduce(function (memo, attr) {
            memo[attr.name] = value[attr.name];
            return memo;
          }, {});
          return (0, _jsonwebtoken.sign)(token, pgJwtSecret, (0, _assign2.default)({}, {
            audience: "postgraphql",
            issuer: "postgraphql"
          }, token.exp ? null : {
            expiresIn: "1 day"
          }));
        }
      }, {
        isPgJwtType: true
      });
      cb(JWTType);

      pg2GqlMapper[compositeType.id] = {
        map: function map(value) {
          if (!value) return null;
          var values = (0, _keys2.default)(value).map(function (k) {
            return value[k];
          });
          if (values.every(function (v) {
            return v == null;
          })) {
            return null;
          }
          return value;
        },
        unmap: function unmap() {
          throw new Error("We don't support passing a JWT token into GraphQL currently");
        }
      };

      pgTweaksByTypeId[compositeType.id] = function (fragment) {
        return sql.fragment`to_json(${fragment})`;
      };
    });
    return _;
  });
};

function parseTypeIdentifier(typeIdentifier) {
  var match = typeIdentifier.match(/^(?:([a-zA-Z0-9_]+)|"([^"]*)")\.(?:([a-zA-Z0-9_]+)|"([^"]*)")$/);

  if (!match) throw new Error(`Type identifier '${typeIdentifier}' is of the incorrect form.`);

  return {
    namespaceName: match[1] || match[2],
    typeName: match[3] || match[4]
  };
}
//# sourceMappingURL=PgJWTPlugin.js.map