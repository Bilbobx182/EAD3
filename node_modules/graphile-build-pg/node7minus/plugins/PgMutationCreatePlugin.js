"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _queryFromResolveData = require("../queryFromResolveData");

var _queryFromResolveData2 = _interopRequireDefault(_queryFromResolveData);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

var _viaTemporaryTable = require("./viaTemporaryTable");

var _viaTemporaryTable2 = _interopRequireDefault(_viaTemporaryTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("graphile-build-pg");

exports.default = function PgMutationCreatePlugin(builder, _ref) {
  var inflection = _ref.pgInflection,
      pgDisableDefaultMutations = _ref.pgDisableDefaultMutations;

  if (pgDisableDefaultMutations) {
    return;
  }
  builder.hook("GraphQLObjectType:fields", function (fields, build, _ref2) {
    var isRootMutation = _ref2.scope.isRootMutation,
        fieldWithHooks = _ref2.fieldWithHooks;
    var extend = build.extend,
        newWithHooks = build.newWithHooks,
        parseResolveInfo = build.parseResolveInfo,
        pgIntrospectionResultsByKind = build.pgIntrospectionResultsByKind,
        pgGetGqlTypeByTypeId = build.pgGetGqlTypeByTypeId,
        pgGetGqlInputTypeByTypeId = build.pgGetGqlInputTypeByTypeId,
        sql = build.pgSql,
        gql2pg = build.gql2pg,
        _build$graphql = build.graphql,
        GraphQLObjectType = _build$graphql.GraphQLObjectType,
        GraphQLInputObjectType = _build$graphql.GraphQLInputObjectType,
        GraphQLNonNull = _build$graphql.GraphQLNonNull,
        GraphQLString = _build$graphql.GraphQLString,
        pgColumnFilter = build.pgColumnFilter;

    if (!isRootMutation) {
      return fields;
    }

    return extend(fields, pgIntrospectionResultsByKind.class.filter(function (table) {
      return !!table.namespace;
    }).filter(function (table) {
      return table.isSelectable;
    }).filter(function (table) {
      return table.isInsertable;
    }).reduce(function (memo, table) {
      var Table = pgGetGqlTypeByTypeId(table.type.id);
      if (!Table) {
        debug(`There was no table type for table '${table.namespace.name}.${table.name}', so we're not generating a create mutation for it.`);
        return memo;
      }
      var TableInput = pgGetGqlInputTypeByTypeId(table.type.id);
      if (!TableInput) {
        debug(`There was no input type for table '${table.namespace.name}.${table.name}', so we're not generating a create mutation for it.`);
        return memo;
      }
      var tableTypeName = inflection.tableType(table.name, table.namespace.name);
      var InputType = newWithHooks(GraphQLInputObjectType, {
        name: inflection.createInputType(table.name, table.namespace.name),
        description: `All input for the create \`${tableTypeName}\` mutation.`,
        fields: {
          clientMutationId: {
            description: "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.",
            type: GraphQLString
          },
          [inflection.tableName(table.name, table.namespace.name)]: {
            description: `The \`${tableTypeName}\` to be created by this mutation.`,
            type: new GraphQLNonNull(TableInput)
          }
        }
      }, {
        isPgCreateInputType: true,
        pgInflection: table
      });
      var PayloadType = newWithHooks(GraphQLObjectType, {
        name: inflection.createPayloadType(table.name, table.namespace.name),
        description: `The output of our create \`${tableTypeName}\` mutation.`,
        fields: function fields(_ref3) {
          var recurseDataGeneratorsForField = _ref3.recurseDataGeneratorsForField;

          var tableName = inflection.tableName(table.name, table.namespace.name);
          recurseDataGeneratorsForField(tableName);
          return {
            clientMutationId: {
              description: "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.",
              type: GraphQLString
            },
            [tableName]: {
              description: `The \`${tableTypeName}\` that was created by this mutation.`,
              type: Table,
              resolve(data) {
                return data.data;
              }
            }
          };
        }
      }, {
        isMutationPayload: true,
        isPgCreatePayloadType: true,
        pgIntrospection: table
      });
      var fieldName = inflection.createField(table.name, table.namespace.name);
      memo[fieldName] = fieldWithHooks(fieldName, function (context) {
        var getDataFromParsedResolveInfoFragment = context.getDataFromParsedResolveInfoFragment;

        return {
          description: `Creates a single \`${tableTypeName}\`.`,
          type: PayloadType,
          args: {
            input: {
              type: new GraphQLNonNull(InputType)
            }
          },
          resolve(data, _ref4, _ref5, resolveInfo) {
            var _this = this;

            return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
              var input = _ref4.input;
              var pgClient = _ref5.pgClient;
              var parsedResolveInfoFragment, resolveData, insertedRowAlias, query, sqlColumns, sqlValues, inputData, mutationQuery, row, result;
              return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      parsedResolveInfoFragment = parseResolveInfo(resolveInfo);
                      resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, PayloadType);
                      insertedRowAlias = sql.identifier((0, _symbol2.default)());
                      query = (0, _queryFromResolveData2.default)(insertedRowAlias, insertedRowAlias, resolveData, {});
                      sqlColumns = [];
                      sqlValues = [];
                      inputData = input[inflection.tableName(table.name, table.namespace.name)];

                      pgIntrospectionResultsByKind.attribute.filter(function (attr) {
                        return attr.classId === table.id;
                      }).filter(function (attr) {
                        return pgColumnFilter(attr, build, context);
                      }).forEach(function (attr) {
                        var fieldName = inflection.column(attr.name, table.name, table.namespace.name);
                        var val = inputData[fieldName];
                        if (Object.prototype.hasOwnProperty.call(inputData, fieldName)) {
                          sqlColumns.push(sql.identifier(attr.name));
                          sqlValues.push(gql2pg(val, attr.type));
                        }
                      });

                      mutationQuery = sql.query`
                    insert into ${sql.identifier(table.namespace.name, table.name)} ${sqlColumns.length ? sql.fragment`(
                        ${sql.join(sqlColumns, ", ")}
                      ) values(${sql.join(sqlValues, ", ")})` : sql.fragment`default values`} returning *`;
                      row = void 0;
                      _context.prev = 10;
                      _context.next = 13;
                      return pgClient.query("SAVEPOINT graphql_mutation");

                    case 13:
                      _context.next = 15;
                      return (0, _viaTemporaryTable2.default)(pgClient, sql.identifier(table.namespace.name, table.name), mutationQuery, insertedRowAlias, query);

                    case 15:
                      result = _context.sent;

                      row = result.rows[0];
                      _context.next = 19;
                      return pgClient.query("RELEASE SAVEPOINT graphql_mutation");

                    case 19:
                      _context.next = 26;
                      break;

                    case 21:
                      _context.prev = 21;
                      _context.t0 = _context["catch"](10);
                      _context.next = 25;
                      return pgClient.query("ROLLBACK TO SAVEPOINT graphql_mutation");

                    case 25:
                      throw _context.t0;

                    case 26:
                      return _context.abrupt("return", {
                        clientMutationId: input.clientMutationId,
                        data: row
                      });

                    case 27:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, _this, [[10, 21]]);
            }))();
          }
        };
      }, {
        pgFieldIntrospection: table,
        isPgCreateMutationField: true
      });
      return memo;
    }, {}), `Adding default 'create' mutation to root mutation`);
  });
};
//# sourceMappingURL=PgMutationCreatePlugin.js.map