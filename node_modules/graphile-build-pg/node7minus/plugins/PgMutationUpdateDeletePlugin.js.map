{"version":3,"sources":["../../src/plugins/PgMutationUpdateDeletePlugin.js"],"names":["debug","base64Decode","Buffer","String","str","toString","builder","inflection","pgInflection","pgDisableDefaultMutations","hook","fields","build","isRootMutation","scope","fieldWithHooks","newWithHooks","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","fieldDataGeneratorsByType","extend","parseResolveInfo","getTypeByName","gql2pg","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","introspectionResultsByKind","pgIntrospectionResultsByKind","sql","pgSql","getNodeType","graphql","GraphQLNonNull","GraphQLInputObjectType","GraphQLString","GraphQLObjectType","GraphQLID","pgColumnFilter","reduce","outerMemo","mode","class","filter","table","namespace","isUpdatable","isDeletable","memo","pgClient","resolveInfo","getDataFromParsedResolveInfoFragment","PayloadType","input","condition","context","parsedResolveInfoFragment","resolveData","sqlTypeIdentifier","identifier","name","sqlMutationQuery","sqlColumns","sqlValues","inputData","patchField","tableName","attribute","attr","classId","id","forEach","fieldName","column","val","push","type","length","query","join","map","col","i","fragment","modifiedRowAlias","row","result","rows","Error","clientMutationId","data","commonCodeRenameMe","TableType","uniqueConstraints","constraint","con","attributes","sort","a","b","num","Table","tableTypeName","TablePatch","patchType","description","recurseDataGeneratorsForField","deletedNodeIdFieldName","singular","resolve","addDataGenerator","fieldDataGeneratorsByTableType","get","gens","gen","__identifiers","isPgMutationPayloadDeletedNodeIdField","isMutationPayload","isPgUpdatePayloadType","isPgDeletePayloadType","pgIntrospection","primaryKeyConstraint","primaryKeys","keyAttributeNums","InputType","isPgUpdateInputType","isPgUpdateNodeInputType","isPgDeleteInputType","isPgDeleteNodeInputType","isMutationInput","args","parent","nodeId","JSON","parse","alias","identifiers","NodeTypeByAlias","key","idx","isPgNodeMutation","pgFieldIntrospection","keys","every","_","simpleKeys","k","schema","typeId","isPgUpdateByKeysInputType","isPgDeleteByKeysInputType","pgKeys","PgMutationUpdateDeletePlugin"],"mappings":"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","file":"PgMutationUpdateDeletePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport debugFactory from \"debug\";\nimport camelCase from \"lodash/camelCase\";\nimport pluralize from \"pluralize\";\nimport viaTemporaryTable from \"./viaTemporaryTable\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\nconst base64Decode = str => new Buffer(String(str), \"base64\").toString(\"utf8\");\n\nexport default (async function PgMutationUpdateDeletePlugin(\n  builder,\n  { pgInflection: inflection, pgDisableDefaultMutations }\n) {\n  if (pgDisableDefaultMutations) {\n    return;\n  }\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, { scope: { isRootMutation }, fieldWithHooks }) => {\n      const {\n        newWithHooks,\n        getNodeIdForTypeAndIdentifiers,\n        nodeIdFieldName,\n        fieldDataGeneratorsByType,\n        extend,\n        parseResolveInfo,\n        getTypeByName,\n        gql2pg,\n        pgGetGqlTypeByTypeId,\n        pgGetGqlInputTypeByTypeId,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        getNodeType,\n        graphql: {\n          GraphQLNonNull,\n          GraphQLInputObjectType,\n          GraphQLString,\n          GraphQLObjectType,\n          GraphQLID,\n        },\n        pgColumnFilter,\n      } = build;\n      if (!isRootMutation) {\n        return fields;\n      }\n      return extend(\n        fields,\n        [\"update\", \"delete\"].reduce(\n          (outerMemo, mode) =>\n            introspectionResultsByKind.class\n              .filter(table => !!table.namespace)\n              .filter(\n                table =>\n                  (mode === \"update\" && table.isUpdatable) ||\n                  (mode === \"delete\" && table.isDeletable)\n              )\n              .reduce((memo, table) => {\n                const TableType = pgGetGqlTypeByTypeId(table.type.id);\n                async function commonCodeRenameMe(\n                  pgClient,\n                  resolveInfo,\n                  getDataFromParsedResolveInfoFragment,\n                  PayloadType,\n                  input,\n                  condition,\n                  context\n                ) {\n                  const parsedResolveInfoFragment = parseResolveInfo(\n                    resolveInfo\n                  );\n                  const resolveData = getDataFromParsedResolveInfoFragment(\n                    parsedResolveInfoFragment,\n                    PayloadType\n                  );\n\n                  const sqlTypeIdentifier = sql.identifier(\n                    table.namespace.name,\n                    table.name\n                  );\n\n                  let sqlMutationQuery;\n                  if (mode === \"update\") {\n                    const sqlColumns = [];\n                    const sqlValues = [];\n                    const inputData =\n                      input[\n                        inflection.patchField(\n                          inflection.tableName(table.name, table.namespace.name)\n                        )\n                      ];\n                    introspectionResultsByKind.attribute\n                      .filter(attr => attr.classId === table.id)\n                      .filter(attr => pgColumnFilter(attr, build, context))\n                      .forEach(attr => {\n                        const fieldName = inflection.column(\n                          attr.name,\n                          table.name,\n                          table.namespace.name\n                        );\n                        if (\n                          fieldName in\n                          inputData /* Because we care about null! */\n                        ) {\n                          const val = inputData[fieldName];\n                          sqlColumns.push(sql.identifier(attr.name));\n                          sqlValues.push(gql2pg(val, attr.type));\n                        }\n                      });\n                    if (sqlColumns.length === 0) {\n                      return null;\n                    }\n                    sqlMutationQuery = sql.query`\n                      update ${sql.identifier(\n                        table.namespace.name,\n                        table.name\n                      )} set ${sql.join(\n                      sqlColumns.map(\n                        (col, i) => sql.fragment`${col} = ${sqlValues[i]}`\n                      ),\n                      \", \"\n                    )}\n                      where ${condition}\n                      returning *`;\n                  } else {\n                    sqlMutationQuery = sql.query`\n                      delete from ${sql.identifier(\n                        table.namespace.name,\n                        table.name\n                      )}\n                      where ${condition}\n                      returning *`;\n                  }\n\n                  const modifiedRowAlias = sql.identifier(Symbol());\n                  const query = queryFromResolveData(\n                    modifiedRowAlias,\n                    modifiedRowAlias,\n                    resolveData,\n                    {}\n                  );\n                  let row;\n                  try {\n                    await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                    const result = await viaTemporaryTable(\n                      pgClient,\n                      sqlTypeIdentifier,\n                      sqlMutationQuery,\n                      modifiedRowAlias,\n                      query\n                    );\n                    row = result.rows[0];\n                    await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                  } catch (e) {\n                    await pgClient.query(\n                      \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                    );\n                    throw e;\n                  }\n                  if (!row) {\n                    throw new Error(\n                      `No values were ${mode}d in collection '${pluralize(\n                        table.name\n                      )}' because no values were found.`\n                    );\n                  }\n                  return {\n                    clientMutationId: input.clientMutationId,\n                    data: row,\n                  };\n                }\n                if (TableType) {\n                  const uniqueConstraints = introspectionResultsByKind.constraint\n                    .filter(con => con.classId === table.id)\n                    .filter(con => con.type === \"u\" || con.type === \"p\");\n                  const attributes = introspectionResultsByKind.attribute\n                    .filter(attr => attr.classId === table.id)\n                    .sort((a, b) => a.num - b.num);\n                  const Table = pgGetGqlTypeByTypeId(table.type.id);\n                  const tableTypeName = Table.name;\n                  const TablePatch = getTypeByName(\n                    inflection.patchType(Table.name)\n                  );\n                  const PayloadType = newWithHooks(\n                    GraphQLObjectType,\n                    {\n                      name: inflection[\n                        mode === \"delete\"\n                          ? \"deletePayloadType\"\n                          : \"updatePayloadType\"\n                      ](table.name, table.namespace.name),\n                      description: `The output of our ${mode} \\`${tableTypeName}\\` mutation.`,\n                      fields: ({\n                        recurseDataGeneratorsForField,\n                        fieldWithHooks,\n                      }) => {\n                        const tableName = inflection.tableName(\n                          table.name,\n                          table.namespace.name\n                        );\n                        recurseDataGeneratorsForField(tableName);\n                        // This should really be `-node-id` but for compatibility with PostGraphQL v3 we haven't made that change.\n                        const deletedNodeIdFieldName = camelCase(\n                          `deleted-${pluralize.singular(table.name)}-id`\n                        );\n                        return Object.assign(\n                          {\n                            clientMutationId: {\n                              description:\n                                \"The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.\",\n                              type: GraphQLString,\n                            },\n                            [tableName]: {\n                              description: `The \\`${tableTypeName}\\` that was ${mode}d by this mutation.`,\n                              type: Table,\n                              resolve(data) {\n                                return data.data;\n                              },\n                            },\n                          },\n                          mode === \"delete\"\n                            ? {\n                                [deletedNodeIdFieldName]: fieldWithHooks(\n                                  deletedNodeIdFieldName,\n                                  ({ addDataGenerator }) => {\n                                    const fieldDataGeneratorsByTableType = fieldDataGeneratorsByType.get(\n                                      TableType\n                                    );\n\n                                    const gens =\n                                      fieldDataGeneratorsByTableType &&\n                                      fieldDataGeneratorsByTableType[\n                                        nodeIdFieldName\n                                      ];\n                                    if (gens) {\n                                      gens.forEach(gen =>\n                                        addDataGenerator(gen)\n                                      );\n                                    }\n                                    return {\n                                      type: GraphQLID,\n                                      resolve(data) {\n                                        return (\n                                          data.data.__identifiers &&\n                                          getNodeIdForTypeAndIdentifiers(\n                                            Table,\n                                            ...data.data.__identifiers\n                                          )\n                                        );\n                                      },\n                                    };\n                                  },\n                                  {\n                                    isPgMutationPayloadDeletedNodeIdField: true,\n                                  }\n                                ),\n                              }\n                            : null\n                        );\n                      },\n                    },\n                    {\n                      isMutationPayload: true,\n                      isPgUpdatePayloadType: mode === \"update\",\n                      isPgDeletePayloadType: mode === \"delete\",\n                      pgIntrospection: table,\n                    }\n                  );\n\n                  // NodeId\n                  if (nodeIdFieldName) {\n                    const primaryKeyConstraint = introspectionResultsByKind.constraint\n                      .filter(con => con.classId === table.id)\n                      .filter(con => con.type === \"p\")[0];\n                    if (!primaryKeyConstraint) {\n                      return memo;\n                    }\n                    const primaryKeys =\n                      primaryKeyConstraint &&\n                      primaryKeyConstraint.keyAttributeNums.map(\n                        num => attributes.filter(attr => attr.num === num)[0]\n                      );\n                    const fieldName = inflection[\n                      mode === \"update\" ? \"updateNode\" : \"deleteNode\"\n                    ](table.name, table.namespace.name);\n                    const InputType = newWithHooks(\n                      GraphQLInputObjectType,\n                      {\n                        description: `All input for the \\`${fieldName}\\` mutation.`,\n                        name: inflection[\n                          mode === \"update\"\n                            ? \"updateNodeInputType\"\n                            : \"deleteNodeInputType\"\n                        ](table.name, table.namespace.name),\n                        fields: Object.assign(\n                          {\n                            clientMutationId: {\n                              description:\n                                \"An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.\",\n                              type: GraphQLString,\n                            },\n                            [nodeIdFieldName]: {\n                              description: `The globally unique \\`ID\\` which will identify a single \\`${tableTypeName}\\` to be ${mode}d.`,\n                              type: new GraphQLNonNull(GraphQLID),\n                            },\n                          },\n                          mode === \"update\"\n                            ? {\n                                [inflection.patchField(\n                                  inflection.tableName(\n                                    table.name,\n                                    table.namespace.name\n                                  )\n                                )]: {\n                                  description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                  type: new GraphQLNonNull(TablePatch),\n                                },\n                              }\n                            : null\n                        ),\n                      },\n                      {\n                        isPgUpdateInputType: mode === \"update\",\n                        isPgUpdateNodeInputType: mode === \"update\",\n                        isPgDeleteInputType: mode === \"delete\",\n                        isPgDeleteNodeInputType: mode === \"delete\",\n                        pgInflection: table,\n                        isMutationInput: true,\n                      }\n                    );\n\n                    memo[fieldName] = fieldWithHooks(\n                      fieldName,\n                      context => {\n                        const {\n                          getDataFromParsedResolveInfoFragment,\n                        } = context;\n                        return {\n                          description:\n                            mode === \"update\"\n                              ? `Updates a single \\`${tableTypeName}\\` using its globally unique id and a patch.`\n                              : `Deletes a single \\`${tableTypeName}\\` using its globally unique id.`,\n                          type: PayloadType,\n                          args: {\n                            input: {\n                              type: new GraphQLNonNull(InputType),\n                            },\n                          },\n                          async resolve(\n                            parent,\n                            { input },\n                            { pgClient },\n                            resolveInfo\n                          ) {\n                            const nodeId = input[nodeIdFieldName];\n                            try {\n                              const [alias, ...identifiers] = JSON.parse(\n                                base64Decode(nodeId)\n                              );\n                              const NodeTypeByAlias = getNodeType(alias);\n                              if (NodeTypeByAlias !== TableType) {\n                                throw new Error(\"Mismatched type\");\n                              }\n                              if (identifiers.length !== primaryKeys.length) {\n                                throw new Error(\"Invalid ID\");\n                              }\n\n                              return commonCodeRenameMe(\n                                pgClient,\n                                resolveInfo,\n                                getDataFromParsedResolveInfoFragment,\n                                PayloadType,\n                                input,\n                                sql.fragment`(${sql.join(\n                                  primaryKeys.map(\n                                    (key, idx) =>\n                                      sql.fragment`${sql.identifier(\n                                        key.name\n                                      )} = ${gql2pg(\n                                        identifiers[idx],\n                                        key.type\n                                      )}`\n                                  ),\n                                  \") and (\"\n                                )})`,\n                                context\n                              );\n                            } catch (e) {\n                              debug(e);\n                              return null;\n                            }\n                          },\n                        };\n                      },\n                      {\n                        isPgNodeMutation: true,\n                        pgFieldIntrospection: table,\n                        [mode === \"update\"\n                          ? \"isPgUpdateMutationField\"\n                          : \"isPgDeleteMutationField\"]: true,\n                      }\n                    );\n                  }\n\n                  // Unique\n                  uniqueConstraints.forEach(constraint => {\n                    const keys = constraint.keyAttributeNums.map(\n                      num => attributes.filter(attr => attr.num === num)[0]\n                    );\n                    if (!keys.every(_ => _)) {\n                      throw new Error(\n                        \"Consistency error: could not find an attribute!\"\n                      );\n                    }\n                    const simpleKeys = keys.map(k => ({\n                      column: k.name,\n                      table: k.class.name,\n                      schema: k.class.namespace.name,\n                    }));\n                    const fieldName = inflection[\n                      mode === \"update\" ? \"updateByKeys\" : \"deleteByKeys\"\n                    ](simpleKeys, table.name, table.namespace.name);\n                    const InputType = newWithHooks(\n                      GraphQLInputObjectType,\n                      {\n                        description: `All input for the \\`${fieldName}\\` mutation.`,\n                        name: inflection[\n                          mode === \"update\"\n                            ? \"updateByKeysInputType\"\n                            : \"deleteByKeysInputType\"\n                        ](simpleKeys, table.name, table.namespace.name),\n                        fields: Object.assign(\n                          {\n                            clientMutationId: {\n                              type: GraphQLString,\n                            },\n                          },\n                          mode === \"update\"\n                            ? {\n                                [inflection.patchField(\n                                  inflection.tableName(\n                                    table.name,\n                                    table.namespace.name\n                                  )\n                                )]: {\n                                  description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                  type: new GraphQLNonNull(TablePatch),\n                                },\n                              }\n                            : null,\n                          keys.reduce((memo, key) => {\n                            memo[\n                              inflection.column(\n                                key.name,\n                                key.class.name,\n                                key.class.namespace.name\n                              )\n                            ] = {\n                              type: new GraphQLNonNull(\n                                pgGetGqlInputTypeByTypeId(key.typeId)\n                              ),\n                            };\n                            return memo;\n                          }, {})\n                        ),\n                      },\n                      {\n                        isPgUpdateInputType: mode === \"update\",\n                        isPgUpdateByKeysInputType: mode === \"update\",\n                        isPgDeleteInputType: mode === \"delete\",\n                        isPgDeleteByKeysInputType: mode === \"delete\",\n                        pgInflection: table,\n                        pgKeys: keys,\n                        isMutationInput: true,\n                      }\n                    );\n\n                    memo[fieldName] = fieldWithHooks(\n                      fieldName,\n                      context => {\n                        const {\n                          getDataFromParsedResolveInfoFragment,\n                        } = context;\n                        return {\n                          description:\n                            mode === \"update\"\n                              ? `Updates a single \\`${tableTypeName}\\` using a unique key and a patch.`\n                              : `Deletes a single \\`${tableTypeName}\\` using a unique key.`,\n                          type: PayloadType,\n                          args: {\n                            input: {\n                              type: new GraphQLNonNull(InputType),\n                            },\n                          },\n                          async resolve(\n                            parent,\n                            { input },\n                            { pgClient },\n                            resolveInfo\n                          ) {\n                            return commonCodeRenameMe(\n                              pgClient,\n                              resolveInfo,\n                              getDataFromParsedResolveInfoFragment,\n                              PayloadType,\n                              input,\n                              sql.fragment`(${sql.join(\n                                keys.map(\n                                  key =>\n                                    sql.fragment`${sql.identifier(\n                                      key.name\n                                    )} = ${gql2pg(\n                                      input[\n                                        inflection.column(\n                                          key.name,\n                                          key.class.name,\n                                          key.class.namespace.name\n                                        )\n                                      ],\n                                      key.type\n                                    )}`\n                                ),\n                                \") and (\"\n                              )})`,\n                              context\n                            );\n                          },\n                        };\n                      },\n                      {\n                        isPgNodeMutation: false,\n                        pgFieldIntrospection: table,\n                        [mode === \"update\"\n                          ? \"isPgUpdateMutationField\"\n                          : \"isPgDeleteMutationField\"]: true,\n                      }\n                    );\n                  });\n                }\n                return memo;\n              }, outerMemo),\n          {}\n        ),\n        `Adding default update/delete mutations to root Mutation type`\n      );\n    }\n  );\n}: Plugin);\n"]}