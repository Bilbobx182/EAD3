"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var base64 = function base64(str) {
  return new Buffer(String(str)).toString("base64");
};

exports.default = function PgTablesPlugin(builder, _ref) {
  var inflection = _ref.pgInflection;

  builder.hook("init", function (_, build) {
    var getNodeIdForTypeAndIdentifiers = build.getNodeIdForTypeAndIdentifiers,
        nodeIdFieldName = build.nodeIdFieldName,
        newWithHooks = build.newWithHooks,
        sql = build.pgSql,
        introspectionResultsByKind = build.pgIntrospectionResultsByKind,
        getTypeByName = build.getTypeByName,
        pgGetGqlTypeByTypeId = build.pgGetGqlTypeByTypeId,
        pgGetGqlInputTypeByTypeId = build.pgGetGqlInputTypeByTypeId,
        pgRegisterGqlTypeByTypeId = build.pgRegisterGqlTypeByTypeId,
        pgRegisterGqlInputTypeByTypeId = build.pgRegisterGqlInputTypeByTypeId,
        pg2GqlMapper = build.pg2GqlMapper,
        gql2pg = build.gql2pg,
        _build$graphql = build.graphql,
        GraphQLObjectType = _build$graphql.GraphQLObjectType,
        GraphQLNonNull = _build$graphql.GraphQLNonNull,
        GraphQLID = _build$graphql.GraphQLID,
        GraphQLList = _build$graphql.GraphQLList,
        GraphQLInputObjectType = _build$graphql.GraphQLInputObjectType,
        pgColumnFilter = build.pgColumnFilter;

    var Cursor = getTypeByName("Cursor");
    introspectionResultsByKind.class.forEach(function (table) {
      var tablePgType = introspectionResultsByKind.type.find(function (type) {
        return type.type === "c" && type.category === "C" && type.namespaceId === table.namespaceId && type.classId === table.id;
      });
      if (!tablePgType) {
        throw new Error("Could not determine the type for this table");
      }
      var arrayTablePgType = introspectionResultsByKind.type.find(function (type) {
        return type.arrayItemTypeId === tablePgType.id;
      });
      /*
        table =
          { kind: 'class',
            id: '6484790',
            name: 'bundle',
            description: null,
            namespaceId: '6484381',
            typeId: '6484792',
            isSelectable: true,
            isInsertable: true,
            isUpdatable: true,
            isDeletable: true }
        */
      var primaryKeyConstraint = introspectionResultsByKind.constraint.filter(function (con) {
        return con.classId === table.id;
      }).filter(function (con) {
        return con.type === "p";
      })[0];
      var primaryKeys = primaryKeyConstraint && primaryKeyConstraint.keyAttributeNums.map(function (num) {
        return introspectionResultsByKind.attributeByClassIdAndNum[table.id][num];
      });
      var attributes = introspectionResultsByKind.attribute.filter(function (attr) {
        return attr.classId === table.id;
      }).sort(function (a1, a2) {
        return a1.num - a2.num;
      });
      var tableTypeName = inflection.tableType(table.name, table.namespaceName);
      var shouldHaveNodeId = nodeIdFieldName && table.isSelectable && table.namespace && primaryKeys && primaryKeys.length ? true : false;
      pgRegisterGqlTypeByTypeId(tablePgType.id, function (cb) {
        if (pg2GqlMapper[tablePgType.id]) {
          // Already handled
          throw new Error(`Register was called but there's already a mapper in place for '${tablePgType.id}'!`);
        }
        var TableType = newWithHooks(GraphQLObjectType, {
          description: table.description || tablePgType.description,
          name: tableTypeName,
          interfaces: function interfaces() {
            if (shouldHaveNodeId) {
              return [getTypeByName("Node")];
            } else {
              return [];
            }
          },
          fields: function fields(_ref2) {
            var addDataGeneratorForField = _ref2.addDataGeneratorForField,
                Self = _ref2.Self;

            var fields = {};
            if (shouldHaveNodeId) {
              // Enable nodeId interface
              addDataGeneratorForField(nodeIdFieldName, function () {
                return {
                  pgQuery: function pgQuery(queryBuilder) {
                    queryBuilder.select(sql.fragment`json_build_array(${sql.join(primaryKeys.map(function (key) {
                      return sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(key.name)}`;
                    }), ", ")})`, "__identifiers");
                  }
                };
              });
              fields[nodeIdFieldName] = {
                description: "A globally unique identifier. Can be used in various places throughout the system to identify this single value.",
                type: new GraphQLNonNull(GraphQLID),
                resolve(data) {
                  return data.__identifiers && getNodeIdForTypeAndIdentifiers.apply(undefined, [Self].concat((0, _toConsumableArray3.default)(data.__identifiers)));
                }
              };
            }
            return fields;
          }
        }, {
          pgIntrospection: table,
          isPgRowType: table.isSelectable,
          isPgCompoundType: !table.isSelectable
        });
        cb(TableType);
        var pgInputFields = {};
        newWithHooks(GraphQLInputObjectType, {
          description: `An input for mutations affecting \`${tableTypeName}\``,
          name: inflection.inputType(TableType),
          fields: function fields(context) {
            pg2GqlMapper[tablePgType.id] = {
              map: function map(_) {
                return _;
              },
              unmap: function unmap(obj) {
                return sql.fragment`row(${sql.join(attributes.map(function (attr) {
                  if (!pgColumnFilter(attr, build, context)) {
                    return sql.null; // TODO: return default instead.
                  }
                  var fieldName = inflection.column(attr.name, table.name, table.namespaceName);
                  var pgInputField = pgInputFields[fieldName];
                  var v = obj[fieldName];
                  if (pgInputField && v != null) {
                    var type = pgInputField.type;

                    return sql.fragment`${gql2pg(v, type)}::${sql.identifier(type.namespaceName, type.name)}`;
                  } else {
                    return sql.null; // TODO: return default instead.
                  }
                }), ",")})::${sql.identifier(tablePgType.namespaceName, tablePgType.name)}`;
              }
            };
            return {};
          }
        }, {
          pgIntrospection: table,
          isInputType: true,
          isPgRowType: table.isSelectable,
          isPgCompoundType: !table.isSelectable,
          pgAddSubfield(fieldName, attrName, pgType, spec) {
            pgInputFields[fieldName] = {
              name: attrName,
              type: pgType
            };
            return spec;
          }
        });

        if (table.isSelectable) {
          /* const TablePatchType = */
          newWithHooks(GraphQLInputObjectType, {
            description: `Represents an update to a \`${tableTypeName}\`. Fields that are set will be updated.`,
            name: inflection.patchType(TableType)
          }, {
            pgIntrospection: table,
            isPgRowType: table.isSelectable,
            isPgCompoundType: !table.isSelectable,
            isPgPatch: true,
            pgAddSubfield(fieldName, _attrName, _type, spec) {
              // We don't use this currently
              return spec;
            }
          });
        }
        var EdgeType = newWithHooks(GraphQLObjectType, {
          description: `A \`${tableTypeName}\` edge in the connection.`,
          name: inflection.edge(TableType.name),
          fields: function fields(_ref3) {
            var fieldWithHooks = _ref3.fieldWithHooks,
                recurseDataGeneratorsForField = _ref3.recurseDataGeneratorsForField;

            recurseDataGeneratorsForField("node");
            return {
              cursor: fieldWithHooks("cursor", function (_ref4) {
                var addDataGenerator = _ref4.addDataGenerator;

                addDataGenerator(function () {
                  return {
                    usesCursor: [true]
                  };
                });
                return {
                  description: "A cursor for use in pagination.",
                  type: Cursor,
                  resolve(data) {
                    return data.__cursor && base64((0, _stringify2.default)(data.__cursor));
                  }
                };
              }, {
                isCursorField: true
              }),
              node: {
                description: `The \`${tableTypeName}\` at the end of the edge.`,
                type: new GraphQLNonNull(TableType),
                resolve(data) {
                  return data;
                }
              }
            };
          }
        }, {
          isEdgeType: true,
          isPgRowEdgeType: true,
          nodeType: TableType,
          pgIntrospection: table
        });
        var PageInfo = getTypeByName("PageInfo");
        /*const ConnectionType = */
        newWithHooks(GraphQLObjectType, {
          description: `A connection to a list of \`${tableTypeName}\` values.`,
          name: inflection.connection(TableType.name),
          fields: function fields(_ref5) {
            var recurseDataGeneratorsForField = _ref5.recurseDataGeneratorsForField;

            recurseDataGeneratorsForField("edges");
            recurseDataGeneratorsForField("nodes");
            recurseDataGeneratorsForField("pageInfo");
            return {
              nodes: {
                description: `A list of \`${tableTypeName}\` objects.`,
                type: new GraphQLNonNull(new GraphQLList(TableType)),
                resolve(data) {
                  return data.data;
                }
              },
              edges: {
                description: `A list of edges which contains the \`${tableTypeName}\` and cursor to aid in pagination.`,
                type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(EdgeType))),
                resolve(data) {
                  return data.data;
                }
              },
              pageInfo: PageInfo && {
                description: "Information to aid in pagination.",
                type: new GraphQLNonNull(PageInfo),
                resolve(data) {
                  return data;
                }
              }
            };
          }
        }, {
          isConnectionType: true,
          isPgRowConnectionType: true,
          edgeType: EdgeType,
          nodeType: TableType,
          pgIntrospection: table
        });
      }, true);
      pgRegisterGqlInputTypeByTypeId(tablePgType.id, function () {
        var TableType = pgGetGqlTypeByTypeId(tablePgType.id);
        return getTypeByName(inflection.inputType(TableType));
      }, true);

      if (arrayTablePgType) {
        // Note: these do not return
        //
        // `new GraphQLList(new GraphQLNonNull(...))`
        //
        // because it's possible to return null entries from postgresql
        // functions. We should probably add a flag to instead export
        // the non-null version as that's more typical.
        pgRegisterGqlTypeByTypeId(arrayTablePgType.id, function () {
          var TableType = pgGetGqlTypeByTypeId(tablePgType.id);
          return new GraphQLList(TableType);
        }, true);
        pgRegisterGqlInputTypeByTypeId(arrayTablePgType.id, function () {
          var TableInputType = pgGetGqlInputTypeByTypeId(tablePgType.id);
          return new GraphQLList(TableInputType);
        }, true);
      }
    });
    return _;
  });
};
//# sourceMappingURL=PgTablesPlugin.js.map