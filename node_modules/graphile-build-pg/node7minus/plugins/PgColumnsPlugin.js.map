{"version":3,"sources":["../../src/plugins/PgColumnsPlugin.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","PgColumnsPlugin","builder","inflection","pgInflection","hook","fields","build","context","extend","pgGetGqlTypeByTypeId","introspectionResultsByKind","pgIntrospectionResultsByKind","sql","pgSql","pg2gql","graphql","GraphQLString","getAliasFromResolveInfo","pgTweakFragmentForType","pgColumnFilter","scope","isPgRowType","isPgCompoundType","table","pgIntrospection","fieldWithHooks","Self","kind","attribute","filter","attr","classId","id","reduce","memo","fieldName","column","name","namespaceName","Error","getDataFromParsedResolveInfoFragment","addDataGenerator","ReturnType","typeId","alias","parsedResolveInfoFragment","pgQuery","getSelectValueForFieldAndType","sqlFullName","type","isPgArray","ident","identifier","fragment","arrayItemType","resolveData","jsonBuildObject","onlyJsonField","addNullCase","queryBuilder","select","getTableAlias","description","isNotNull","domainIsNotNull","resolve","data","_args","_context","resolveInfo","pgFieldIntrospection","pgGetGqlInputTypeByTypeId","isPgPatch","pgAddSubfield","hasDefault"],"mappings":"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","file":"PgColumnsPlugin.js","sourcesContent":["// @flow\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport type { Plugin } from \"graphile-build\";\n\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nexport default (function PgColumnsPlugin(\n  builder,\n  { pgInflection: inflection }\n) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlTypeByTypeId,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      pg2gql,\n      graphql: { GraphQLString, GraphQLNonNull },\n      getAliasFromResolveInfo,\n      pgTweakFragmentForType,\n      pgColumnFilter,\n    } = build;\n    const {\n      scope: { isPgRowType, isPgCompoundType, pgIntrospection: table },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .reduce((memo, attr) => {\n          /*\n            attr =\n              { kind: 'attribute',\n                classId: '6546809',\n                num: 21,\n                name: 'upstreamName',\n                description: null,\n                typeId: '6484393',\n                isNotNull: false,\n                hasDefault: false }\n            */\n          const fieldName = inflection.column(\n            attr.name,\n            table.name,\n            table.namespaceName\n          );\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo[fieldName] = fieldWithHooks(\n            fieldName,\n            ({ getDataFromParsedResolveInfoFragment, addDataGenerator }) => {\n              const ReturnType =\n                pgGetGqlTypeByTypeId(attr.typeId) || GraphQLString;\n              addDataGenerator(parsedResolveInfoFragment => {\n                const { alias } = parsedResolveInfoFragment;\n                return {\n                  pgQuery: queryBuilder => {\n                    const getSelectValueForFieldAndType = (\n                      sqlFullName,\n                      type\n                    ) => {\n                      if (type.isPgArray) {\n                        const ident = sql.identifier(Symbol());\n                        return sql.fragment`\n                          (\n                            case\n                            when ${sqlFullName} is null then null\n                            when coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json\n                            else\n                              (\n                                select json_agg(${getSelectValueForFieldAndType(\n                                  ident,\n                                  type.arrayItemType\n                                )})\n                                from unnest(${sqlFullName}) as ${ident}\n                              )\n                            end\n                          )\n                        `;\n                      } else if (type.type === \"c\") {\n                        const resolveData = getDataFromParsedResolveInfoFragment(\n                          parsedResolveInfoFragment,\n                          ReturnType\n                        );\n                        const jsonBuildObject = queryFromResolveData(\n                          sql.identifier(Symbol()), // Ignore!\n                          sqlFullName,\n                          resolveData,\n                          { onlyJsonField: true, addNullCase: true }\n                        );\n                        return jsonBuildObject;\n                      } else {\n                        return pgTweakFragmentForType(sqlFullName, type);\n                      }\n                    };\n                    queryBuilder.select(\n                      getSelectValueForFieldAndType(\n                        sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(\n                          attr.name\n                        )})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING\n                        attr.type\n                      ),\n                      alias\n                    );\n                  },\n                };\n              });\n              return {\n                description: attr.description,\n                type: nullableIf(\n                  GraphQLNonNull,\n                  !attr.isNotNull && !attr.type.domainIsNotNull,\n                  ReturnType\n                ),\n                resolve: (data, _args, _context, resolveInfo) => {\n                  const alias = getAliasFromResolveInfo(resolveInfo);\n                  return pg2gql(data[alias], attr.type);\n                },\n              };\n            },\n            { pgFieldIntrospection: attr }\n          );\n          return memo;\n        }, {}),\n      `Adding columns to '${Self.name}'`\n    );\n  });\n  builder.hook(\"GraphQLInputObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlInputTypeByTypeId,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgColumnFilter,\n    } = build;\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isPgPatch,\n        pgIntrospection: table,\n        pgAddSubfield,\n      },\n      Self,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .reduce((memo, attr) => {\n          const fieldName = inflection.column(\n            attr.name,\n            table.name,\n            table.namespaceName\n          );\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on input class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo[fieldName] = pgAddSubfield(fieldName, attr.name, attr.type, {\n            description: attr.description,\n            type: nullableIf(\n              GraphQLNonNull,\n              isPgPatch ||\n                (!attr.isNotNull && !attr.type.domainIsNotNull) ||\n                attr.hasDefault,\n              pgGetGqlInputTypeByTypeId(attr.typeId) || GraphQLString\n            ),\n          });\n          return memo;\n        }, {}),\n      `Adding columns to input object '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}