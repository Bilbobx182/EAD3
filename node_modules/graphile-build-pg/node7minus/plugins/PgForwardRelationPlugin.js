"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

var _queryFromResolveData = require("../queryFromResolveData");

var _queryFromResolveData2 = _interopRequireDefault(_queryFromResolveData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("graphile-build-pg");

exports.default = function PgForwardRelationPlugin(builder, _ref) {
  var inflection = _ref.pgInflection;

  builder.hook("GraphQLObjectType:fields", function (fields, _ref2, _ref3) {
    var extend = _ref2.extend,
        getAliasFromResolveInfo = _ref2.getAliasFromResolveInfo,
        pgGetGqlTypeByTypeId = _ref2.pgGetGqlTypeByTypeId,
        introspectionResultsByKind = _ref2.pgIntrospectionResultsByKind,
        sql = _ref2.pgSql;
    var _ref3$scope = _ref3.scope,
        isPgRowType = _ref3$scope.isPgRowType,
        isMutationPayload = _ref3$scope.isMutationPayload,
        pgIntrospection = _ref3$scope.pgIntrospection,
        pgIntrospectionTable = _ref3$scope.pgIntrospectionTable,
        fieldWithHooks = _ref3.fieldWithHooks,
        Self = _ref3.Self;

    var table = pgIntrospectionTable || pgIntrospection;
    if (!(isPgRowType || isMutationPayload) || !table || table.kind !== "class" || !table.namespace) {
      return fields;
    }
    // This is a relation in which we (table) are local, and there's a foreign table

    var foreignKeyConstraints = introspectionResultsByKind.constraint.filter(function (con) {
      return con.type === "f";
    }).filter(function (con) {
      return con.classId === table.id;
    });
    var attributes = introspectionResultsByKind.attribute.filter(function (attr) {
      return attr.classId === table.id;
    }).sort(function (a, b) {
      return a.num - b.num;
    });

    return extend(fields, foreignKeyConstraints.reduce(function (memo, constraint) {
      var gqlTableType = pgGetGqlTypeByTypeId(table.type.id);
      var tableTypeName = gqlTableType.name;
      if (!gqlTableType) {
        debug(`Could not determine type for table with id ${constraint.classId}`);
        return memo;
      }
      var foreignTable = introspectionResultsByKind.classById[constraint.foreignClassId];
      var gqlForeignTableType = pgGetGqlTypeByTypeId(foreignTable.type.id);
      var foreignTableTypeName = gqlForeignTableType.name;
      if (!gqlForeignTableType) {
        debug(`Could not determine type for foreign table with id ${constraint.foreignClassId}`);
        return memo;
      }
      if (!foreignTable) {
        throw new Error(`Could not find the foreign table (constraint: ${constraint.name})`);
      }
      var foreignSchema = introspectionResultsByKind.namespace.filter(function (n) {
        return n.id === foreignTable.namespaceId;
      })[0];
      var foreignAttributes = introspectionResultsByKind.attribute.filter(function (attr) {
        return attr.classId === constraint.foreignClassId;
      }).sort(function (a, b) {
        return a.num - b.num;
      });

      var keys = constraint.keyAttributeNums.map(function (num) {
        return attributes.filter(function (attr) {
          return attr.num === num;
        })[0];
      });
      var foreignKeys = constraint.foreignKeyAttributeNums.map(function (num) {
        return foreignAttributes.filter(function (attr) {
          return attr.num === num;
        })[0];
      });
      if (!keys.every(function (_) {
        return _;
      }) || !foreignKeys.every(function (_) {
        return _;
      })) {
        throw new Error("Could not find key columns!");
      }

      var simpleKeys = keys.map(function (k) {
        return {
          column: k.name,
          table: k.class.name,
          schema: k.class.namespace.name
        };
      });
      var fieldName = inflection.singleRelationByKeys(simpleKeys, foreignTable.name, foreignTable.namespace.name);

      memo[fieldName] = fieldWithHooks(fieldName, function (_ref4) {
        var getDataFromParsedResolveInfoFragment = _ref4.getDataFromParsedResolveInfoFragment,
            addDataGenerator = _ref4.addDataGenerator;

        addDataGenerator(function (parsedResolveInfoFragment) {
          return {
            pgQuery: function pgQuery(queryBuilder) {
              queryBuilder.select(function () {
                var resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, gqlForeignTableType);
                var foreignTableAlias = sql.identifier((0, _symbol2.default)());
                var query = (0, _queryFromResolveData2.default)(sql.identifier(foreignSchema.name, foreignTable.name), foreignTableAlias, resolveData, { asJson: true }, function (innerQueryBuilder) {
                  keys.forEach(function (key, i) {
                    innerQueryBuilder.where(sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(key.name)} = ${foreignTableAlias}.${sql.identifier(foreignKeys[i].name)}`);
                  });
                });
                return sql.fragment`(${query})`;
              }, parsedResolveInfoFragment.alias);
            }
          };
        });
        return {
          description: `Reads a single \`${foreignTableTypeName}\` that is related to this \`${tableTypeName}\`.`,
          type: gqlForeignTableType, // Nullable since RLS may forbid fetching
          resolve: function resolve(rawData, _args, _context, resolveInfo) {
            var data = isMutationPayload ? rawData.data : rawData;
            var alias = getAliasFromResolveInfo(resolveInfo);
            return data[alias];
          }
        };
      }, {
        pgFieldIntrospection: constraint
      });
      return memo;
    }, {}), `Adding forward relations to '${Self.name}'`);
  });
};
//# sourceMappingURL=PgForwardRelationPlugin.js.map