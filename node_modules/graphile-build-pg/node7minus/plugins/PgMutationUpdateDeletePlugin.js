"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toArray2 = require("babel-runtime/helpers/toArray");

var _toArray3 = _interopRequireDefault(_toArray2);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _queryFromResolveData = require("../queryFromResolveData");

var _queryFromResolveData2 = _interopRequireDefault(_queryFromResolveData);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

var _camelCase = require("lodash/camelCase");

var _camelCase2 = _interopRequireDefault(_camelCase);

var _pluralize = require("pluralize");

var _pluralize2 = _interopRequireDefault(_pluralize);

var _viaTemporaryTable = require("./viaTemporaryTable");

var _viaTemporaryTable2 = _interopRequireDefault(_viaTemporaryTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("graphile-build-pg");
var base64Decode = function base64Decode(str) {
  return new Buffer(String(str), "base64").toString("utf8");
};

exports.default = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(builder, _ref) {
    var inflection = _ref.pgInflection,
        pgDisableDefaultMutations = _ref.pgDisableDefaultMutations;
    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!pgDisableDefaultMutations) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return");

          case 2:
            builder.hook("GraphQLObjectType:fields", function (fields, build, _ref3) {
              var isRootMutation = _ref3.scope.isRootMutation,
                  fieldWithHooks = _ref3.fieldWithHooks;
              var newWithHooks = build.newWithHooks,
                  getNodeIdForTypeAndIdentifiers = build.getNodeIdForTypeAndIdentifiers,
                  nodeIdFieldName = build.nodeIdFieldName,
                  fieldDataGeneratorsByType = build.fieldDataGeneratorsByType,
                  extend = build.extend,
                  parseResolveInfo = build.parseResolveInfo,
                  getTypeByName = build.getTypeByName,
                  gql2pg = build.gql2pg,
                  pgGetGqlTypeByTypeId = build.pgGetGqlTypeByTypeId,
                  pgGetGqlInputTypeByTypeId = build.pgGetGqlInputTypeByTypeId,
                  introspectionResultsByKind = build.pgIntrospectionResultsByKind,
                  sql = build.pgSql,
                  getNodeType = build.getNodeType,
                  _build$graphql = build.graphql,
                  GraphQLNonNull = _build$graphql.GraphQLNonNull,
                  GraphQLInputObjectType = _build$graphql.GraphQLInputObjectType,
                  GraphQLString = _build$graphql.GraphQLString,
                  GraphQLObjectType = _build$graphql.GraphQLObjectType,
                  GraphQLID = _build$graphql.GraphQLID,
                  pgColumnFilter = build.pgColumnFilter;

              if (!isRootMutation) {
                return fields;
              }
              return extend(fields, ["update", "delete"].reduce(function (outerMemo, mode) {
                return introspectionResultsByKind.class.filter(function (table) {
                  return !!table.namespace;
                }).filter(function (table) {
                  return mode === "update" && table.isUpdatable || mode === "delete" && table.isDeletable;
                }).reduce(function (memo, table) {
                  var commonCodeRenameMe = function () {
                    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(pgClient, resolveInfo, getDataFromParsedResolveInfoFragment, PayloadType, input, condition, context) {
                      var parsedResolveInfoFragment, resolveData, sqlTypeIdentifier, sqlMutationQuery, sqlColumns, sqlValues, inputData, modifiedRowAlias, query, row, result;
                      return _regenerator2.default.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              parsedResolveInfoFragment = parseResolveInfo(resolveInfo);
                              resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, PayloadType);
                              sqlTypeIdentifier = sql.identifier(table.namespace.name, table.name);
                              sqlMutationQuery = void 0;

                              if (!(mode === "update")) {
                                _context.next = 14;
                                break;
                              }

                              sqlColumns = [];
                              sqlValues = [];
                              inputData = input[inflection.patchField(inflection.tableName(table.name, table.namespace.name))];

                              introspectionResultsByKind.attribute.filter(function (attr) {
                                return attr.classId === table.id;
                              }).filter(function (attr) {
                                return pgColumnFilter(attr, build, context);
                              }).forEach(function (attr) {
                                var fieldName = inflection.column(attr.name, table.name, table.namespace.name);
                                if (fieldName in inputData /* Because we care about null! */
                                ) {
                                    var val = inputData[fieldName];
                                    sqlColumns.push(sql.identifier(attr.name));
                                    sqlValues.push(gql2pg(val, attr.type));
                                  }
                              });

                              if (!(sqlColumns.length === 0)) {
                                _context.next = 11;
                                break;
                              }

                              return _context.abrupt("return", null);

                            case 11:
                              sqlMutationQuery = sql.query`
                      update ${sql.identifier(table.namespace.name, table.name)} set ${sql.join(sqlColumns.map(function (col, i) {
                                return sql.fragment`${col} = ${sqlValues[i]}`;
                              }), ", ")}
                      where ${condition}
                      returning *`;
                              _context.next = 15;
                              break;

                            case 14:
                              sqlMutationQuery = sql.query`
                      delete from ${sql.identifier(table.namespace.name, table.name)}
                      where ${condition}
                      returning *`;

                            case 15:
                              modifiedRowAlias = sql.identifier((0, _symbol2.default)());
                              query = (0, _queryFromResolveData2.default)(modifiedRowAlias, modifiedRowAlias, resolveData, {});
                              row = void 0;
                              _context.prev = 18;
                              _context.next = 21;
                              return pgClient.query("SAVEPOINT graphql_mutation");

                            case 21:
                              _context.next = 23;
                              return (0, _viaTemporaryTable2.default)(pgClient, sqlTypeIdentifier, sqlMutationQuery, modifiedRowAlias, query);

                            case 23:
                              result = _context.sent;

                              row = result.rows[0];
                              _context.next = 27;
                              return pgClient.query("RELEASE SAVEPOINT graphql_mutation");

                            case 27:
                              _context.next = 34;
                              break;

                            case 29:
                              _context.prev = 29;
                              _context.t0 = _context["catch"](18);
                              _context.next = 33;
                              return pgClient.query("ROLLBACK TO SAVEPOINT graphql_mutation");

                            case 33:
                              throw _context.t0;

                            case 34:
                              if (row) {
                                _context.next = 36;
                                break;
                              }

                              throw new Error(`No values were ${mode}d in collection '${(0, _pluralize2.default)(table.name)}' because no values were found.`);

                            case 36:
                              return _context.abrupt("return", {
                                clientMutationId: input.clientMutationId,
                                data: row
                              });

                            case 37:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this, [[18, 29]]);
                    }));

                    return function commonCodeRenameMe(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {
                      return _ref4.apply(this, arguments);
                    };
                  }();

                  var TableType = pgGetGqlTypeByTypeId(table.type.id);

                  if (TableType) {
                    var uniqueConstraints = introspectionResultsByKind.constraint.filter(function (con) {
                      return con.classId === table.id;
                    }).filter(function (con) {
                      return con.type === "u" || con.type === "p";
                    });
                    var attributes = introspectionResultsByKind.attribute.filter(function (attr) {
                      return attr.classId === table.id;
                    }).sort(function (a, b) {
                      return a.num - b.num;
                    });
                    var Table = pgGetGqlTypeByTypeId(table.type.id);
                    var tableTypeName = Table.name;
                    var TablePatch = getTypeByName(inflection.patchType(Table.name));
                    var PayloadType = newWithHooks(GraphQLObjectType, {
                      name: inflection[mode === "delete" ? "deletePayloadType" : "updatePayloadType"](table.name, table.namespace.name),
                      description: `The output of our ${mode} \`${tableTypeName}\` mutation.`,
                      fields: function fields(_ref5) {
                        var recurseDataGeneratorsForField = _ref5.recurseDataGeneratorsForField,
                            fieldWithHooks = _ref5.fieldWithHooks;

                        var tableName = inflection.tableName(table.name, table.namespace.name);
                        recurseDataGeneratorsForField(tableName);
                        // This should really be `-node-id` but for compatibility with PostGraphQL v3 we haven't made that change.
                        var deletedNodeIdFieldName = (0, _camelCase2.default)(`deleted-${_pluralize2.default.singular(table.name)}-id`);
                        return (0, _assign2.default)({
                          clientMutationId: {
                            description: "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.",
                            type: GraphQLString
                          },
                          [tableName]: {
                            description: `The \`${tableTypeName}\` that was ${mode}d by this mutation.`,
                            type: Table,
                            resolve(data) {
                              return data.data;
                            }
                          }
                        }, mode === "delete" ? {
                          [deletedNodeIdFieldName]: fieldWithHooks(deletedNodeIdFieldName, function (_ref6) {
                            var addDataGenerator = _ref6.addDataGenerator;

                            var fieldDataGeneratorsByTableType = fieldDataGeneratorsByType.get(TableType);

                            var gens = fieldDataGeneratorsByTableType && fieldDataGeneratorsByTableType[nodeIdFieldName];
                            if (gens) {
                              gens.forEach(function (gen) {
                                return addDataGenerator(gen);
                              });
                            }
                            return {
                              type: GraphQLID,
                              resolve(data) {
                                return data.data.__identifiers && getNodeIdForTypeAndIdentifiers.apply(undefined, [Table].concat((0, _toConsumableArray3.default)(data.data.__identifiers)));
                              }
                            };
                          }, {
                            isPgMutationPayloadDeletedNodeIdField: true
                          })
                        } : null);
                      }
                    }, {
                      isMutationPayload: true,
                      isPgUpdatePayloadType: mode === "update",
                      isPgDeletePayloadType: mode === "delete",
                      pgIntrospection: table
                    });

                    // NodeId
                    if (nodeIdFieldName) {
                      var primaryKeyConstraint = introspectionResultsByKind.constraint.filter(function (con) {
                        return con.classId === table.id;
                      }).filter(function (con) {
                        return con.type === "p";
                      })[0];
                      if (!primaryKeyConstraint) {
                        return memo;
                      }
                      var primaryKeys = primaryKeyConstraint && primaryKeyConstraint.keyAttributeNums.map(function (num) {
                        return attributes.filter(function (attr) {
                          return attr.num === num;
                        })[0];
                      });
                      var fieldName = inflection[mode === "update" ? "updateNode" : "deleteNode"](table.name, table.namespace.name);
                      var InputType = newWithHooks(GraphQLInputObjectType, {
                        description: `All input for the \`${fieldName}\` mutation.`,
                        name: inflection[mode === "update" ? "updateNodeInputType" : "deleteNodeInputType"](table.name, table.namespace.name),
                        fields: (0, _assign2.default)({
                          clientMutationId: {
                            description: "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.",
                            type: GraphQLString
                          },
                          [nodeIdFieldName]: {
                            description: `The globally unique \`ID\` which will identify a single \`${tableTypeName}\` to be ${mode}d.`,
                            type: new GraphQLNonNull(GraphQLID)
                          }
                        }, mode === "update" ? {
                          [inflection.patchField(inflection.tableName(table.name, table.namespace.name))]: {
                            description: `An object where the defined keys will be set on the \`${tableTypeName}\` being ${mode}d.`,
                            type: new GraphQLNonNull(TablePatch)
                          }
                        } : null)
                      }, {
                        isPgUpdateInputType: mode === "update",
                        isPgUpdateNodeInputType: mode === "update",
                        isPgDeleteInputType: mode === "delete",
                        isPgDeleteNodeInputType: mode === "delete",
                        pgInflection: table,
                        isMutationInput: true
                      });

                      memo[fieldName] = fieldWithHooks(fieldName, function (context) {
                        var getDataFromParsedResolveInfoFragment = context.getDataFromParsedResolveInfoFragment;

                        return {
                          description: mode === "update" ? `Updates a single \`${tableTypeName}\` using its globally unique id and a patch.` : `Deletes a single \`${tableTypeName}\` using its globally unique id.`,
                          type: PayloadType,
                          args: {
                            input: {
                              type: new GraphQLNonNull(InputType)
                            }
                          },
                          resolve(parent, _ref7, _ref8, resolveInfo) {
                            var _this = this;

                            return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                              var input = _ref7.input;
                              var pgClient = _ref8.pgClient;

                              var nodeId, _JSON$parse, _JSON$parse2, alias, identifiers, NodeTypeByAlias;

                              return _regenerator2.default.wrap(function _callee2$(_context2) {
                                while (1) {
                                  switch (_context2.prev = _context2.next) {
                                    case 0:
                                      nodeId = input[nodeIdFieldName];
                                      _context2.prev = 1;
                                      _JSON$parse = JSON.parse(base64Decode(nodeId)), _JSON$parse2 = (0, _toArray3.default)(_JSON$parse), alias = _JSON$parse2[0], identifiers = _JSON$parse2.slice(1);
                                      NodeTypeByAlias = getNodeType(alias);

                                      if (!(NodeTypeByAlias !== TableType)) {
                                        _context2.next = 6;
                                        break;
                                      }

                                      throw new Error("Mismatched type");

                                    case 6:
                                      if (!(identifiers.length !== primaryKeys.length)) {
                                        _context2.next = 8;
                                        break;
                                      }

                                      throw new Error("Invalid ID");

                                    case 8:
                                      return _context2.abrupt("return", commonCodeRenameMe(pgClient, resolveInfo, getDataFromParsedResolveInfoFragment, PayloadType, input, sql.fragment`(${sql.join(primaryKeys.map(function (key, idx) {
                                        return sql.fragment`${sql.identifier(key.name)} = ${gql2pg(identifiers[idx], key.type)}`;
                                      }), ") and (")})`, context));

                                    case 11:
                                      _context2.prev = 11;
                                      _context2.t0 = _context2["catch"](1);

                                      debug(_context2.t0);
                                      return _context2.abrupt("return", null);

                                    case 15:
                                    case "end":
                                      return _context2.stop();
                                  }
                                }
                              }, _callee2, _this, [[1, 11]]);
                            }))();
                          }
                        };
                      }, {
                        isPgNodeMutation: true,
                        pgFieldIntrospection: table,
                        [mode === "update" ? "isPgUpdateMutationField" : "isPgDeleteMutationField"]: true
                      });
                    }

                    // Unique
                    uniqueConstraints.forEach(function (constraint) {
                      var keys = constraint.keyAttributeNums.map(function (num) {
                        return attributes.filter(function (attr) {
                          return attr.num === num;
                        })[0];
                      });
                      if (!keys.every(function (_) {
                        return _;
                      })) {
                        throw new Error("Consistency error: could not find an attribute!");
                      }
                      var simpleKeys = keys.map(function (k) {
                        return {
                          column: k.name,
                          table: k.class.name,
                          schema: k.class.namespace.name
                        };
                      });
                      var fieldName = inflection[mode === "update" ? "updateByKeys" : "deleteByKeys"](simpleKeys, table.name, table.namespace.name);
                      var InputType = newWithHooks(GraphQLInputObjectType, {
                        description: `All input for the \`${fieldName}\` mutation.`,
                        name: inflection[mode === "update" ? "updateByKeysInputType" : "deleteByKeysInputType"](simpleKeys, table.name, table.namespace.name),
                        fields: (0, _assign2.default)({
                          clientMutationId: {
                            type: GraphQLString
                          }
                        }, mode === "update" ? {
                          [inflection.patchField(inflection.tableName(table.name, table.namespace.name))]: {
                            description: `An object where the defined keys will be set on the \`${tableTypeName}\` being ${mode}d.`,
                            type: new GraphQLNonNull(TablePatch)
                          }
                        } : null, keys.reduce(function (memo, key) {
                          memo[inflection.column(key.name, key.class.name, key.class.namespace.name)] = {
                            type: new GraphQLNonNull(pgGetGqlInputTypeByTypeId(key.typeId))
                          };
                          return memo;
                        }, {}))
                      }, {
                        isPgUpdateInputType: mode === "update",
                        isPgUpdateByKeysInputType: mode === "update",
                        isPgDeleteInputType: mode === "delete",
                        isPgDeleteByKeysInputType: mode === "delete",
                        pgInflection: table,
                        pgKeys: keys,
                        isMutationInput: true
                      });

                      memo[fieldName] = fieldWithHooks(fieldName, function (context) {
                        var getDataFromParsedResolveInfoFragment = context.getDataFromParsedResolveInfoFragment;

                        return {
                          description: mode === "update" ? `Updates a single \`${tableTypeName}\` using a unique key and a patch.` : `Deletes a single \`${tableTypeName}\` using a unique key.`,
                          type: PayloadType,
                          args: {
                            input: {
                              type: new GraphQLNonNull(InputType)
                            }
                          },
                          resolve(parent, _ref9, _ref10, resolveInfo) {
                            var _this2 = this;

                            return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                              var input = _ref9.input;
                              var pgClient = _ref10.pgClient;
                              return _regenerator2.default.wrap(function _callee3$(_context3) {
                                while (1) {
                                  switch (_context3.prev = _context3.next) {
                                    case 0:
                                      return _context3.abrupt("return", commonCodeRenameMe(pgClient, resolveInfo, getDataFromParsedResolveInfoFragment, PayloadType, input, sql.fragment`(${sql.join(keys.map(function (key) {
                                        return sql.fragment`${sql.identifier(key.name)} = ${gql2pg(input[inflection.column(key.name, key.class.name, key.class.namespace.name)], key.type)}`;
                                      }), ") and (")})`, context));

                                    case 1:
                                    case "end":
                                      return _context3.stop();
                                  }
                                }
                              }, _callee3, _this2);
                            }))();
                          }
                        };
                      }, {
                        isPgNodeMutation: false,
                        pgFieldIntrospection: table,
                        [mode === "update" ? "isPgUpdateMutationField" : "isPgDeleteMutationField"]: true
                      });
                    });
                  }
                  return memo;
                }, outerMemo);
              }, {}), `Adding default update/delete mutations to root Mutation type`);
            });

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  function PgMutationUpdateDeletePlugin(_x, _x2) {
    return _ref2.apply(this, arguments);
  }

  return PgMutationUpdateDeletePlugin;
}();
//# sourceMappingURL=PgMutationUpdateDeletePlugin.js.map