"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _isString = require("lodash/isString");

var _isString2 = _interopRequireDefault(_isString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function PgMutationPayloadEdgePlugin(builder, _ref) {
  var inflection = _ref.pgInflection;

  builder.hook("GraphQLObjectType:fields", function (fields, _ref2, _ref3) {
    var extend = _ref2.extend,
        getTypeByName = _ref2.getTypeByName,
        pgGetGqlTypeByTypeId = _ref2.pgGetGqlTypeByTypeId,
        sql = _ref2.pgSql,
        _ref2$graphql = _ref2.graphql,
        GraphQLList = _ref2$graphql.GraphQLList,
        GraphQLNonNull = _ref2$graphql.GraphQLNonNull,
        introspectionResultsByKind = _ref2.pgIntrospectionResultsByKind;
    var _ref3$scope = _ref3.scope,
        isMutationPayload = _ref3$scope.isMutationPayload,
        pgIntrospection = _ref3$scope.pgIntrospection,
        pgIntrospectionTable = _ref3$scope.pgIntrospectionTable,
        fieldWithHooks = _ref3.fieldWithHooks,
        recurseDataGeneratorsForField = _ref3.recurseDataGeneratorsForField,
        Self = _ref3.Self;

    var table = pgIntrospectionTable || pgIntrospection;
    if (!isMutationPayload || !table || table.kind !== "class" || !table.namespace || !table.isSelectable) {
      return fields;
    }
    var TableType = pgGetGqlTypeByTypeId(table.type.id);
    var tableTypeName = TableType.name;
    var TableOrderByType = getTypeByName(inflection.orderByType(tableTypeName));
    var TableEdgeType = getTypeByName(inflection.edge(tableTypeName));
    if (!TableEdgeType) {
      return fields;
    }

    var attributes = introspectionResultsByKind.attribute.filter(function (attr) {
      return attr.classId === table.id;
    });
    var primaryKeyConstraint = introspectionResultsByKind.constraint.filter(function (con) {
      return con.classId === table.id;
    }).filter(function (con) {
      return con.type === "p";
    })[0];
    var primaryKeys = primaryKeyConstraint && primaryKeyConstraint.keyAttributeNums.map(function (num) {
      return attributes.filter(function (attr) {
        return attr.num === num;
      })[0];
    });

    var fieldName = inflection.edgeField(table.name, table.namespace.name);
    recurseDataGeneratorsForField(fieldName);
    return extend(fields, {
      [fieldName]: fieldWithHooks(fieldName, function (_ref4) {
        var addArgDataGenerator = _ref4.addArgDataGenerator;

        addArgDataGenerator(function connectionOrderBy(_ref5) {
          var rawOrderBy = _ref5.orderBy;

          var orderBy = rawOrderBy ? Array.isArray(rawOrderBy) ? rawOrderBy : [rawOrderBy] : null;
          return {
            pgQuery: function pgQuery(queryBuilder) {
              if (orderBy != null) {
                var aliases = [];
                var expressions = [];
                var unique = false;
                orderBy.forEach(function (item) {
                  var alias = item.alias,
                      specs = item.specs,
                      itemIsUnique = item.unique;

                  unique = unique || itemIsUnique;
                  var orders = Array.isArray(specs[0]) ? specs : [specs];
                  orders.forEach(function (_ref6) {
                    var _ref7 = (0, _slicedToArray3.default)(_ref6, 2),
                        col = _ref7[0],
                        _ascending = _ref7[1];

                    if (!col) {
                      return;
                    }
                    var expr = (0, _isString2.default)(col) ? sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(col)}` : col;
                    expressions.push(expr);
                  });
                  if (alias == null) return;
                  aliases.push(alias);
                });
                if (!unique && primaryKeys) {
                  // Add PKs
                  primaryKeys.forEach(function (key) {
                    expressions.push(sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(key.name)}`);
                  });
                }
                if (aliases.length) {
                  queryBuilder.select(sql.fragment`json_build_array(${sql.join(aliases.map(function (a) {
                    return sql.fragment`${sql.literal(a)}::text`;
                  }), ", ")}, json_build_array(${sql.join(expressions, ", ")}))`, "__order_" + aliases.join("__"));
                }
              }
            }
          };
        });

        var defaultValueEnum = TableOrderByType.getValues().find(function (v) {
          return v.name === "PRIMARY_KEY_ASC";
        }) || TableOrderByType.getValues()[0];
        return {
          description: "An edge for the type. May be used by Relay 1.",
          type: TableEdgeType,
          args: {
            orderBy: {
              description: `The method to use when ordering \`${tableTypeName}\`.`,
              type: new GraphQLList(new GraphQLNonNull(TableOrderByType)),
              defaultValue: defaultValueEnum && defaultValueEnum.value
            }
          },
          resolve(data, _ref8) {
            var rawOrderBy = _ref8.orderBy;

            var orderBy = rawOrderBy ? Array.isArray(rawOrderBy) ? rawOrderBy : [rawOrderBy] : null;
            var order = orderBy && orderBy.some(function (item) {
              return item.alias;
            }) ? orderBy.filter(function (item) {
              return item.alias;
            }) : null;

            if (!order) {
              if (data.data.__identifiers) {
                return (0, _assign2.default)({}, data.data, {
                  __cursor: ["primary_key_asc", data.data.__identifiers]
                });
              } else {
                return data.data;
              }
            }
            return (0, _assign2.default)({}, data.data, {
              __cursor: data.data[`__order_${order.map(function (item) {
                return item.alias;
              }).join("__")}`]
            });
          }
        };
      }, {
        isPgMutationPayloadEdgeField: true,
        pgFieldIntrospection: table
      })
    }, `Adding edge field to mutation payload '${Self.name}'`);
  });
};
//# sourceMappingURL=PgMutationPayloadEdgePlugin.js.map