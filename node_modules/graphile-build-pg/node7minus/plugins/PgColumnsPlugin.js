"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _queryFromResolveData = require("../queryFromResolveData");

var _queryFromResolveData2 = _interopRequireDefault(_queryFromResolveData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nullableIf = function nullableIf(GraphQLNonNull, condition, Type) {
  return condition ? Type : new GraphQLNonNull(Type);
};

exports.default = function PgColumnsPlugin(builder, _ref) {
  var inflection = _ref.pgInflection;

  builder.hook("GraphQLObjectType:fields", function (fields, build, context) {
    var extend = build.extend,
        pgGetGqlTypeByTypeId = build.pgGetGqlTypeByTypeId,
        introspectionResultsByKind = build.pgIntrospectionResultsByKind,
        sql = build.pgSql,
        pg2gql = build.pg2gql,
        _build$graphql = build.graphql,
        GraphQLString = _build$graphql.GraphQLString,
        GraphQLNonNull = _build$graphql.GraphQLNonNull,
        getAliasFromResolveInfo = build.getAliasFromResolveInfo,
        pgTweakFragmentForType = build.pgTweakFragmentForType,
        pgColumnFilter = build.pgColumnFilter;
    var _context$scope = context.scope,
        isPgRowType = _context$scope.isPgRowType,
        isPgCompoundType = _context$scope.isPgCompoundType,
        table = _context$scope.pgIntrospection,
        fieldWithHooks = context.fieldWithHooks,
        Self = context.Self;

    if (!(isPgRowType || isPgCompoundType) || !table || table.kind !== "class") {
      return fields;
    }
    return extend(fields, introspectionResultsByKind.attribute.filter(function (attr) {
      return attr.classId === table.id;
    }).filter(function (attr) {
      return pgColumnFilter(attr, build, context);
    }).reduce(function (memo, attr) {
      /*
        attr =
          { kind: 'attribute',
            classId: '6546809',
            num: 21,
            name: 'upstreamName',
            description: null,
            typeId: '6484393',
            isNotNull: false,
            hasDefault: false }
        */
      var fieldName = inflection.column(attr.name, table.name, table.namespaceName);
      if (memo[fieldName]) {
        throw new Error(`Two columns produce the same GraphQL field name '${fieldName}' on class '${table.namespaceName}.${table.name}'; one of them is '${attr.name}'`);
      }
      memo[fieldName] = fieldWithHooks(fieldName, function (_ref2) {
        var getDataFromParsedResolveInfoFragment = _ref2.getDataFromParsedResolveInfoFragment,
            addDataGenerator = _ref2.addDataGenerator;

        var ReturnType = pgGetGqlTypeByTypeId(attr.typeId) || GraphQLString;
        addDataGenerator(function (parsedResolveInfoFragment) {
          var alias = parsedResolveInfoFragment.alias;

          return {
            pgQuery: function pgQuery(queryBuilder) {
              var getSelectValueForFieldAndType = function getSelectValueForFieldAndType(sqlFullName, type) {
                if (type.isPgArray) {
                  var ident = sql.identifier((0, _symbol2.default)());
                  return sql.fragment`
                          (
                            case
                            when ${sqlFullName} is null then null
                            when coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json
                            else
                              (
                                select json_agg(${getSelectValueForFieldAndType(ident, type.arrayItemType)})
                                from unnest(${sqlFullName}) as ${ident}
                              )
                            end
                          )
                        `;
                } else if (type.type === "c") {
                  var resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, ReturnType);
                  var jsonBuildObject = (0, _queryFromResolveData2.default)(sql.identifier((0, _symbol2.default)()), // Ignore!
                  sqlFullName, resolveData, { onlyJsonField: true, addNullCase: true });
                  return jsonBuildObject;
                } else {
                  return pgTweakFragmentForType(sqlFullName, type);
                }
              };
              queryBuilder.select(getSelectValueForFieldAndType(sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(attr.name)})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING
              attr.type), alias);
            }
          };
        });
        return {
          description: attr.description,
          type: nullableIf(GraphQLNonNull, !attr.isNotNull && !attr.type.domainIsNotNull, ReturnType),
          resolve: function resolve(data, _args, _context, resolveInfo) {
            var alias = getAliasFromResolveInfo(resolveInfo);
            return pg2gql(data[alias], attr.type);
          }
        };
      }, { pgFieldIntrospection: attr });
      return memo;
    }, {}), `Adding columns to '${Self.name}'`);
  });
  builder.hook("GraphQLInputObjectType:fields", function (fields, build, context) {
    var extend = build.extend,
        pgGetGqlInputTypeByTypeId = build.pgGetGqlInputTypeByTypeId,
        introspectionResultsByKind = build.pgIntrospectionResultsByKind,
        _build$graphql2 = build.graphql,
        GraphQLString = _build$graphql2.GraphQLString,
        GraphQLNonNull = _build$graphql2.GraphQLNonNull,
        pgColumnFilter = build.pgColumnFilter;
    var _context$scope2 = context.scope,
        isPgRowType = _context$scope2.isPgRowType,
        isPgCompoundType = _context$scope2.isPgCompoundType,
        isPgPatch = _context$scope2.isPgPatch,
        table = _context$scope2.pgIntrospection,
        pgAddSubfield = _context$scope2.pgAddSubfield,
        Self = context.Self;

    if (!(isPgRowType || isPgCompoundType) || !table || table.kind !== "class") {
      return fields;
    }
    return extend(fields, introspectionResultsByKind.attribute.filter(function (attr) {
      return attr.classId === table.id;
    }).filter(function (attr) {
      return pgColumnFilter(attr, build, context);
    }).reduce(function (memo, attr) {
      var fieldName = inflection.column(attr.name, table.name, table.namespaceName);
      if (memo[fieldName]) {
        throw new Error(`Two columns produce the same GraphQL field name '${fieldName}' on input class '${table.namespaceName}.${table.name}'; one of them is '${attr.name}'`);
      }
      memo[fieldName] = pgAddSubfield(fieldName, attr.name, attr.type, {
        description: attr.description,
        type: nullableIf(GraphQLNonNull, isPgPatch || !attr.isNotNull && !attr.type.domainIsNotNull || attr.hasDefault, pgGetGqlInputTypeByTypeId(attr.typeId) || GraphQLString)
      });
      return memo;
    }, {}), `Adding columns to input object '${Self.name}'`);
  });
};
//# sourceMappingURL=PgColumnsPlugin.js.map