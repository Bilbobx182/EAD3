"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function PgConnectionArgCondition(builder, _ref) {
  var inflection = _ref.pgInflection;

  builder.hook("init", function (_, build) {
    var newWithHooks = build.newWithHooks,
        introspectionResultsByKind = build.pgIntrospectionResultsByKind,
        pgGetGqlInputTypeByTypeId = build.pgGetGqlInputTypeByTypeId,
        _build$graphql = build.graphql,
        GraphQLInputObjectType = _build$graphql.GraphQLInputObjectType,
        GraphQLString = _build$graphql.GraphQLString,
        pgColumnFilter = build.pgColumnFilter;

    introspectionResultsByKind.class.filter(function (table) {
      return table.isSelectable;
    }).filter(function (table) {
      return !!table.namespace;
    }).forEach(function (table) {
      var tableTypeName = inflection.tableType(table.name, table.namespace.name);
      /* const TableConditionType = */
      newWithHooks(GraphQLInputObjectType, {
        description: `A condition to be used against \`${tableTypeName}\` object types. All fields are tested for equality and combined with a logical ‘and.’`,
        name: inflection.conditionType(inflection.tableType(table.name, table.namespace.name)),
        fields: function fields(context) {
          var fieldWithHooks = context.fieldWithHooks;

          return introspectionResultsByKind.attribute.filter(function (attr) {
            return attr.classId === table.id;
          }).filter(function (attr) {
            return pgColumnFilter(attr, build, context);
          }).reduce(function (memo, attr) {
            var fieldName = inflection.column(attr.name, table.name, table.namespace.name);
            memo[fieldName] = fieldWithHooks(fieldName, {
              description: `Checks for equality with the object’s \`${fieldName}\` field.`,
              type: pgGetGqlInputTypeByTypeId(attr.typeId) || GraphQLString
            }, {
              isPgConnectionConditionInputField: true
            });
            return memo;
          }, {});
        }
      }, {
        pgIntrospection: table,
        isPgCondition: true
      });
    });
    return _;
  });
  builder.hook("GraphQLObjectType:fields:field:args", function (args, build, context) {
    var sql = build.pgSql,
        gql2pg = build.gql2pg,
        extend = build.extend,
        getTypeByName = build.getTypeByName,
        pgGetGqlTypeByTypeId = build.pgGetGqlTypeByTypeId,
        introspectionResultsByKind = build.pgIntrospectionResultsByKind,
        pgColumnFilter = build.pgColumnFilter;
    var _context$scope = context.scope,
        isPgFieldConnection = _context$scope.isPgFieldConnection,
        table = _context$scope.pgFieldIntrospection,
        addArgDataGenerator = context.addArgDataGenerator,
        Self = context.Self,
        field = context.field;

    if (!isPgFieldConnection || !table || table.kind !== "class" || !table.namespace) {
      return args;
    }
    var TableType = pgGetGqlTypeByTypeId(table.type.id);
    var TableConditionType = getTypeByName(inflection.conditionType(TableType.name));

    addArgDataGenerator(function connectionCondition(_ref2) {
      var condition = _ref2.condition;

      return {
        pgQuery: function pgQuery(queryBuilder) {
          if (condition != null) {
            introspectionResultsByKind.attribute.filter(function (attr) {
              return attr.classId === table.id;
            }).filter(function (attr) {
              return pgColumnFilter(attr, build, context);
            }).forEach(function (attr) {
              var fieldName = inflection.column(attr.name, table.name, table.namespace.name);
              var val = condition[fieldName];
              if (val != null) {
                queryBuilder.where(sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(attr.name)} = ${gql2pg(val, attr.type)}`);
              } else if (val === null) {
                queryBuilder.where(sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(attr.name)} IS NULL`);
              }
            });
          }
        }
      };
    });

    return extend(args, {
      condition: {
        description: "A condition to be used in determining which values should be returned by the collection.",
        type: TableConditionType
      }
    }, `Adding condition to connection field '${field.name}' of '${Self.name}'`);
  });
};
//# sourceMappingURL=PgConnectionArgCondition.js.map