"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _freeze = require("babel-runtime/core-js/object/freeze");

var _freeze2 = _interopRequireDefault(_freeze);

var _graphql = require("graphql");

var _language = require("graphql/language");

var _pg = require("pg");

var _graphqlTypeJson = require("graphql-type-json");

var _graphqlTypeJson2 = _interopRequireDefault(_graphqlTypeJson);

var _postgresInterval = require("postgres-interval");

var _postgresInterval2 = _interopRequireDefault(_postgresInterval);

var _lruCache = require("lru-cache");

var _lruCache2 = _interopRequireDefault(_lruCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function indent(str) {
  return "  " + str.replace(/\n/g, "\n  ");
}


var stringType = function stringType(name, description) {
  return new _graphql.GraphQLScalarType({
    name,
    description,
    serialize: function serialize(value) {
      return String(value);
    },
    parseValue: function parseValue(value) {
      return String(value);
    },
    parseLiteral: function parseLiteral(ast) {
      if (ast.kind !== _language.Kind.STRING) {
        throw new Error("Can only parse string values");
      }
      return ast.value;
    }
  });
};

/*
const {
  GraphQLDate,
  GraphQLTime,
  GraphQLDateTime,
} = require("graphql-iso-date");
*/

var parseCache = (0, _lruCache2.default)(500);
function parseInterval(str) {
  var result = parseCache.get(str);
  if (!result) {
    result = (0, _postgresInterval2.default)(str);
    (0, _freeze2.default)(result);
    parseCache.set(str, result);
  }
  return result;
}

var pgRangeParser = {
  parse(str) {
    var parts = str.split(",");
    if (parts.length !== 2) {
      throw new Error("Invalid daterange");
    }

    return {
      start: parts[0].length > 1 ? {
        inclusive: parts[0][0] === "[",
        value: parts[0].slice(1)
      } : null,
      end: parts[1].length > 1 ? {
        inclusive: parts[1][parts[1].length - 1] === "]",
        value: parts[1].slice(0, -1)
      } : null
    };
  },

  serialize(_ref) {
    var start = _ref.start,
        end = _ref.end;

    var inclusivity = {
      true: "[]",
      false: "()"
    };

    return [start ? inclusivity[start.inclusive][0] + start.value : "[", end ? end.value + inclusivity[end.inclusive][1] : "]"].join(",");
  }
};

exports.default = function PgTypesPlugin(builder, _ref2) {
  var _ref2$pgExtendedTypes = _ref2.pgExtendedTypes,
      pgExtendedTypes = _ref2$pgExtendedTypes === undefined ? true : _ref2$pgExtendedTypes,
      inflection = _ref2.pgInflection;

  // XXX: most of this should be in an "init" hook, not a "build" hook
  builder.hook("build", function (build) {
    var introspectionResultsByKind = build.pgIntrospectionResultsByKind,
        getTypeByName = build.getTypeByName,
        addType = build.addType,
        sql = build.pgSql;


    var gqlTypeByTypeIdGenerator = {};
    var gqlInputTypeByTypeIdGenerator = {};
    var gqlTypeByTypeId = (0, _assign2.default)({}, build.pgGqlTypeByTypeId);
    var gqlInputTypeByTypeId = (0, _assign2.default)({}, build.pgGqlInputTypeByTypeId);
    var pg2GqlMapper = {};
    var pg2gql = function pg2gql(val, type) {
      if (val == null) {
        return val;
      }
      if (pg2GqlMapper[type.id]) {
        return pg2GqlMapper[type.id].map(val);
      } else if (type.domainBaseType) {
        return pg2gql(val, type.domainBaseType);
      } else if (type.isPgArray) {
        if (!Array.isArray(val)) {
          throw new Error(`Expected array when converting PostgreSQL data into GraphQL; failing type: '${type.namespaceName}.${type.name}'`);
        }
        return val.map(function (v) {
          return pg2gql(v, type.arrayItemType);
        });
      } else {
        return val;
      }
    };
    var gql2pg = function gql2pg(val, type) {
      if (val == null) {
        return sql.null;
      }
      if (pg2GqlMapper[type.id]) {
        return pg2GqlMapper[type.id].unmap(val);
      } else if (type.domainBaseType) {
        return gql2pg(val, type.domainBaseType);
      } else if (type.isPgArray) {
        if (!Array.isArray(val)) {
          throw new Error(`Expected array when converting GraphQL data into PostgreSQL data; failing type: '${type.namespaceName}.${type.name}' (type: ${type === null ? "null" : typeof type})`);
        }
        return sql.fragment`array[${sql.join(val.map(function (v) {
          return gql2pg(v, type.arrayItemType);
        }), ", ")}]::${sql.identifier(type.namespaceName)}.${sql.identifier(type.name)}`;
      } else {
        return sql.value(val);
      }
    };
    /*
      type =
        { kind: 'type',
          id: '1021',
          name: '_float4',
          description: null,
          namespaceId: '11',
          namespaceName: 'pg_catalog',
          type: 'b',
          category: 'A',
          domainIsNotNull: false,
          arrayItemTypeId: '700',
          classId: null,
          domainBaseTypeId: null,
          enumVariants: null,
          rangeSubTypeId: null }
      */

    var makeIntervalFields = function makeIntervalFields() {
      return {
        seconds: {
          description: "A quantity of seconds. This is the only non-integer field, as all the other fields will dump their overflow into a smaller unit of time. Intervals donâ€™t have a smaller unit than seconds.",
          type: _graphql.GraphQLFloat
        },
        minutes: {
          description: "A quantity of minutes.",
          type: _graphql.GraphQLInt
        },
        hours: {
          description: "A quantity of hours.",
          type: _graphql.GraphQLInt
        },
        days: {
          description: "A quantity of days.",
          type: _graphql.GraphQLInt
        },
        months: {
          description: "A quantity of months.",
          type: _graphql.GraphQLInt
        },
        years: {
          description: "A quantity of years.",
          type: _graphql.GraphQLInt
        }
      };
    };
    var GQLInterval = new _graphql.GraphQLObjectType({
      name: "Interval",
      description: "An interval of time that has passed where the smallest distinct unit is a second.",
      fields: makeIntervalFields()
    });
    addType(GQLInterval);

    var GQLIntervalInput = new _graphql.GraphQLInputObjectType({
      name: "IntervalInput",
      description: "An interval of time that has passed where the smallest distinct unit is a second.",
      fields: makeIntervalFields()
    });
    addType(GQLIntervalInput);

    var pgTypeById = introspectionResultsByKind.type.reduce(function (memo, type) {
      memo[type.id] = type;
      return memo;
    }, {});

    var BigFloat = stringType("BigFloat", "A floating point number that requires more precision than IEEE 754 binary 64");
    var BitString = stringType("BitString", "A string representing a series of binary bits");
    addType(BigFloat);
    addType(BitString);

    var rawTypes = [1186, // interval
    1082, // date
    1114, // timestamp
    1184, // timestamptz
    1083, // time
    1266];

    var tweakToJson = function tweakToJson(fragment) {
      return fragment;
    }; // Since everything is to_json'd now, just pass through
    var tweakToText = function tweakToText(fragment) {
      return sql.fragment`(${fragment})::text`;
    };
    var pgTweaksByTypeId = (0, _assign2.default)(
    // ::text rawTypes
    rawTypes.reduce(function (memo, typeId) {
      memo[typeId] = tweakToText;
      return memo;
    }, {}), {
      // cast numbers above our ken to strings to avoid loss of precision
      "20": tweakToText,
      "1700": tweakToText,
      // to_json all dates to make them ISO (overrides rawTypes above)
      "1082": tweakToJson,
      "1114": tweakToJson,
      "1184": tweakToJson,
      "1083": tweakToJson,
      "1266": tweakToJson
    });

    var categoryLookup = {
      B: function B() {
        return _graphql.GraphQLBoolean;
      },

      // Numbers may be too large for GraphQL/JS to handle, so stringify by
      // default.
      N: function N(type) {
        pgTweaksByTypeId[type.id] = tweakToText;
        return BigFloat;
      },

      A: function A(type) {
        return new _graphql.GraphQLList(enforceGqlTypeByPgType(pgTypeById[type.arrayItemTypeId]));
      }
    };

    var pgTweakFragmentForType = function pgTweakFragmentForType(fragment, type) {
      var tweaker = pgTweaksByTypeId[type.id];
      if (tweaker) {
        return tweaker(fragment);
      } else if (type.domainBaseType) {
        return pgTweakFragmentForType(fragment, type.domainBaseType);
      } else if (type.isPgArray) {
        var error = new Error("Internal graphile-build-pg error: should not attempt to tweak an array, please process array before tweaking (type: `${type.namespaceName}.${type.name}`)");
        if (process.env.NODE_ENV === "test") {
          throw error;
        }
        // eslint-disable-next-line no-console
        console.error(error);
        return fragment;
      } else {
        return fragment;
      }
    };
    /*
        Determined by running:
           select oid, typname, typarray, typcategory, typtype from pg_catalog.pg_type where typtype = 'b' order by oid;
         We only need to add oidLookups for types that don't have the correct fallback
      */
    var SimpleDate = stringType("Date", "The day, does not include a time.");
    var SimpleDatetime = stringType("Datetime", "A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.");
    var SimpleTime = stringType("Time", "The exact time of day, does not include the date. May or may not have a timezone offset.");
    var SimpleJSON = stringType("JSON", "A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).");
    var SimpleUUID = stringType("UUID", "A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).");

    // pgExtendedTypes might change what types we use for things
    var JSONType = pgExtendedTypes ? _graphqlTypeJson2.default : SimpleJSON;
    var UUIDType = SimpleUUID; // GraphQLUUID
    var DateType = SimpleDate; // GraphQLDate
    var DateTimeType = SimpleDatetime; // GraphQLDateTime
    var TimeType = SimpleTime; // GraphQLTime

    // 'point' in PostgreSQL is a 16-byte type that's comprised of two 8-byte floats.
    var Point = new _graphql.GraphQLObjectType({
      name: "Point",
      fields: {
        x: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLFloat)
        },
        y: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLFloat)
        }
      }
    });
    var PointInput = new _graphql.GraphQLInputObjectType({
      name: "PointInput",
      fields: {
        x: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLFloat)
        },
        y: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLFloat)
        }
      }
    });

    // Other plugins might want to use JSON
    addType(JSONType);
    addType(UUIDType);
    addType(DateType);
    addType(DateTimeType);
    addType(TimeType);

    var oidLookup = {
      "20": stringType("BigInt", "A signed eight-byte integer. The upper big integer values are greater then the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers."), // bitint - even though this is int8, it's too big for JS int, so cast to string.
      "21": _graphql.GraphQLInt, // int2
      "23": _graphql.GraphQLInt, // int4
      "700": _graphql.GraphQLFloat, // float4
      "701": _graphql.GraphQLFloat, // float8
      "1700": BigFloat, // numeric
      "790": _graphql.GraphQLFloat, // money

      "1186": GQLInterval, // interval
      "1082": DateType, // date
      "1114": DateTimeType, // timestamp
      "1184": DateTimeType, // timestamptz
      "1083": TimeType, // time
      "1266": TimeType, // timetz

      "114": JSONType, // json
      "3802": JSONType, // jsonb
      "2950": UUIDType, // uuid

      "1560": BitString, // bit
      "1562": BitString, // varbit

      "18": _graphql.GraphQLString, // char
      "25": _graphql.GraphQLString, // text
      "1043": _graphql.GraphQLString, // varchar

      "600": Point // point
    };
    var oidInputLookup = {
      "1186": GQLIntervalInput, // interval
      "600": PointInput // point
    };
    var identity = function identity(_) {
      return _;
    };
    var jsonStringify = function jsonStringify(o) {
      return (0, _stringify2.default)(o);
    };
    if (pgExtendedTypes) {
      pg2GqlMapper[114] = {
        map: identity,
        unmap: function unmap(o) {
          return sql.value(jsonStringify(o));
        }
      };
    } else {
      pg2GqlMapper[114] = {
        map: jsonStringify,
        unmap: function unmap(str) {
          return sql.value(str);
        }
      };
    }
    pg2GqlMapper[3802] = pg2GqlMapper[114]; // jsonb

    // interval
    pg2GqlMapper[1186] = {
      map: function map(str) {
        return parseInterval(str);
      },
      unmap: function unmap(o) {
        var keys = ["seconds", "minutes", "hours", "days", "months", "years"];
        var parts = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(keys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            if (o[key]) {
              parts.push(`${o[key]} ${key}`);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return sql.value(parts.join(" ") || "0 seconds");
      }
    };

    var parseMoney = function parseMoney(str) {
      var numerical = str.replace(/[^0-9.,]/g, "");
      var lastCommaIndex = numerical.lastIndexOf(",");
      if (lastCommaIndex >= 0 && lastCommaIndex === numerical.length - 3) {
        // Assume string is of the form '123.456,78'
        return parseFloat(numerical.replace(/\./g, "").replace(",", "."));
      } else {
        // Assume string is of the form '123,456.78'
        return parseFloat(numerical.replace(/,/g, ""));
      }
    };
    pg2GqlMapper[790] = {
      map: parseMoney,
      unmap: function unmap(val) {
        return sql.fragment`(${sql.value(val)})::money`;
      }
    };

    // point
    pg2GqlMapper[600] = {
      map: function map(f) {
        if (f[0] === "(" && f[f.length - 1] === ")") {
          var _f$substr$split$map = f.substr(1, f.length - 2).split(",").map(function (f) {
            return parseFloat(f);
          }),
              _f$substr$split$map2 = (0, _slicedToArray3.default)(_f$substr$split$map, 2),
              x = _f$substr$split$map2[0],
              y = _f$substr$split$map2[1];

          return { x, y };
        }
      },
      unmap: function unmap(o) {
        return sql.fragment`point(${sql.value(o.x)}, ${sql.value(o.y)})`;
      }
    };

    // TODO: add more support for geometric types

    var depth = 0;
    var enforceGqlTypeByPgType = function enforceGqlTypeByPgType(type) {
      depth++;
      if (depth > 50) {
        throw new Error("Type enforcement went too deep - infinite loop?");
      }
      try {
        return reallyEnforceGqlTypeByPgType(type);
      } catch (e) {
        var error = new Error(`Error occurred when processing type '${type.namespaceName}.${type.name}' (type=${type.type}):\n${indent(e.message)}`);
        // $FlowFixMe
        error.originalError = e;
        throw error;
      } finally {
        depth--;
      }
    };
    var reallyEnforceGqlTypeByPgType = function reallyEnforceGqlTypeByPgType(type) {
      if (!type.id) {
        throw new Error(`Invalid argument to enforceGqlTypeByPgType - expected a full type, received '${type}'`);
      }
      // Explicit overrides
      if (!gqlTypeByTypeId[type.id]) {
        var gqlType = oidLookup[type.id];
        if (gqlType) {
          gqlTypeByTypeId[type.id] = gqlType;
        }
      }
      if (!gqlInputTypeByTypeId[type.id]) {
        var gqlInputType = oidInputLookup[type.id];
        if (gqlInputType) {
          gqlInputTypeByTypeId[type.id] = gqlInputType;
        }
      }
      // Enums
      if (!gqlTypeByTypeId[type.id] && type.type === "e") {
        gqlTypeByTypeId[type.id] = new _graphql.GraphQLEnumType({
          name: inflection.enumType(type.name),
          description: type.description,
          values: type.enumVariants.reduce(function (memo, value) {
            memo[inflection.enumName(value)] = {
              value: value
            };
            return memo;
          }, {})
        });
      }
      // Ranges
      if (!gqlTypeByTypeId[type.id] && type.type === "r") {
        var subtype = introspectionResultsByKind.typeById[type.rangeSubTypeId];
        var gqlRangeSubType = enforceGqlTypeByPgType(subtype);
        if (!gqlRangeSubType) {
          throw new Error("Range of unsupported");
        }
        var Range = getTypeByName(inflection.rangeType(gqlRangeSubType.name));
        var RangeInput = void 0;
        if (!Range) {
          var RangeBound = new _graphql.GraphQLObjectType({
            name: inflection.rangeBoundType(gqlRangeSubType.name),
            description: "The value at one end of a range. A range can either include this value, or not.",
            fields: {
              value: {
                description: "The value at one end of our range.",
                type: new _graphql.GraphQLNonNull(gqlRangeSubType)
              },
              inclusive: {
                description: "Whether or not the value of this bound is included in the range.",
                type: new _graphql.GraphQLNonNull(_graphql.GraphQLBoolean)
              }
            }
          });
          var RangeBoundInput = new _graphql.GraphQLInputObjectType({
            name: inflection.inputType(RangeBound.name),
            description: "The value at one end of a range. A range can either include this value, or not.",
            fields: {
              value: {
                description: "The value at one end of our range.",
                type: new _graphql.GraphQLNonNull(gqlRangeSubType)
              },
              inclusive: {
                description: "Whether or not the value of this bound is included in the range.",
                type: new _graphql.GraphQLNonNull(_graphql.GraphQLBoolean)
              }
            }
          });
          Range = new _graphql.GraphQLObjectType({
            name: inflection.rangeType(gqlRangeSubType.name),
            description: `A range of \`${gqlRangeSubType.name}\`.`,
            fields: {
              start: {
                description: "The starting bound of our range.",
                type: RangeBound
              },
              end: {
                description: "The ending bound of our range.",
                type: RangeBound
              }
            }
          });
          RangeInput = new _graphql.GraphQLInputObjectType({
            name: inflection.inputType(Range.name),
            description: `A range of \`${gqlRangeSubType.name}\`.`,
            fields: {
              start: {
                description: "The starting bound of our range.",
                type: RangeBoundInput
              },
              end: {
                description: "The ending bound of our range.",
                type: RangeBoundInput
              }
            }
          });
          addType(Range);
          addType(RangeInput);
        } else {
          RangeInput = getTypeByName(inflection.inputType(Range.name));
        }
        gqlTypeByTypeId[type.id] = Range;
        gqlInputTypeByTypeId[type.id] = RangeInput;
        pg2GqlMapper[type.id] = {
          map: function map(pgRange) {
            var parsed = pgRangeParser.parse(pgRange);
            // Since the value we will get from `parsed.(start|end).value` is a
            // string but our code will expect it to be the value after `pg`
            // parsed it, we pass through to `pg-types` for parsing.
            var pgParse = rawTypes.indexOf(parseInt(subtype.id, 10)) >= 0 ? identity : _pg.types.getTypeParser(subtype.id);
            var start = parsed.start,
                end = parsed.end;

            return {
              start: start ? {
                value: pg2gql(pgParse(start.value), subtype),
                inclusive: start.inclusive
              } : null,
              end: end ? {
                value: pg2gql(pgParse(end.value), subtype),
                inclusive: end.inclusive
              } : null
            };
          },
          unmap: function unmap(_ref3) {
            var start = _ref3.start,
                end = _ref3.end;

            // Ref: https://www.postgresql.org/docs/9.6/static/rangetypes.html#RANGETYPES-CONSTRUCT
            var lower = start && gql2pg(start.value, subtype) || sql.null;
            var upper = end && gql2pg(end.value, subtype) || sql.null;
            var lowerInclusive = start && !start.inclusive ? "(" : "[";
            var upperInclusive = end && !end.inclusive ? ")" : "]";
            return sql.fragment`${sql.identifier(type.namespaceName, type.name)}(${lower}, ${upper}, ${sql.literal(lowerInclusive + upperInclusive)})`;
          }
        };
      }

      // Domains
      if (!gqlTypeByTypeId[type.id] && type.type === "d" && type.domainBaseTypeId) {
        var baseType = enforceGqlTypeByPgType(type.domainBaseType);
        var baseInputType = gqlInputTypeByTypeId[type.domainBaseTypeId];
        // Hack stolen from: https://github.com/postgraphql/postgraphql/blob/ade728ed8f8e3ecdc5fdad7d770c67aa573578eb/src/graphql/schema/type/aliasGqlType.ts#L16
        gqlTypeByTypeId[type.id] = (0, _assign2.default)((0, _create2.default)(baseType), {
          name: inflection.domainType(type.name),
          description: type.description
        });
        if (baseInputType && baseInputType !== baseType) {
          gqlInputTypeByTypeId[type.id] = (0, _assign2.default)((0, _create2.default)(baseInputType), {
            name: inflection.inputType(gqlTypeByTypeId[type.id]),
            description: type.description
          });
        }
      }

      // Fall back to categories
      if (!gqlTypeByTypeId[type.id]) {
        var gen = categoryLookup[type.category];
        if (gen) {
          gqlTypeByTypeId[type.id] = gen(type);
        }
      }

      // Nothing else worked; pass through as string!
      if (!gqlTypeByTypeId[type.id]) {
        // XXX: consider using stringType(upperFirst(camelCase(`fallback_${type.name}`)), type.description)?
        gqlTypeByTypeId[type.id] = _graphql.GraphQLString;
      }
      // Now for input types, fall back to output types if possible
      if (!gqlInputTypeByTypeId[type.id]) {
        if ((0, _graphql.isInputType)(gqlTypeByTypeId[type.id])) {
          gqlInputTypeByTypeId[type.id] = gqlTypeByTypeId[type.id];
        }
      }
      addType((0, _graphql.getNamedType)(gqlTypeByTypeId[type.id]));
      return gqlTypeByTypeId[type.id];
    };

    function getGqlTypeByTypeId(typeId) {
      if (!gqlInputTypeByTypeIdGenerator[typeId]) {
        var type = introspectionResultsByKind.type.find(function (t) {
          return t.id === typeId;
        });
        return enforceGqlTypeByPgType(type);
      }
      if (!gqlTypeByTypeId[typeId]) {
        var _type = introspectionResultsByKind.type.find(function (t) {
          return t.id === typeId;
        });
        if (!_type) {
          throw new Error(`Type '${typeId}' not present in introspection results`);
        }
        var gen = gqlTypeByTypeIdGenerator[_type.id];
        if (gen) {
          var set = function set(Type) {
            gqlTypeByTypeId[_type.id] = Type;
          };
          var result = gen(set);
          if (result) {
            if (gqlTypeByTypeId[_type.id] && gqlTypeByTypeId[_type.id] !== result) {
              throw new Error(`Callback and return types differ when defining type for '${_type.id}'`);
            }
            gqlTypeByTypeId[_type.id] = result;
          }
        }
      }
      return gqlTypeByTypeId[typeId];
    }
    function getGqlInputTypeByTypeId(typeId) {
      if (!gqlInputTypeByTypeIdGenerator[typeId]) {
        var type = introspectionResultsByKind.type.find(function (t) {
          return t.id === typeId;
        });
        enforceGqlTypeByPgType(type);
        return gqlInputTypeByTypeId[typeId];
      }
      if (!gqlInputTypeByTypeId[typeId]) {
        var _type2 = introspectionResultsByKind.type.find(function (t) {
          return t.id === typeId;
        });
        getGqlTypeByTypeId(typeId);
        if (!_type2) {
          throw new Error(`Type '${typeId}' not present in introspection results`);
        }
        var gen = gqlInputTypeByTypeIdGenerator[_type2.id];
        if (gen) {
          var set = function set(Type) {
            gqlInputTypeByTypeId[_type2.id] = Type;
          };
          var result = gen(set);
          if (result) {
            if (gqlInputTypeByTypeId[_type2.id] && gqlInputTypeByTypeId[_type2.id] !== result) {
              throw new Error(`Callback and return types differ when defining type for '${_type2.id}'`);
            }
            gqlInputTypeByTypeId[_type2.id] = result;
          }
        }
      }
      return gqlInputTypeByTypeId[typeId];
    }

    function registerGqlTypeByTypeId(typeId, gen) {
      var yieldToExisting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (gqlTypeByTypeIdGenerator[typeId]) {
        if (yieldToExisting) {
          return;
        }
        throw new Error(`There's already a type generator registered for '${typeId}'`);
      }
      gqlTypeByTypeIdGenerator[typeId] = gen;
    }
    function registerGqlInputTypeByTypeId(typeId, gen) {
      var yieldToExisting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (gqlInputTypeByTypeIdGenerator[typeId]) {
        if (yieldToExisting) {
          return;
        }
        throw new Error(`There's already an input type generator registered for '${typeId}'`);
      }
      gqlInputTypeByTypeIdGenerator[typeId] = gen;
    }

    return build.extend(build, {
      pgRegisterGqlTypeByTypeId: registerGqlTypeByTypeId,
      pgRegisterGqlInputTypeByTypeId: registerGqlInputTypeByTypeId,
      pgGetGqlTypeByTypeId: getGqlTypeByTypeId,
      pgGetGqlInputTypeByTypeId: getGqlInputTypeByTypeId,
      pg2GqlMapper,
      pg2gql,
      gql2pg,
      pgTweakFragmentForType,
      pgTweaksByTypeId
    });
  });
};
//# sourceMappingURL=PgTypesPlugin.js.map