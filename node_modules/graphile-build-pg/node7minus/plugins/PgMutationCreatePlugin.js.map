{"version":3,"sources":["../../src/plugins/PgMutationCreatePlugin.js"],"names":["debug","PgMutationCreatePlugin","builder","inflection","pgInflection","pgDisableDefaultMutations","hook","fields","build","isRootMutation","scope","fieldWithHooks","extend","newWithHooks","parseResolveInfo","pgIntrospectionResultsByKind","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","sql","pgSql","gql2pg","graphql","GraphQLObjectType","GraphQLInputObjectType","GraphQLNonNull","GraphQLString","pgColumnFilter","class","filter","table","namespace","isSelectable","isInsertable","reduce","memo","Table","type","id","name","TableInput","tableTypeName","tableType","InputType","createInputType","description","clientMutationId","tableName","isPgCreateInputType","PayloadType","createPayloadType","recurseDataGeneratorsForField","resolve","data","isMutationPayload","isPgCreatePayloadType","pgIntrospection","fieldName","createField","getDataFromParsedResolveInfoFragment","context","args","input","resolveInfo","pgClient","parsedResolveInfoFragment","resolveData","insertedRowAlias","identifier","query","sqlColumns","sqlValues","inputData","attribute","attr","classId","forEach","column","val","Object","prototype","hasOwnProperty","call","push","mutationQuery","length","fragment","join","row","result","rows","pgFieldIntrospection","isPgCreateMutationField"],"mappings":";;;;;;;;;;;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,QAAQ,qBAAa,mBAAb,CAAd;;kBAEgB,SAASC,sBAAT,CACdC,OADc,QAGd;AAAA,MADgBC,UAChB,QADEC,YACF;AAAA,MAD4BC,yBAC5B,QAD4BA,yBAC5B;;AACA,MAAIA,yBAAJ,EAA+B;AAC7B;AACD;AACDH,UAAQI,IAAR,CACE,0BADF,EAEE,UAACC,MAAD,EAASC,KAAT,SAAkE;AAAA,QAAvCC,cAAuC,SAAhDC,KAAgD,CAAvCD,cAAuC;AAAA,QAArBE,cAAqB,SAArBA,cAAqB;AAAA,QAE9DC,MAF8D,GAiB5DJ,KAjB4D,CAE9DI,MAF8D;AAAA,QAG9DC,YAH8D,GAiB5DL,KAjB4D,CAG9DK,YAH8D;AAAA,QAI9DC,gBAJ8D,GAiB5DN,KAjB4D,CAI9DM,gBAJ8D;AAAA,QAK9DC,4BAL8D,GAiB5DP,KAjB4D,CAK9DO,4BAL8D;AAAA,QAM9DC,oBAN8D,GAiB5DR,KAjB4D,CAM9DQ,oBAN8D;AAAA,QAO9DC,yBAP8D,GAiB5DT,KAjB4D,CAO9DS,yBAP8D;AAAA,QAQvDC,GARuD,GAiB5DV,KAjB4D,CAQ9DW,KAR8D;AAAA,QAS9DC,MAT8D,GAiB5DZ,KAjB4D,CAS9DY,MAT8D;AAAA,yBAiB5DZ,KAjB4D,CAU9Da,OAV8D;AAAA,QAW5DC,iBAX4D,kBAW5DA,iBAX4D;AAAA,QAY5DC,sBAZ4D,kBAY5DA,sBAZ4D;AAAA,QAa5DC,cAb4D,kBAa5DA,cAb4D;AAAA,QAc5DC,aAd4D,kBAc5DA,aAd4D;AAAA,QAgB9DC,cAhB8D,GAiB5DlB,KAjB4D,CAgB9DkB,cAhB8D;;AAkBhE,QAAI,CAACjB,cAAL,EAAqB;AACnB,aAAOF,MAAP;AACD;;AAED,WAAOK,OACLL,MADK,EAELQ,6BAA6BY,KAA7B,CACGC,MADH,CACU;AAAA,aAAS,CAAC,CAACC,MAAMC,SAAjB;AAAA,KADV,EAEGF,MAFH,CAEU;AAAA,aAASC,MAAME,YAAf;AAAA,KAFV,EAGGH,MAHH,CAGU;AAAA,aAASC,MAAMG,YAAf;AAAA,KAHV,EAIGC,MAJH,CAIU,UAACC,IAAD,EAAOL,KAAP,EAAiB;AACvB,UAAMM,QAAQnB,qBAAqBa,MAAMO,IAAN,CAAWC,EAAhC,CAAd;AACA,UAAI,CAACF,KAAL,EAAY;AACVnC,cACG,sCAAqC6B,MAAMC,SAAN,CAAgBQ,IAAK,IACzDT,MAAMS,IACP,sDAHH;AAKA,eAAOJ,IAAP;AACD;AACD,UAAMK,aAAatB,0BAA0BY,MAAMO,IAAN,CAAWC,EAArC,CAAnB;AACA,UAAI,CAACE,UAAL,EAAiB;AACfvC,cACG,sCAAqC6B,MAAMC,SAAN,CAAgBQ,IAAK,IACzDT,MAAMS,IACP,sDAHH;AAKA,eAAOJ,IAAP;AACD;AACD,UAAMM,gBAAgBrC,WAAWsC,SAAX,CACpBZ,MAAMS,IADc,EAEpBT,MAAMC,SAAN,CAAgBQ,IAFI,CAAtB;AAIA,UAAMI,YAAY7B,aAChBU,sBADgB,EAEhB;AACEe,cAAMnC,WAAWwC,eAAX,CACJd,MAAMS,IADF,EAEJT,MAAMC,SAAN,CAAgBQ,IAFZ,CADR;AAKEM,qBAAc,8BAA6BJ,aAAc,cAL3D;AAMEjC,gBAAQ;AACNsC,4BAAkB;AAChBD,yBACE,6IAFc;AAGhBR,kBAAMX;AAHU,WADZ;AAMN,WAACtB,WAAW2C,SAAX,CAAqBjB,MAAMS,IAA3B,EAAiCT,MAAMC,SAAN,CAAgBQ,IAAjD,CAAD,GAA0D;AACxDM,yBAAc,SAAQJ,aAAc,oCADoB;AAExDJ,kBAAM,IAAIZ,cAAJ,CAAmBe,UAAnB;AAFkD;AANpD;AANV,OAFgB,EAoBhB;AACEQ,6BAAqB,IADvB;AAEE3C,sBAAcyB;AAFhB,OApBgB,CAAlB;AAyBA,UAAMmB,cAAcnC,aAClBS,iBADkB,EAElB;AACEgB,cAAMnC,WAAW8C,iBAAX,CACJpB,MAAMS,IADF,EAEJT,MAAMC,SAAN,CAAgBQ,IAFZ,CADR;AAKEM,qBAAc,8BAA6BJ,aAAc,cAL3D;AAMEjC,gBAAQ,uBAAuC;AAAA,cAApC2C,6BAAoC,SAApCA,6BAAoC;;AAC7C,cAAMJ,YAAY3C,WAAW2C,SAAX,CAChBjB,MAAMS,IADU,EAEhBT,MAAMC,SAAN,CAAgBQ,IAFA,CAAlB;AAIAY,wCAA8BJ,SAA9B;AACA,iBAAO;AACLD,8BAAkB;AAChBD,2BACE,8IAFc;AAGhBR,oBAAMX;AAHU,aADb;AAML,aAACqB,SAAD,GAAa;AACXF,2BAAc,SAAQJ,aAAc,uCADzB;AAEXJ,oBAAMD,KAFK;AAGXgB,sBAAQC,IAAR,EAAc;AACZ,uBAAOA,KAAKA,IAAZ;AACD;AALU;AANR,WAAP;AAcD;AA1BH,OAFkB,EA8BlB;AACEC,2BAAmB,IADrB;AAEEC,+BAAuB,IAFzB;AAGEC,yBAAiB1B;AAHnB,OA9BkB,CAApB;AAoCA,UAAM2B,YAAYrD,WAAWsD,WAAX,CAChB5B,MAAMS,IADU,EAEhBT,MAAMC,SAAN,CAAgBQ,IAFA,CAAlB;AAIAJ,WAAKsB,SAAL,IAAkB7C,eAChB6C,SADgB,EAEhB,mBAAW;AAAA,YACDE,oCADC,GACwCC,OADxC,CACDD,oCADC;;AAET,eAAO;AACLd,uBAAc,sBAAqBJ,aAAc,KAD5C;AAELJ,gBAAMY,WAFD;AAGLY,gBAAM;AACJC,mBAAO;AACLzB,oBAAM,IAAIZ,cAAJ,CAAmBkB,SAAnB;AADD;AADH,WAHD;AAQCS,iBAAN,CAAcC,IAAd,gBAA6CU,WAA7C,EAA0D;AAAA;;AAAA;AAAA,kBAApCD,KAAoC,SAApCA,KAAoC;AAAA,kBAAzBE,QAAyB,SAAzBA,QAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAClDC,+CADkD,GACtBlD,iBAChCgD,WADgC,CADsB;AAIlDG,iCAJkD,GAIpCP,qCAClBM,yBADkB,EAElBhB,WAFkB,CAJoC;AAQlDkB,sCARkD,GAQ/BhD,IAAIiD,UAAJ,CAAe,uBAAf,CAR+B;AASlDC,2BATkD,GAS1C,oCACZF,gBADY,EAEZA,gBAFY,EAGZD,WAHY,EAIZ,EAJY,CAT0C;AAelDI,gCAfkD,GAerC,EAfqC;AAgBlDC,+BAhBkD,GAgBtC,EAhBsC;AAiBlDC,+BAjBkD,GAkBtDV,MACE1D,WAAW2C,SAAX,CAAqBjB,MAAMS,IAA3B,EAAiCT,MAAMC,SAAN,CAAgBQ,IAAjD,CADF,CAlBsD;;AAqBxDvB,mDAA6ByD,SAA7B,CACG5C,MADH,CACU;AAAA,+BAAQ6C,KAAKC,OAAL,KAAiB7C,MAAMQ,EAA/B;AAAA,uBADV,EAEGT,MAFH,CAEU;AAAA,+BAAQF,eAAe+C,IAAf,EAAqBjE,KAArB,EAA4BmD,OAA5B,CAAR;AAAA,uBAFV,EAGGgB,OAHH,CAGW,gBAAQ;AACf,4BAAMnB,YAAYrD,WAAWyE,MAAX,CAChBH,KAAKnC,IADW,EAEhBT,MAAMS,IAFU,EAGhBT,MAAMC,SAAN,CAAgBQ,IAHA,CAAlB;AAKA,4BAAMuC,MAAMN,UAAUf,SAAV,CAAZ;AACA,4BACEsB,OAAOC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CACEV,SADF,EAEEf,SAFF,CADF,EAKE;AACAa,qCAAWa,IAAX,CAAgBhE,IAAIiD,UAAJ,CAAeM,KAAKnC,IAApB,CAAhB;AACAgC,oCAAUY,IAAV,CAAe9D,OAAOyD,GAAP,EAAYJ,KAAKrC,IAAjB,CAAf;AACD;AACF,uBAnBH;;AAqBM+C,mCA1CkD,GA0ClCjE,IAAIkD,KAAM;kCAClBlD,IAAIiD,UAAJ,CACZtC,MAAMC,SAAN,CAAgBQ,IADJ,EAEZT,MAAMS,IAFM,CAGZ,IACA+B,WAAWe,MAAX,GACIlE,IAAImE,QAAS;0BACbnE,IAAIoE,IAAJ,CAASjB,UAAT,EAAqB,IAArB,CAA2B;iCACpBnD,IAAIoE,IAAJ,CAAShB,SAAT,EAAoB,IAApB,CAA0B,GAHrC,GAIIpD,IAAImE,QAAS,gBAClB,cApDuD;AAsDpDE,yBAtDoD;AAAA;AAAA;AAAA,6BAwDhDxB,SAASK,KAAT,CAAe,4BAAf,CAxDgD;;AAAA;AAAA;AAAA,6BAyDjC,iCACnBL,QADmB,EAEnB7C,IAAIiD,UAAJ,CAAetC,MAAMC,SAAN,CAAgBQ,IAA/B,EAAqCT,MAAMS,IAA3C,CAFmB,EAGnB6C,aAHmB,EAInBjB,gBAJmB,EAKnBE,KALmB,CAzDiC;;AAAA;AAyDhDoB,4BAzDgD;;AAgEtDD,4BAAMC,OAAOC,IAAP,CAAY,CAAZ,CAAN;AAhEsD;AAAA,6BAiEhD1B,SAASK,KAAT,CACJ,oCADI,CAjEgD;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,6BAqEhDL,SAASK,KAAT,CACJ,wCADI,CArEgD;;AAAA;AAAA;;AAAA;AAAA,uDA0EjD;AACLvB,0CAAkBgB,MAAMhB,gBADnB;AAELO,8BAAMmC;AAFD,uBA1EiD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8EzD;AAtFI,SAAP;AAwFD,OA5Fe,EA6FhB;AACEG,8BAAsB7D,KADxB;AAEE8D,iCAAyB;AAF3B,OA7FgB,CAAlB;AAkGA,aAAOzD,IAAP;AACD,KA/LH,EA+LK,EA/LL,CAFK,EAkMJ,mDAlMI,CAAP;AAoMD,GA5NH;AA8ND,C","file":"PgMutationCreatePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport queryFromResolveData from \"../queryFromResolveData\";\nimport debugFactory from \"debug\";\nimport viaTemporaryTable from \"./viaTemporaryTable\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nexport default (function PgMutationCreatePlugin(\n  builder,\n  { pgInflection: inflection, pgDisableDefaultMutations }\n) {\n  if (pgDisableDefaultMutations) {\n    return;\n  }\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, { scope: { isRootMutation }, fieldWithHooks }) => {\n      const {\n        extend,\n        newWithHooks,\n        parseResolveInfo,\n        pgIntrospectionResultsByKind,\n        pgGetGqlTypeByTypeId,\n        pgGetGqlInputTypeByTypeId,\n        pgSql: sql,\n        gql2pg,\n        graphql: {\n          GraphQLObjectType,\n          GraphQLInputObjectType,\n          GraphQLNonNull,\n          GraphQLString,\n        },\n        pgColumnFilter,\n      } = build;\n      if (!isRootMutation) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        pgIntrospectionResultsByKind.class\n          .filter(table => !!table.namespace)\n          .filter(table => table.isSelectable)\n          .filter(table => table.isInsertable)\n          .reduce((memo, table) => {\n            const Table = pgGetGqlTypeByTypeId(table.type.id);\n            if (!Table) {\n              debug(\n                `There was no table type for table '${table.namespace.name}.${\n                  table.name\n                }', so we're not generating a create mutation for it.`\n              );\n              return memo;\n            }\n            const TableInput = pgGetGqlInputTypeByTypeId(table.type.id);\n            if (!TableInput) {\n              debug(\n                `There was no input type for table '${table.namespace.name}.${\n                  table.name\n                }', so we're not generating a create mutation for it.`\n              );\n              return memo;\n            }\n            const tableTypeName = inflection.tableType(\n              table.name,\n              table.namespace.name\n            );\n            const InputType = newWithHooks(\n              GraphQLInputObjectType,\n              {\n                name: inflection.createInputType(\n                  table.name,\n                  table.namespace.name\n                ),\n                description: `All input for the create \\`${tableTypeName}\\` mutation.`,\n                fields: {\n                  clientMutationId: {\n                    description:\n                      \"An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.\",\n                    type: GraphQLString,\n                  },\n                  [inflection.tableName(table.name, table.namespace.name)]: {\n                    description: `The \\`${tableTypeName}\\` to be created by this mutation.`,\n                    type: new GraphQLNonNull(TableInput),\n                  },\n                },\n              },\n              {\n                isPgCreateInputType: true,\n                pgInflection: table,\n              }\n            );\n            const PayloadType = newWithHooks(\n              GraphQLObjectType,\n              {\n                name: inflection.createPayloadType(\n                  table.name,\n                  table.namespace.name\n                ),\n                description: `The output of our create \\`${tableTypeName}\\` mutation.`,\n                fields: ({ recurseDataGeneratorsForField }) => {\n                  const tableName = inflection.tableName(\n                    table.name,\n                    table.namespace.name\n                  );\n                  recurseDataGeneratorsForField(tableName);\n                  return {\n                    clientMutationId: {\n                      description:\n                        \"The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.\",\n                      type: GraphQLString,\n                    },\n                    [tableName]: {\n                      description: `The \\`${tableTypeName}\\` that was created by this mutation.`,\n                      type: Table,\n                      resolve(data) {\n                        return data.data;\n                      },\n                    },\n                  };\n                },\n              },\n              {\n                isMutationPayload: true,\n                isPgCreatePayloadType: true,\n                pgIntrospection: table,\n              }\n            );\n            const fieldName = inflection.createField(\n              table.name,\n              table.namespace.name\n            );\n            memo[fieldName] = fieldWithHooks(\n              fieldName,\n              context => {\n                const { getDataFromParsedResolveInfoFragment } = context;\n                return {\n                  description: `Creates a single \\`${tableTypeName}\\`.`,\n                  type: PayloadType,\n                  args: {\n                    input: {\n                      type: new GraphQLNonNull(InputType),\n                    },\n                  },\n                  async resolve(data, { input }, { pgClient }, resolveInfo) {\n                    const parsedResolveInfoFragment = parseResolveInfo(\n                      resolveInfo\n                    );\n                    const resolveData = getDataFromParsedResolveInfoFragment(\n                      parsedResolveInfoFragment,\n                      PayloadType\n                    );\n                    const insertedRowAlias = sql.identifier(Symbol());\n                    const query = queryFromResolveData(\n                      insertedRowAlias,\n                      insertedRowAlias,\n                      resolveData,\n                      {}\n                    );\n                    const sqlColumns = [];\n                    const sqlValues = [];\n                    const inputData =\n                      input[\n                        inflection.tableName(table.name, table.namespace.name)\n                      ];\n                    pgIntrospectionResultsByKind.attribute\n                      .filter(attr => attr.classId === table.id)\n                      .filter(attr => pgColumnFilter(attr, build, context))\n                      .forEach(attr => {\n                        const fieldName = inflection.column(\n                          attr.name,\n                          table.name,\n                          table.namespace.name\n                        );\n                        const val = inputData[fieldName];\n                        if (\n                          Object.prototype.hasOwnProperty.call(\n                            inputData,\n                            fieldName\n                          )\n                        ) {\n                          sqlColumns.push(sql.identifier(attr.name));\n                          sqlValues.push(gql2pg(val, attr.type));\n                        }\n                      });\n\n                    const mutationQuery = sql.query`\n                    insert into ${sql.identifier(\n                      table.namespace.name,\n                      table.name\n                    )} ${\n                      sqlColumns.length\n                        ? sql.fragment`(\n                        ${sql.join(sqlColumns, \", \")}\n                      ) values(${sql.join(sqlValues, \", \")})`\n                        : sql.fragment`default values`\n                    } returning *`;\n\n                    let row;\n                    try {\n                      await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                      const result = await viaTemporaryTable(\n                        pgClient,\n                        sql.identifier(table.namespace.name, table.name),\n                        mutationQuery,\n                        insertedRowAlias,\n                        query\n                      );\n                      row = result.rows[0];\n                      await pgClient.query(\n                        \"RELEASE SAVEPOINT graphql_mutation\"\n                      );\n                    } catch (e) {\n                      await pgClient.query(\n                        \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                      );\n                      throw e;\n                    }\n                    return {\n                      clientMutationId: input.clientMutationId,\n                      data: row,\n                    };\n                  },\n                };\n              },\n              {\n                pgFieldIntrospection: table,\n                isPgCreateMutationField: true,\n              }\n            );\n            return memo;\n          }, {}),\n        `Adding default 'create' mutation to root mutation`\n      );\n    }\n  );\n}: Plugin);\n"]}