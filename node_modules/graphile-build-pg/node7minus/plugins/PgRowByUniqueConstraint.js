"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _queryFromResolveData = require("../queryFromResolveData");

var _queryFromResolveData2 = _interopRequireDefault(_queryFromResolveData);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debugSql = (0, _debug2.default)("graphile-build-pg:sql");

exports.default = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(builder, _ref) {
    var inflection = _ref.pgInflection;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            builder.hook("GraphQLObjectType:fields", function (fields, _ref3, _ref4) {
              var extend = _ref3.extend,
                  parseResolveInfo = _ref3.parseResolveInfo,
                  pgGetGqlTypeByTypeId = _ref3.pgGetGqlTypeByTypeId,
                  pgGetGqlInputTypeByTypeId = _ref3.pgGetGqlInputTypeByTypeId,
                  gql2pg = _ref3.gql2pg,
                  introspectionResultsByKind = _ref3.pgIntrospectionResultsByKind,
                  sql = _ref3.pgSql,
                  GraphQLNonNull = _ref3.graphql.GraphQLNonNull;
              var isRootQuery = _ref4.scope.isRootQuery,
                  fieldWithHooks = _ref4.fieldWithHooks;

              if (!isRootQuery) {
                return fields;
              }
              return extend(fields, introspectionResultsByKind.class.filter(function (table) {
                return !!table.namespace;
              }).reduce(function (memo, table) {
                var TableType = pgGetGqlTypeByTypeId(table.type.id);
                var sqlFullTableName = sql.identifier(table.namespace.name, table.name);
                if (TableType) {
                  var uniqueConstraints = introspectionResultsByKind.constraint.filter(function (con) {
                    return con.classId === table.id;
                  }).filter(function (con) {
                    return con.type === "u" || con.type === "p";
                  });
                  var attributes = introspectionResultsByKind.attribute.filter(function (attr) {
                    return attr.classId === table.id;
                  }).sort(function (a, b) {
                    return a.num - b.num;
                  });
                  uniqueConstraints.forEach(function (constraint) {
                    var keys = constraint.keyAttributeNums.map(function (num) {
                      return attributes.filter(function (attr) {
                        return attr.num === num;
                      })[0];
                    });
                    if (!keys.every(function (_) {
                      return _;
                    })) {
                      throw new Error("Consistency error: could not find an attribute!");
                    }
                    var simpleKeys = keys.map(function (k) {
                      return {
                        column: k.name,
                        table: k.class.name,
                        schema: k.class.namespace.name
                      };
                    });
                    var fieldName = inflection.rowByUniqueKeys(simpleKeys, table.name, table.namespace.name);
                    memo[fieldName] = fieldWithHooks(fieldName, function (_ref5) {
                      var getDataFromParsedResolveInfoFragment = _ref5.getDataFromParsedResolveInfoFragment;

                      return {
                        type: TableType,
                        args: keys.reduce(function (memo, key) {
                          var InputType = pgGetGqlInputTypeByTypeId(key.typeId);
                          if (!InputType) {
                            throw new Error(`Could not find input type for key '${key.name}' on type '${TableType.name}'`);
                          }
                          memo[inflection.column(key.name, key.class.name, key.class.namespace.name)] = {
                            type: new GraphQLNonNull(InputType)
                          };
                          return memo;
                        }, {}),
                        resolve(parent, args, _ref6, resolveInfo) {
                          var _this = this;

                          return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                            var pgClient = _ref6.pgClient;

                            var parsedResolveInfoFragment, resolveData, query, _sql$compile, text, values, _ref7, _ref7$rows, row;

                            return _regenerator2.default.wrap(function _callee$(_context) {
                              while (1) {
                                switch (_context.prev = _context.next) {
                                  case 0:
                                    parsedResolveInfoFragment = parseResolveInfo(resolveInfo);
                                    resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, TableType);
                                    query = (0, _queryFromResolveData2.default)(sqlFullTableName, undefined, resolveData, {}, function (builder) {
                                      keys.forEach(function (key) {
                                        builder.where(sql.fragment`${builder.getTableAlias()}.${sql.identifier(key.name)} = ${gql2pg(args[inflection.column(key.name, key.class.name, key.class.namespace.name)], key.type)}`);
                                      });
                                    });
                                    _sql$compile = sql.compile(query), text = _sql$compile.text, values = _sql$compile.values;

                                    if (debugSql.enabled) debugSql(text);
                                    _context.next = 7;
                                    return pgClient.query(text, values);

                                  case 7:
                                    _ref7 = _context.sent;
                                    _ref7$rows = (0, _slicedToArray3.default)(_ref7.rows, 1);
                                    row = _ref7$rows[0];
                                    return _context.abrupt("return", row);

                                  case 11:
                                  case "end":
                                    return _context.stop();
                                }
                              }
                            }, _callee, _this);
                          }))();
                        }
                      };
                    }, {
                      isPgRowByUniqueConstraintField: true,
                      pgFieldIntrospection: constraint
                    });
                  });
                }
                return memo;
              }, {}), `Adding "row by unique constraint" fields to root Query type`);
            });

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  function PgRowByUniqueConstraint(_x, _x2) {
    return _ref2.apply(this, arguments);
  }

  return PgRowByUniqueConstraint;
}();
//# sourceMappingURL=PgRowByUniqueConstraint.js.map