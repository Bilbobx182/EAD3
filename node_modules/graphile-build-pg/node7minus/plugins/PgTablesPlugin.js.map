{"version":3,"sources":["../../src/plugins/PgTablesPlugin.js"],"names":["base64","Buffer","String","str","toString","PgTablesPlugin","builder","inflection","pgInflection","hook","_","build","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","newWithHooks","sql","pgSql","introspectionResultsByKind","pgIntrospectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeId","pgGetGqlInputTypeByTypeId","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pg2GqlMapper","gql2pg","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLID","GraphQLList","GraphQLInputObjectType","pgColumnFilter","Cursor","class","forEach","tablePgType","type","find","category","namespaceId","table","classId","id","Error","arrayTablePgType","arrayItemTypeId","primaryKeyConstraint","constraint","filter","con","primaryKeys","keyAttributeNums","map","attributeByClassIdAndNum","num","attributes","attribute","attr","sort","a1","a2","tableTypeName","tableType","name","namespaceName","shouldHaveNodeId","isSelectable","namespace","length","TableType","description","interfaces","fields","addDataGeneratorForField","Self","pgQuery","queryBuilder","select","fragment","join","getTableAlias","identifier","key","resolve","data","__identifiers","pgIntrospection","isPgRowType","isPgCompoundType","cb","pgInputFields","inputType","unmap","context","null","fieldName","column","pgInputField","v","obj","isInputType","pgAddSubfield","attrName","pgType","spec","patchType","isPgPatch","_attrName","_type","EdgeType","edge","fieldWithHooks","recurseDataGeneratorsForField","cursor","addDataGenerator","usesCursor","__cursor","isCursorField","node","isEdgeType","isPgRowEdgeType","nodeType","PageInfo","connection","nodes","edges","pageInfo","isConnectionType","isPgRowConnectionType","edgeType","TableInputType"],"mappings":"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","file":"PgTablesPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => new Buffer(String(str)).toString(\"base64\");\n\nexport default (function PgTablesPlugin(builder, { pgInflection: inflection }) {\n  builder.hook(\"init\", (_, build) => {\n    const {\n      getNodeIdForTypeAndIdentifiers,\n      nodeIdFieldName,\n      newWithHooks,\n      pgSql: sql,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      getTypeByName,\n      pgGetGqlTypeByTypeId,\n      pgGetGqlInputTypeByTypeId,\n      pgRegisterGqlTypeByTypeId,\n      pgRegisterGqlInputTypeByTypeId,\n      pg2GqlMapper,\n      gql2pg,\n      graphql: {\n        GraphQLObjectType,\n        GraphQLNonNull,\n        GraphQLID,\n        GraphQLList,\n        GraphQLInputObjectType,\n      },\n      pgColumnFilter,\n    } = build;\n    const Cursor = getTypeByName(\"Cursor\");\n    introspectionResultsByKind.class.forEach(table => {\n      const tablePgType = introspectionResultsByKind.type.find(\n        type =>\n          type.type === \"c\" &&\n          type.category === \"C\" &&\n          type.namespaceId === table.namespaceId &&\n          type.classId === table.id\n      );\n      if (!tablePgType) {\n        throw new Error(\"Could not determine the type for this table\");\n      }\n      const arrayTablePgType = introspectionResultsByKind.type.find(\n        type => type.arrayItemTypeId === tablePgType.id\n      );\n      /*\n        table =\n          { kind: 'class',\n            id: '6484790',\n            name: 'bundle',\n            description: null,\n            namespaceId: '6484381',\n            typeId: '6484792',\n            isSelectable: true,\n            isInsertable: true,\n            isUpdatable: true,\n            isDeletable: true }\n        */\n      const primaryKeyConstraint = introspectionResultsByKind.constraint\n        .filter(con => con.classId === table.id)\n        .filter(con => con.type === \"p\")[0];\n      const primaryKeys =\n        primaryKeyConstraint &&\n        primaryKeyConstraint.keyAttributeNums.map(\n          num =>\n            introspectionResultsByKind.attributeByClassIdAndNum[table.id][num]\n        );\n      const attributes = introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .sort((a1, a2) => a1.num - a2.num);\n      const tableTypeName = inflection.tableType(\n        table.name,\n        table.namespaceName\n      );\n      const shouldHaveNodeId: boolean =\n        nodeIdFieldName &&\n        table.isSelectable &&\n        table.namespace &&\n        primaryKeys &&\n        primaryKeys.length\n          ? true\n          : false;\n      pgRegisterGqlTypeByTypeId(\n        tablePgType.id,\n        cb => {\n          if (pg2GqlMapper[tablePgType.id]) {\n            // Already handled\n            throw new Error(\n              `Register was called but there's already a mapper in place for '${\n                tablePgType.id\n              }'!`\n            );\n          }\n          const TableType = newWithHooks(\n            GraphQLObjectType,\n            {\n              description: table.description || tablePgType.description,\n              name: tableTypeName,\n              interfaces: () => {\n                if (shouldHaveNodeId) {\n                  return [getTypeByName(\"Node\")];\n                } else {\n                  return [];\n                }\n              },\n              fields: ({ addDataGeneratorForField, Self }) => {\n                const fields = {};\n                if (shouldHaveNodeId) {\n                  // Enable nodeId interface\n                  addDataGeneratorForField(nodeIdFieldName, () => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(\n                          sql.fragment`json_build_array(${sql.join(\n                            primaryKeys.map(\n                              key =>\n                                sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                  key.name\n                                )}`\n                            ),\n                            \", \"\n                          )})`,\n                          \"__identifiers\"\n                        );\n                      },\n                    };\n                  });\n                  fields[nodeIdFieldName] = {\n                    description:\n                      \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n                    type: new GraphQLNonNull(GraphQLID),\n                    resolve(data) {\n                      return (\n                        data.__identifiers &&\n                        getNodeIdForTypeAndIdentifiers(\n                          Self,\n                          ...data.__identifiers\n                        )\n                      );\n                    },\n                  };\n                }\n                return fields;\n              },\n            },\n            {\n              pgIntrospection: table,\n              isPgRowType: table.isSelectable,\n              isPgCompoundType: !table.isSelectable,\n            }\n          );\n          cb(TableType);\n          const pgInputFields = {};\n          newWithHooks(\n            GraphQLInputObjectType,\n            {\n              description: `An input for mutations affecting \\`${tableTypeName}\\``,\n              name: inflection.inputType(TableType),\n              fields: context => {\n                pg2GqlMapper[tablePgType.id] = {\n                  map: _ => _,\n                  unmap: obj => {\n                    return sql.fragment`row(${sql.join(\n                      attributes.map(attr => {\n                        if (!pgColumnFilter(attr, build, context)) {\n                          return sql.null; // TODO: return default instead.\n                        }\n                        const fieldName = inflection.column(\n                          attr.name,\n                          table.name,\n                          table.namespaceName\n                        );\n                        const pgInputField = pgInputFields[fieldName];\n                        const v = obj[fieldName];\n                        if (pgInputField && v != null) {\n                          const { type } = pgInputField;\n                          return sql.fragment`${gql2pg(\n                            v,\n                            type\n                          )}::${sql.identifier(type.namespaceName, type.name)}`;\n                        } else {\n                          return sql.null; // TODO: return default instead.\n                        }\n                      }),\n                      \",\"\n                    )})::${sql.identifier(\n                      tablePgType.namespaceName,\n                      tablePgType.name\n                    )}`;\n                  },\n                };\n                return {};\n              },\n            },\n            {\n              pgIntrospection: table,\n              isInputType: true,\n              isPgRowType: table.isSelectable,\n              isPgCompoundType: !table.isSelectable,\n              pgAddSubfield(fieldName, attrName, pgType, spec) {\n                pgInputFields[fieldName] = {\n                  name: attrName,\n                  type: pgType,\n                };\n                return spec;\n              },\n            }\n          );\n\n          if (table.isSelectable) {\n            /* const TablePatchType = */\n            newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: `Represents an update to a \\`${tableTypeName}\\`. Fields that are set will be updated.`,\n                name: inflection.patchType(TableType),\n              },\n              {\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                isPgPatch: true,\n                pgAddSubfield(fieldName, _attrName, _type, spec) {\n                  // We don't use this currently\n                  return spec;\n                },\n              }\n            );\n          }\n          const EdgeType = newWithHooks(\n            GraphQLObjectType,\n            {\n              description: `A \\`${tableTypeName}\\` edge in the connection.`,\n              name: inflection.edge(TableType.name),\n              fields: ({ fieldWithHooks, recurseDataGeneratorsForField }) => {\n                recurseDataGeneratorsForField(\"node\");\n                return {\n                  cursor: fieldWithHooks(\n                    \"cursor\",\n                    ({ addDataGenerator }) => {\n                      addDataGenerator(() => ({\n                        usesCursor: [true],\n                      }));\n                      return {\n                        description: \"A cursor for use in pagination.\",\n                        type: Cursor,\n                        resolve(data) {\n                          return (\n                            data.__cursor &&\n                            base64(JSON.stringify(data.__cursor))\n                          );\n                        },\n                      };\n                    },\n                    {\n                      isCursorField: true,\n                    }\n                  ),\n                  node: {\n                    description: `The \\`${tableTypeName}\\` at the end of the edge.`,\n                    type: new GraphQLNonNull(TableType),\n                    resolve(data) {\n                      return data;\n                    },\n                  },\n                };\n              },\n            },\n            {\n              isEdgeType: true,\n              isPgRowEdgeType: true,\n              nodeType: TableType,\n              pgIntrospection: table,\n            }\n          );\n          const PageInfo = getTypeByName(\"PageInfo\");\n          /*const ConnectionType = */\n          newWithHooks(\n            GraphQLObjectType,\n            {\n              description: `A connection to a list of \\`${tableTypeName}\\` values.`,\n              name: inflection.connection(TableType.name),\n              fields: ({ recurseDataGeneratorsForField }) => {\n                recurseDataGeneratorsForField(\"edges\");\n                recurseDataGeneratorsForField(\"nodes\");\n                recurseDataGeneratorsForField(\"pageInfo\");\n                return {\n                  nodes: {\n                    description: `A list of \\`${tableTypeName}\\` objects.`,\n                    type: new GraphQLNonNull(new GraphQLList(TableType)),\n                    resolve(data) {\n                      return data.data;\n                    },\n                  },\n                  edges: {\n                    description: `A list of edges which contains the \\`${tableTypeName}\\` and cursor to aid in pagination.`,\n                    type: new GraphQLNonNull(\n                      new GraphQLList(new GraphQLNonNull(EdgeType))\n                    ),\n                    resolve(data) {\n                      return data.data;\n                    },\n                  },\n                  pageInfo: PageInfo && {\n                    description: \"Information to aid in pagination.\",\n                    type: new GraphQLNonNull(PageInfo),\n                    resolve(data) {\n                      return data;\n                    },\n                  },\n                };\n              },\n            },\n            {\n              isConnectionType: true,\n              isPgRowConnectionType: true,\n              edgeType: EdgeType,\n              nodeType: TableType,\n              pgIntrospection: table,\n            }\n          );\n        },\n        true\n      );\n      pgRegisterGqlInputTypeByTypeId(\n        tablePgType.id,\n        () => {\n          const TableType = pgGetGqlTypeByTypeId(tablePgType.id);\n          return getTypeByName(inflection.inputType(TableType));\n        },\n        true\n      );\n\n      if (arrayTablePgType) {\n        // Note: these do not return\n        //\n        // `new GraphQLList(new GraphQLNonNull(...))`\n        //\n        // because it's possible to return null entries from postgresql\n        // functions. We should probably add a flag to instead export\n        // the non-null version as that's more typical.\n        pgRegisterGqlTypeByTypeId(\n          arrayTablePgType.id,\n          () => {\n            const TableType = pgGetGqlTypeByTypeId(tablePgType.id);\n            return new GraphQLList(TableType);\n          },\n          true\n        );\n        pgRegisterGqlInputTypeByTypeId(\n          arrayTablePgType.id,\n          () => {\n            const TableInputType = pgGetGqlInputTypeByTypeId(tablePgType.id);\n            return new GraphQLList(TableInputType);\n          },\n          true\n        );\n      }\n    });\n    return _;\n  });\n}: Plugin);\n"]}