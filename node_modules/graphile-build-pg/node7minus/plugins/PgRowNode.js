"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toArray2 = require("babel-runtime/helpers/toArray");

var _toArray3 = _interopRequireDefault(_toArray2);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _queryFromResolveData = require("../queryFromResolveData");

var _queryFromResolveData2 = _interopRequireDefault(_queryFromResolveData);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var base64Decode = function base64Decode(str) {
  return new Buffer(String(str), "base64").toString("utf8");
};

var debugSql = (0, _debug2.default)("graphile-build-pg:sql");

exports.default = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(builder, _ref) {
    var _this = this;

    var inflection = _ref.pgInflection;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            builder.hook("GraphQLObjectType", function (object, _ref3, _ref4) {
              var addNodeFetcherForTypeName = _ref3.addNodeFetcherForTypeName,
                  introspectionResultsByKind = _ref3.pgIntrospectionResultsByKind,
                  sql = _ref3.pgSql,
                  gql2pg = _ref3.gql2pg;
              var _ref4$scope = _ref4.scope,
                  isPgRowType = _ref4$scope.isPgRowType,
                  table = _ref4$scope.pgIntrospection;

              if (!isPgRowType || !table.namespace) {
                return object;
              }
              var sqlFullTableName = sql.identifier(table.namespace.name, table.name);
              var attributes = introspectionResultsByKind.attribute.filter(function (attr) {
                return attr.classId === table.id;
              });
              var primaryKeyConstraint = introspectionResultsByKind.constraint.filter(function (con) {
                return con.classId === table.id;
              }).filter(function (con) {
                return con.type === "p";
              })[0];
              if (!primaryKeyConstraint) {
                return object;
              }
              var primaryKeys = primaryKeyConstraint && primaryKeyConstraint.keyAttributeNums.map(function (num) {
                return attributes.filter(function (attr) {
                  return attr.num === num;
                })[0];
              });
              addNodeFetcherForTypeName(object.name, function () {
                var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(data, identifiers, _ref5, parsedResolveInfoFragment, ReturnType, resolveData) {
                  var pgClient = _ref5.pgClient;

                  var query, _sql$compile, text, values, _ref7, _ref7$rows, row;

                  return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          if (!(identifiers.length !== primaryKeys.length)) {
                            _context.next = 2;
                            break;
                          }

                          throw new Error("Invalid ID");

                        case 2:
                          query = (0, _queryFromResolveData2.default)(sqlFullTableName, undefined, resolveData, {}, function (builder) {
                            primaryKeys.forEach(function (key, idx) {
                              builder.where(sql.fragment`${builder.getTableAlias()}.${sql.identifier(key.name)} = ${gql2pg(identifiers[idx], primaryKeys[idx].type)}`);
                            });
                          });
                          _sql$compile = sql.compile(query), text = _sql$compile.text, values = _sql$compile.values;

                          if (debugSql.enabled) debugSql(text);
                          _context.next = 7;
                          return pgClient.query(text, values);

                        case 7:
                          _ref7 = _context.sent;
                          _ref7$rows = (0, _slicedToArray3.default)(_ref7.rows, 1);
                          row = _ref7$rows[0];
                          return _context.abrupt("return", row);

                        case 11:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, _this);
                }));

                return function (_x3, _x4, _x5, _x6, _x7, _x8) {
                  return _ref6.apply(this, arguments);
                };
              }());
              return object;
            });

            builder.hook("GraphQLObjectType:fields", function (fields, _ref8, _ref9) {
              var nodeIdFieldName = _ref8.nodeIdFieldName,
                  extend = _ref8.extend,
                  parseResolveInfo = _ref8.parseResolveInfo,
                  pgGetGqlTypeByTypeId = _ref8.pgGetGqlTypeByTypeId,
                  introspectionResultsByKind = _ref8.pgIntrospectionResultsByKind,
                  sql = _ref8.pgSql,
                  gql2pg = _ref8.gql2pg,
                  getNodeType = _ref8.getNodeType,
                  _ref8$graphql = _ref8.graphql,
                  GraphQLNonNull = _ref8$graphql.GraphQLNonNull,
                  GraphQLID = _ref8$graphql.GraphQLID;
              var isRootQuery = _ref9.scope.isRootQuery,
                  fieldWithHooks = _ref9.fieldWithHooks;

              if (!isRootQuery || !nodeIdFieldName) {
                return fields;
              }
              return extend(fields, introspectionResultsByKind.class.filter(function (table) {
                return !!table.namespace;
              }).reduce(function (memo, table) {
                var TableType = pgGetGqlTypeByTypeId(table.type.id);
                var sqlFullTableName = sql.identifier(table.namespace.name, table.name);
                if (TableType) {
                  var attributes = introspectionResultsByKind.attribute.filter(function (attr) {
                    return attr.classId === table.id;
                  });
                  var primaryKeyConstraint = introspectionResultsByKind.constraint.filter(function (con) {
                    return con.classId === table.id;
                  }).filter(function (con) {
                    return con.type === "p";
                  })[0];
                  if (!primaryKeyConstraint) {
                    return memo;
                  }
                  var primaryKeys = primaryKeyConstraint && primaryKeyConstraint.keyAttributeNums.map(function (num) {
                    return attributes.filter(function (attr) {
                      return attr.num === num;
                    })[0];
                  });
                  var fieldName = inflection.tableNode(table.name, table.namespace.name);
                  memo[fieldName] = fieldWithHooks(fieldName, function (_ref10) {
                    var getDataFromParsedResolveInfoFragment = _ref10.getDataFromParsedResolveInfoFragment;

                    return {
                      description: `Reads a single \`${TableType.name}\` using its globally unique \`ID\`.`,
                      type: TableType,
                      args: {
                        [nodeIdFieldName]: {
                          description: `The globally unique \`ID\` to be used in selecting a single \`${TableType.name}\`.`,
                          type: new GraphQLNonNull(GraphQLID)
                        }
                      },
                      resolve(parent, args, _ref11, resolveInfo) {
                        var _this2 = this;

                        return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                          var pgClient = _ref11.pgClient;

                          var nodeId, _JSON$parse, _JSON$parse2, alias, identifiers, NodeTypeByAlias, parsedResolveInfoFragment, resolveData, query, _sql$compile2, text, values, _ref12, _ref12$rows, row;

                          return _regenerator2.default.wrap(function _callee2$(_context2) {
                            while (1) {
                              switch (_context2.prev = _context2.next) {
                                case 0:
                                  nodeId = args[nodeIdFieldName];
                                  _context2.prev = 1;
                                  _JSON$parse = JSON.parse(base64Decode(nodeId)), _JSON$parse2 = (0, _toArray3.default)(_JSON$parse), alias = _JSON$parse2[0], identifiers = _JSON$parse2.slice(1);
                                  NodeTypeByAlias = getNodeType(alias);

                                  if (!(NodeTypeByAlias !== TableType)) {
                                    _context2.next = 6;
                                    break;
                                  }

                                  throw new Error("Mismatched type");

                                case 6:
                                  if (!(identifiers.length !== primaryKeys.length)) {
                                    _context2.next = 8;
                                    break;
                                  }

                                  throw new Error("Invalid ID");

                                case 8:
                                  parsedResolveInfoFragment = parseResolveInfo(resolveInfo);
                                  resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, TableType);
                                  query = (0, _queryFromResolveData2.default)(sqlFullTableName, undefined, resolveData, {}, function (builder) {
                                    primaryKeys.forEach(function (key, idx) {
                                      builder.where(sql.fragment`${builder.getTableAlias()}.${sql.identifier(key.name)} = ${gql2pg(identifiers[idx], primaryKeys[idx].type)}`);
                                    });
                                  });
                                  _sql$compile2 = sql.compile(query), text = _sql$compile2.text, values = _sql$compile2.values;

                                  if (debugSql.enabled) debugSql(text);
                                  _context2.next = 15;
                                  return pgClient.query(text, values);

                                case 15:
                                  _ref12 = _context2.sent;
                                  _ref12$rows = (0, _slicedToArray3.default)(_ref12.rows, 1);
                                  row = _ref12$rows[0];
                                  return _context2.abrupt("return", row);

                                case 21:
                                  _context2.prev = 21;
                                  _context2.t0 = _context2["catch"](1);
                                  return _context2.abrupt("return", null);

                                case 24:
                                case "end":
                                  return _context2.stop();
                              }
                            }
                          }, _callee2, _this2, [[1, 21]]);
                        }))();
                      }
                    };
                  }, {
                    isPgNodeQuery: true,
                    pgFieldIntrospection: table
                  });
                }
                return memo;
              }, {}), `Adding "row by node ID" fields to root Query type`);
            });

          case 2:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  function PgRowByUniqueConstraint(_x, _x2) {
    return _ref2.apply(this, arguments);
  }

  return PgRowByUniqueConstraint;
}();
//# sourceMappingURL=PgRowNode.js.map