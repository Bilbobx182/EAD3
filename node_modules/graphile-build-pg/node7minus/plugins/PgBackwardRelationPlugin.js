"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

var _queryFromResolveData = require("../queryFromResolveData");

var _queryFromResolveData2 = _interopRequireDefault(_queryFromResolveData);

var _addStartEndCursor = require("./addStartEndCursor");

var _addStartEndCursor2 = _interopRequireDefault(_addStartEndCursor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("graphile-build-pg");

exports.default = function PgBackwardRelationPlugin(builder, _ref) {
  var inflection = _ref.pgInflection;

  builder.hook("GraphQLObjectType:fields", function (fields, _ref2, _ref3) {
    var extend = _ref2.extend,
        getTypeByName = _ref2.getTypeByName,
        pgGetGqlTypeByTypeId = _ref2.pgGetGqlTypeByTypeId,
        introspectionResultsByKind = _ref2.pgIntrospectionResultsByKind,
        sql = _ref2.pgSql,
        getAliasFromResolveInfo = _ref2.getAliasFromResolveInfo,
        GraphQLNonNull = _ref2.graphql.GraphQLNonNull;
    var _ref3$scope = _ref3.scope,
        isPgRowType = _ref3$scope.isPgRowType,
        foreignTable = _ref3$scope.pgIntrospection,
        fieldWithHooks = _ref3.fieldWithHooks,
        Self = _ref3.Self;

    if (!isPgRowType || !foreignTable || foreignTable.kind !== "class") {
      return fields;
    }
    // This is a relation in which WE are foreign
    var foreignKeyConstraints = introspectionResultsByKind.constraint.filter(function (con) {
      return con.type === "f";
    }).filter(function (con) {
      return con.foreignClassId === foreignTable.id;
    });
    var foreignAttributes = introspectionResultsByKind.attribute.filter(function (attr) {
      return attr.classId === foreignTable.id;
    }).sort(function (a, b) {
      return a.num - b.num;
    });

    return extend(fields, foreignKeyConstraints.reduce(function (memo, constraint) {
      var table = introspectionResultsByKind.classById[constraint.classId];
      var tableTypeName = inflection.tableType(table.name, table.namespace.name);
      var gqlTableType = pgGetGqlTypeByTypeId(table.type.id);
      if (!gqlTableType) {
        debug(`Could not determine type for table with id ${constraint.classId}`);
        return memo;
      }
      var foreignTable = introspectionResultsByKind.classById[constraint.foreignClassId];
      var gqlForeignTableType = pgGetGqlTypeByTypeId(foreignTable.type.id);
      if (!gqlForeignTableType) {
        debug(`Could not determine type for foreign table with id ${constraint.foreignClassId}`);
        return memo;
      }
      if (!table) {
        throw new Error(`Could not find the table that referenced us (constraint: ${constraint.name})`);
      }
      var schema = table.namespace;

      var attributes = introspectionResultsByKind.attribute.filter(function (attr) {
        return attr.classId === table.id;
      });

      var keys = constraint.keyAttributeNums.map(function (num) {
        return attributes.filter(function (attr) {
          return attr.num === num;
        })[0];
      });
      var foreignKeys = constraint.foreignKeyAttributeNums.map(function (num) {
        return foreignAttributes.filter(function (attr) {
          return attr.num === num;
        })[0];
      });
      if (!keys.every(function (_) {
        return _;
      }) || !foreignKeys.every(function (_) {
        return _;
      })) {
        throw new Error("Could not find key columns!");
      }

      var simpleKeys = keys.map(function (k) {
        return {
          column: k.name,
          table: k.class.name,
          schema: k.class.namespace.name
        };
      });
      var fieldName = inflection.manyRelationByKeys(simpleKeys, table.name, table.namespace.name, foreignTable.name, foreignTable.namespace.name);
      var primaryKeyConstraint = introspectionResultsByKind.constraint.filter(function (con) {
        return con.classId === table.id;
      }).filter(function (con) {
        return con.type === "p";
      })[0];
      var primaryKeys = primaryKeyConstraint && primaryKeyConstraint.keyAttributeNums.map(function (num) {
        return attributes.filter(function (attr) {
          return attr.num === num;
        })[0];
      });

      memo[fieldName] = fieldWithHooks(fieldName, function (_ref4) {
        var getDataFromParsedResolveInfoFragment = _ref4.getDataFromParsedResolveInfoFragment,
            addDataGenerator = _ref4.addDataGenerator;

        addDataGenerator(function (parsedResolveInfoFragment) {
          return {
            pgQuery: function pgQuery(queryBuilder) {
              queryBuilder.select(function () {
                var resolveData = getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, ConnectionType);
                var tableAlias = sql.identifier((0, _symbol2.default)());
                var foreignTableAlias = queryBuilder.getTableAlias();
                var query = (0, _queryFromResolveData2.default)(sql.identifier(schema.name, table.name), tableAlias, resolveData, {
                  withPagination: true,
                  withPaginationAsFields: false
                }, function (innerQueryBuilder) {
                  if (primaryKeys) {
                    innerQueryBuilder.beforeLock("orderBy", function () {
                      // append order by primary key to the list of orders
                      if (!innerQueryBuilder.isOrderUnique(false)) {
                        innerQueryBuilder.data.cursorPrefix = ["primary_key_asc"];
                        primaryKeys.forEach(function (key) {
                          innerQueryBuilder.orderBy(sql.fragment`${innerQueryBuilder.getTableAlias()}.${sql.identifier(key.name)}`, true);
                        });
                        innerQueryBuilder.setOrderIsUnique();
                      }
                    });
                  }

                  keys.forEach(function (key, i) {
                    innerQueryBuilder.where(sql.fragment`${tableAlias}.${sql.identifier(key.name)} = ${foreignTableAlias}.${sql.identifier(foreignKeys[i].name)}`);
                  });
                });
                return sql.fragment`(${query})`;
              }, parsedResolveInfoFragment.alias);
            }
          };
        });
        var ConnectionType = getTypeByName(inflection.connection(gqlTableType.name));
        return {
          description: `Reads and enables pagination through a set of \`${tableTypeName}\`.`,
          type: new GraphQLNonNull(ConnectionType),
          args: {},
          resolve: function resolve(data, _args, _context, resolveInfo) {
            var alias = getAliasFromResolveInfo(resolveInfo);
            return (0, _addStartEndCursor2.default)(data[alias]);
          }
        };
      }, {
        isPgFieldConnection: true,
        pgFieldIntrospection: table
      });
      return memo;
    }, {}), `Adding backward relations for ${Self.name}`);
  });
};
//# sourceMappingURL=PgBackwardRelationPlugin.js.map