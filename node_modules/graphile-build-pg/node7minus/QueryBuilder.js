"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _pgSql = require("pg-sql2");

var sql = _interopRequireWildcard(_pgSql);

var _isSafeInteger = require("lodash/isSafeInteger");

var _isSafeInteger2 = _interopRequireDefault(_isSafeInteger);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isDev = ["test", "development"].indexOf(process.env.NODE_ENV) >= 0;

function callIfNecessary(o, context) {
  if (typeof o === "function") {
    return o(context);
  } else {
    return o;
  }
}

function callIfNecessaryArray(o, context) {
  if (Array.isArray(o)) {
    return o.map(function (v) {
      return callIfNecessary(v, context);
    });
  } else {
    return o;
  }
}

var QueryBuilder = function () {
  function QueryBuilder() {
    var _this = this;

    (0, _classCallCheck3.default)(this, QueryBuilder);

    this.locks = {};
    this.finalized = false;
    this.data = {
      // TODO: refactor `cursorPrefix`, it shouldn't be here (or should at least have getters/setters)
      cursorPrefix: ["natural"],
      select: [],
      selectCursor: null,
      from: null,
      join: [],
      where: [],
      whereBound: {
        lower: [],
        upper: []
      },
      orderBy: [],
      orderIsUnique: false,
      limit: null,
      offset: null,
      first: null,
      last: null,
      beforeLock: {},
      cursorComparator: null
    };
    this.compiledData = {
      cursorPrefix: ["natural"],
      select: [],
      selectCursor: null,
      from: null,
      join: [],
      where: [],
      whereBound: {
        lower: [],
        upper: []
      },
      orderBy: [],
      orderIsUnique: false,
      limit: null,
      offset: null,
      first: null,
      last: null,
      cursorComparator: null
    };
    this.beforeLock("select", function () {
      _this.lock("selectCursor");
      if (_this.compiledData.selectCursor) {
        _this.select(_this.compiledData.selectCursor, "__cursor");
      }
    });
    // 'whereBound' and 'natural' order might set offset/limit
    this.beforeLock("where", function () {
      _this.lock("whereBound");
    });
    this.beforeLock("offset", function () {
      _this.lock("whereBound");
    });
    this.beforeLock("limit", function () {
      _this.lock("whereBound");
    });
    this.beforeLock("first", function () {
      _this.lock("limit");
      _this.lock("offset");
    });
    this.beforeLock("last", function () {
      _this.lock("limit");
      _this.lock("offset");
    });
  }

  // ----------------------------------------

  (0, _createClass3.default)(QueryBuilder, [{
    key: "beforeLock",
    value: function beforeLock(field, fn) {
      this.checkLock(field);
      this.data.beforeLock[field] = this.data.beforeLock[field] || [];
      this.data.beforeLock[field].push(fn);
    }
  }, {
    key: "setCursorComparator",
    value: function setCursorComparator(fn) {
      this.checkLock("cursorComparator");
      this.data.cursorComparator = fn;
      this.lock("cursorComparator");
    }
  }, {
    key: "addCursorCondition",
    value: function addCursorCondition(cursorValue, isAfter) {
      var _this2 = this;

      this.beforeLock("whereBound", function () {
        _this2.lock("cursorComparator");
        if (!_this2.compiledData.cursorComparator) {
          throw new Error("No cursor comparator was set!");
        }
        _this2.compiledData.cursorComparator(cursorValue, isAfter);
      });
    }
  }, {
    key: "select",
    value: function select(exprGen, alias) {
      this.checkLock("select");
      if (typeof alias === "string") {
        // To protect against vulnerabilities such as
        //
        // https://github.com/brianc/node-postgres/issues/1408
        //
        // we need to ensure column names are safe. Turns out that GraphQL
        // aliases are fairly strict (`[_A-Za-z][_0-9A-Za-z]*`) anyway:
        //
        // https://github.com/graphql/graphql-js/blob/680685dd14bd52c6475305e150e5f295ead2aa7e/src/language/lexer.js#L551-L581
        //
        // so this should not cause any issues in practice.
        if (/^[_A-Za-z][_0-9A-Za-z]*$/.test(alias) !== true) {
          throw new Error(`Disallowed alias '${alias}'.`);
        }
      }
      this.data.select.push([exprGen, alias]);
    }
  }, {
    key: "selectCursor",
    value: function selectCursor(exprGen) {
      this.checkLock("selectCursor");
      this.data.selectCursor = exprGen;
    }
  }, {
    key: "from",
    value: function from(expr) {
      var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sql.identifier((0, _symbol2.default)());

      this.checkLock("from");
      if (!expr) {
        throw new Error("No from table source!");
      }
      if (!alias) {
        throw new Error("No from alias!");
      }
      this.data.from = [expr, alias];
      this.lock("from");
    }
    // XXX: join

  }, {
    key: "where",
    value: function where(exprGen) {
      this.checkLock("where");
      this.data.where.push(exprGen);
    }
  }, {
    key: "whereBound",
    value: function whereBound(exprGen, isLower) {
      if (typeof isLower !== "boolean") {
        throw new Error("isLower must be specified as a boolean");
      }
      this.checkLock("whereBound");
      this.data.whereBound[isLower ? "lower" : "upper"].push(exprGen);
    }
  }, {
    key: "setOrderIsUnique",
    value: function setOrderIsUnique() {
      this.data.orderIsUnique = true;
    }
  }, {
    key: "orderBy",
    value: function orderBy(exprGen) {
      var ascending = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.checkLock("orderBy");
      this.data.orderBy.push([exprGen, ascending]);
    }
  }, {
    key: "limit",
    value: function limit(limitGen) {
      this.checkLock("limit");

      if (this.data.limit != null) {
        throw new Error("Must only set limit once");
      }
      this.data.limit = limitGen;
    }
  }, {
    key: "offset",
    value: function offset(offsetGen) {
      this.checkLock("offset");
      if (this.data.offset != null) {
        throw new Error("Must only set offset once");
      }
      this.data.offset = offsetGen;
    }
  }, {
    key: "first",
    value: function (_first) {
      function first(_x) {
        return _first.apply(this, arguments);
      }

      first.toString = function () {
        return _first.toString();
      };

      return first;
    }(function (first) {
      this.checkLock("first");
      if (this.data.first != null) {
        throw new Error("Must only set first once");
      }
      this.data.first = first;
    })
  }, {
    key: "last",
    value: function (_last) {
      function last(_x2) {
        return _last.apply(this, arguments);
      }

      last.toString = function () {
        return _last.toString();
      };

      return last;
    }(function (last) {
      this.checkLock("last");
      if (this.data.last != null) {
        throw new Error("Must only set last once");
      }
      this.data.last = last;
    })

    // ----------------------------------------

  }, {
    key: "isOrderUnique",
    value: function isOrderUnique() {
      var lock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (lock) {
        this.lock("orderBy");
        this.lock("orderIsUnique");
        return this.compiledData.orderIsUnique;
      } else {
        // This is useful inside `beforeLock("orderBy", ...)` calls
        return this.data.orderIsUnique;
      }
    }
  }, {
    key: "getTableExpression",
    value: function getTableExpression() {
      this.lock("from");
      if (!this.compiledData.from) {
        throw new Error("No from table has been supplied");
      }
      return this.compiledData.from[0];
    }
  }, {
    key: "getTableAlias",
    value: function getTableAlias() {
      this.lock("from");
      if (!this.compiledData.from) {
        throw new Error("No from table has been supplied");
      }
      return this.compiledData.from[1];
    }
  }, {
    key: "getSelectCursor",
    value: function getSelectCursor() {
      this.lock("selectCursor");
      return this.compiledData.selectCursor;
    }
  }, {
    key: "getOffset",
    value: function getOffset() {
      this.lock("offset");
      return this.compiledData.offset || 0;
    }
  }, {
    key: "getFinalLimitAndOffset",
    value: function getFinalLimitAndOffset() {
      this.lock("offset");
      this.lock("limit");
      this.lock("first");
      this.lock("last");
      var limit = this.compiledData.limit;
      var offset = this.compiledData.offset || 0;
      var flip = false;
      if (this.compiledData.first != null) {
        if (limit != null) {
          limit = Math.min(limit, this.compiledData.first);
        } else {
          limit = this.compiledData.first;
        }
      }
      if (this.compiledData.last != null) {
        if (offset > 0 && limit != null) {
          throw new Error("Issue within pagination, please report your query to graphile-build");
        }
        if (limit != null) {
          if (this.compiledData.last < limit) {
            offset = limit - this.compiledData.last;
            limit = this.compiledData.last;
          } else {
            // no need to change anything
          }
        } else if (offset > 0) {
          throw new Error("Cannot combine 'last' and 'offset'");
        } else {
          if (this.compiledData.orderBy.length > 0) {
            flip = true;
            limit = this.compiledData.last;
          } else {
            throw new Error("Cannot do last of an unordered set");
          }
        }
      }
      return {
        limit,
        offset,
        flip
      };
    }
  }, {
    key: "getFinalOffset",
    value: function getFinalOffset() {
      return this.getFinalLimitAndOffset().offset;
    }
  }, {
    key: "getFinalLimit",
    value: function getFinalLimit() {
      return this.getFinalLimitAndOffset().limit;
    }
  }, {
    key: "getOrderByExpressionsAndDirections",
    value: function getOrderByExpressionsAndDirections() {
      this.lock("orderBy");
      return this.compiledData.orderBy;
    }
  }, {
    key: "getSelectFieldsCount",
    value: function getSelectFieldsCount() {
      this.lockEverything();
      return this.compiledData.select.length;
    }
  }, {
    key: "buildSelectFields",
    value: function buildSelectFields() {
      this.lockEverything();
      return sql.join(this.compiledData.select.map(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            sqlFragment = _ref2[0],
            alias = _ref2[1];

        return sql.fragment`to_json(${sqlFragment}) as ${sql.identifier(alias)}`;
      }), ", ");
    }
  }, {
    key: "buildSelectJson",
    value: function buildSelectJson(_ref3) {
      var addNullCase = _ref3.addNullCase;

      this.lockEverything();
      var buildObject = this.compiledData.select.length ? sql.fragment`json_build_object(${sql.join(this.compiledData.select.map(function (_ref4) {
        var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
            sqlFragment = _ref5[0],
            alias = _ref5[1];

        return sql.fragment`${sql.literal(alias)}, ${sqlFragment}`;
      }), ", ")})` : sql.fragment`to_json(${this.getTableAlias()}.*)`;
      if (addNullCase) {
        buildObject = sql.fragment`(case when ${this.getTableAlias()} is not distinct from null then null else ${buildObject} end)`;
      }
      return buildObject;
    }
  }, {
    key: "buildWhereBoundClause",
    value: function buildWhereBoundClause(isLower) {
      this.lock("whereBound");
      var clauses = this.compiledData.whereBound[isLower ? "lower" : "upper"];
      if (clauses.length) {
        return sql.fragment`(${sql.join(clauses, ") and (")})`;
      } else {
        return sql.literal(true);
      }
    }
  }, {
    key: "buildWhereClause",
    value: function buildWhereClause(includeLowerBound, includeUpperBound, _ref6) {
      var addNullCase = _ref6.addNullCase;

      this.lock("where");
      var clauses = [].concat((0, _toConsumableArray3.default)(addNullCase ? /*
                                                                              * Okay... so this is quite interesting. When we're talking about
                                                                              * composite types, `(foo is not null)` and `not (foo is null)` are
                                                                              * NOT equivalent! Here's why:
                                                                              *
                                                                              * `(foo is null)`
                                                                              *   true if every field of the row is null
                                                                              *
                                                                              * `(foo is not null)`
                                                                              *   true if every field of the row is not null
                                                                              *
                                                                              * `not (foo is null)`
                                                                              *   true if there's at least one field that is not null
                                                                              *
                                                                              * So don't "simplify" the line below! We're probably checking if
                                                                              * the result of a function call returning a compound type was
                                                                              * indeed null.
                                                                              */
      [sql.fragment`not (${this.getTableAlias()} is null)`] : []), (0, _toConsumableArray3.default)(this.compiledData.where), (0, _toConsumableArray3.default)(includeLowerBound ? [this.buildWhereBoundClause(true)] : []), (0, _toConsumableArray3.default)(includeUpperBound ? [this.buildWhereBoundClause(false)] : []));
      return clauses.length ? sql.fragment`(${sql.join(clauses, ") and (")})` : sql.fragment`1 = 1`;
    }
  }, {
    key: "build",
    value: function build() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _options$asJson = options.asJson,
          asJson = _options$asJson === undefined ? false : _options$asJson,
          _options$asJsonAggreg = options.asJsonAggregate,
          asJsonAggregate = _options$asJsonAggreg === undefined ? false : _options$asJsonAggreg,
          _options$onlyJsonFiel = options.onlyJsonField,
          onlyJsonField = _options$onlyJsonFiel === undefined ? false : _options$onlyJsonFiel,
          _options$addNullCase = options.addNullCase,
          addNullCase = _options$addNullCase === undefined ? false : _options$addNullCase;


      this.lockEverything();
      if (onlyJsonField) {
        return this.buildSelectJson({ addNullCase });
      }

      var _getFinalLimitAndOffs = this.getFinalLimitAndOffset(),
          limit = _getFinalLimitAndOffs.limit,
          offset = _getFinalLimitAndOffs.offset,
          flip = _getFinalLimitAndOffs.flip;

      var fields = asJson || asJsonAggregate ? sql.fragment`${this.buildSelectJson({ addNullCase })} as object` : this.buildSelectFields();

      var fragment = sql.fragment`
      select ${fields}
      ${this.compiledData.from && sql.fragment`from ${this.compiledData.from[0]} as ${this.getTableAlias()}`}
      ${this.compiledData.join.length && sql.join(this.compiledData.join, " ")}
      where ${this.buildWhereClause(true, true, options)}
      ${this.compiledData.orderBy.length ? sql.fragment`order by ${sql.join(this.compiledData.orderBy.map(function (_ref7) {
        var _ref8 = (0, _slicedToArray3.default)(_ref7, 2),
            expr = _ref8[0],
            ascending = _ref8[1];

        return sql.fragment`${expr} ${Number(ascending) ^ Number(flip) ? sql.fragment`ASC` : sql.fragment`DESC`}`;
      }), ",")}` : ""}
      ${(0, _isSafeInteger2.default)(limit) && sql.fragment`limit ${sql.literal(limit)}`}
      ${offset && sql.fragment`offset ${sql.literal(offset)}`}
    `;
      if (flip) {
        var flipAlias = (0, _symbol2.default)();
        fragment = sql.fragment`
        with ${sql.identifier(flipAlias)} as (
          ${fragment}
        )
        select *
        from ${sql.identifier(flipAlias)}
        order by (row_number() over (partition by 1)) desc
        `;
      }
      if (asJsonAggregate) {
        var aggAlias = (0, _symbol2.default)();
        fragment = sql.fragment`select json_agg(${sql.identifier(aggAlias, "object")}) from (${fragment}) as ${sql.identifier(aggAlias)}`;
        fragment = sql.fragment`select coalesce((${fragment}), '[]'::json)`;
      }
      return fragment;
    }

    // ----------------------------------------

  }, {
    key: "_finalize",
    value: function _finalize() {
      this.finalized = true;
    }
  }, {
    key: "lock",
    value: function lock(type) {
      var _this3 = this;

      if (this.locks[type]) return;
      var getContext = function getContext() {
        return {
          queryBuilder: _this3
        };
      };
      var beforeLocks = this.data.beforeLock[type];
      this.data.beforeLock[type] = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(beforeLocks || []), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fn = _step.value;

          fn();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.locks[type] = isDev ? new Error("Initally locked here").stack : true;
      if (type === "cursorComparator") {
        // It's meant to be a function
        this.compiledData[type] = this.data[type];
      } else if (type === "whereBound") {
        // Handle properties separately
        this.compiledData[type].lower = callIfNecessaryArray(this.data[type].lower, getContext());
        this.compiledData[type].upper = callIfNecessaryArray(this.data[type].upper, getContext());
      } else if (type === "select") {
        // Assume that duplicate fields must be identical, don't output the same key multiple times
        var seenFields = [];
        this.compiledData[type] = this.data[type].reduce(function (memo, _ref9) {
          var _ref10 = (0, _slicedToArray3.default)(_ref9, 2),
              a = _ref10[0],
              b = _ref10[1];

          if (seenFields.indexOf(b) < 0) {
            seenFields.push(b);
            memo.push([callIfNecessary(a, getContext()), b]);
          }
          return memo;
        }, []);
      } else if (type === "orderBy") {
        this.compiledData[type] = this.data[type].map(function (_ref11) {
          var _ref12 = (0, _slicedToArray3.default)(_ref11, 2),
              a = _ref12[0],
              b = _ref12[1];

          return [callIfNecessary(a, getContext()), b];
        });
      } else if (type === "from") {
        if (this.data.from) {
          var f = this.data.from;
          this.compiledData.from = [callIfNecessary(f[0], getContext()), f[1]];
        }
      } else if (type === "join" || type === "where") {
        this.compiledData[type] = callIfNecessaryArray(this.data[type], getContext());
      } else if (type === "selectCursor") {
        this.compiledData[type] = callIfNecessary(this.data[type], getContext());
      } else if (type === "cursorPrefix") {
        this.compiledData[type] = this.data[type];
      } else if (type === "orderIsUnique") {
        this.compiledData[type] = this.data[type];
      } else if (type === "limit") {
        this.compiledData[type] = callIfNecessary(this.data[type], getContext());
      } else if (type === "offset") {
        this.compiledData[type] = callIfNecessary(this.data[type], getContext());
      } else if (type === "first") {
        this.compiledData[type] = this.data[type];
      } else if (type === "last") {
        this.compiledData[type] = this.data[type];
      } else {
        throw new Error(`Wasn't expecting to lock '${type}'`);
      }
    }
  }, {
    key: "checkLock",
    value: function checkLock(type) {
      if (this.locks[type]) {
        if (typeof this.locks[type] === "string") {
          throw new Error(`'${type}' has already been locked\n    ` + this.locks[type].replace(/\n/g, "\n    ") + "\n");
        }
        throw new Error(`'${type}' has already been locked`);
      }
    }
  }, {
    key: "lockEverything",
    value: function lockEverything() {
      this._finalize();
      // We must execute everything after `from` so we have the alias to reference
      this.lock("from");
      this.lock("join");
      this.lock("orderBy");
      // We must execute where after orderBy because cursor queries require all orderBy columns
      this.lock("cursorComparator");
      this.lock("whereBound");
      this.lock("where");
      // 'where' -> 'whereBound' can affect 'offset'/'limit'
      this.lock("offset");
      this.lock("limit");
      this.lock("first");
      this.lock("last");
      // We must execute select after orderBy otherwise we cannot generate a cursor
      this.lock("selectCursor");
      this.lock("select");
    }
  }]);
  return QueryBuilder;
}();

exports.default = QueryBuilder;
//# sourceMappingURL=QueryBuilder.js.map