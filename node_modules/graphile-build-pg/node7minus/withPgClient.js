"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

exports.quacksLikePgPool = quacksLikePgPool;

var _pg = require("pg");

var _pg2 = _interopRequireDefault(_pg);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)("graphile-build-pg");

function constructorName(obj) {
  return obj && typeof obj.constructor === "function" && obj.constructor.name;
}

// Some duck-typing

function quacksLikePgClient(pgConfig) {
  // A diagnosis of exclusion
  if (!pgConfig || typeof pgConfig !== "object") return false;
  if (constructorName(pgConfig) !== "Client") return false;
  if (typeof pgConfig.connect !== "function") return false;
  if (typeof pgConfig.end !== "function") return false;
  if (typeof pgConfig.escapeLiteral !== "function") return false;
  if (typeof pgConfig.escapeIdentifier !== "function") return false;
  return true;
}

function quacksLikePgPool(pgConfig) {
  // A diagnosis of exclusion
  if (!pgConfig || typeof pgConfig !== "object") return false;
  if (constructorName(pgConfig) !== "Pool" && constructorName(pgConfig) !== "BoundPool") {
    return false;
  }
  if (!pgConfig.Client) return false;
  if (!pgConfig.options) return false;
  if (typeof pgConfig.connect !== "function") return false;
  if (typeof pgConfig.end !== "function") return false;
  if (typeof pgConfig.query !== "function") return false;
  return true;
}

var withPgClient = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    var pgConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env.DATABASE_URL;
    var fn = arguments[1];
    var releasePgClient, pgClient, result, pgPool;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (fn) {
              _context.next = 2;
              break;
            }

            throw new Error("Nothing to do!");

          case 2:
            releasePgClient = function releasePgClient() {};

            pgClient = void 0;
            result = void 0;
            _context.prev = 5;

            if (!(pgConfig instanceof _pg2.default.Client || quacksLikePgClient(pgConfig))) {
              _context.next = 12;
              break;
            }

            pgClient = pgConfig;

            if (pgClient.release) {
              _context.next = 10;
              break;
            }

            throw new Error("We only support PG clients from a PG pool (because otherwise the `await` call can hang indefinitely if an error occurs and there's no error handler)");

          case 10:
            _context.next = 29;
            break;

          case 12:
            if (!(pgConfig instanceof _pg2.default.Pool || quacksLikePgPool(pgConfig))) {
              _context.next = 20;
              break;
            }

            pgPool = pgConfig;
            _context.next = 16;
            return pgPool.connect();

          case 16:
            pgClient = _context.sent;

            releasePgClient = function releasePgClient() {
              return pgClient.release();
            };
            _context.next = 29;
            break;

          case 20:
            if (!(pgConfig === undefined || typeof pgConfig === "string")) {
              _context.next = 28;
              break;
            }

            pgClient = new _pg2.default.Client(pgConfig);
            pgClient.on("error", function (e) {
              debug("pgClient error occurred: %s", e);
            });
            releasePgClient = function releasePgClient() {
              return new _promise2.default(function (resolve, reject) {
                return pgClient.end(function (err) {
                  return err ? reject(err) : resolve();
                });
              });
            };
            _context.next = 26;
            return new _promise2.default(function (resolve, reject) {
              return pgClient.connect(function (err) {
                return err ? reject(err) : resolve();
              });
            });

          case 26:
            _context.next = 29;
            break;

          case 28:
            throw new Error("You must provide a valid PG client configuration");

          case 29:
            _context.next = 31;
            return fn(pgClient);

          case 31:
            result = _context.sent;

          case 32:
            _context.prev = 32;
            _context.prev = 33;
            _context.next = 36;
            return releasePgClient();

          case 36:
            _context.next = 40;
            break;

          case 38:
            _context.prev = 38;
            _context.t0 = _context["catch"](33);

          case 40:
            return _context.finish(32);

          case 41:
            return _context.abrupt("return", result);

          case 42:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, undefined, [[5,, 32, 41], [33, 38]]);
  }));

  return function withPgClient() {
    return _ref.apply(this, arguments);
  };
}();

exports.default = withPgClient;
//# sourceMappingURL=withPgClient.js.map