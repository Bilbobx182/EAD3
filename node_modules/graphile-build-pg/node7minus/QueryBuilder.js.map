{"version":3,"sources":["../src/QueryBuilder.js"],"names":["sql","isDev","indexOf","process","env","NODE_ENV","callIfNecessary","o","context","callIfNecessaryArray","Array","isArray","map","v","QueryBuilder","locks","finalized","data","cursorPrefix","select","selectCursor","from","join","where","whereBound","lower","upper","orderBy","orderIsUnique","limit","offset","first","last","beforeLock","cursorComparator","compiledData","lock","field","fn","checkLock","push","cursorValue","isAfter","Error","exprGen","alias","test","expr","identifier","isLower","ascending","limitGen","offsetGen","flip","Math","min","length","getFinalLimitAndOffset","lockEverything","sqlFragment","fragment","addNullCase","buildObject","literal","getTableAlias","clauses","includeLowerBound","includeUpperBound","buildWhereBoundClause","options","asJson","asJsonAggregate","onlyJsonField","buildSelectJson","fields","buildSelectFields","buildWhereClause","Number","flipAlias","aggAlias","type","getContext","queryBuilder","beforeLocks","stack","seenFields","reduce","memo","a","b","f","replace","_finalize"],"mappings":"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","file":"QueryBuilder.js","sourcesContent":["// @flow\nimport * as sql from \"pg-sql2\";\nimport type { SQL } from \"pg-sql2\";\nimport isSafeInteger from \"lodash/isSafeInteger\";\n\nconst isDev = [\"test\", \"development\"].indexOf(process.env.NODE_ENV) >= 0;\n\ntype GenContext = {\n  queryBuilder: QueryBuilder,\n};\ntype Gen<T> = (context: GenContext) => T;\n\nfunction callIfNecessary<T>(o: Gen<T> | T, context: GenContext): T {\n  if (typeof o === \"function\") {\n    return o(context);\n  } else {\n    return o;\n  }\n}\n\nfunction callIfNecessaryArray<T>(\n  o: Array<Gen<T> | T>,\n  context: GenContext\n): Array<T> {\n  if (Array.isArray(o)) {\n    return o.map(v => callIfNecessary(v, context));\n  } else {\n    return o;\n  }\n}\n\ntype RawAlias = Symbol | string;\ntype SQLAlias = SQL;\ntype SQLGen = Gen<SQL> | SQL;\ntype NumberGen = Gen<number> | number;\ntype CursorValue = {};\ntype CursorComparator = (val: CursorValue, isAfter: boolean) => void;\n\nclass QueryBuilder {\n  locks: {\n    [string]: true | string,\n  };\n  finalized: boolean;\n  data: {\n    cursorPrefix: Array<string>,\n    select: Array<[SQLGen, RawAlias]>,\n    selectCursor: ?SQLGen,\n    from: ?[SQLGen, SQLAlias],\n    join: Array<SQLGen>,\n    where: Array<SQLGen>,\n    whereBound: {\n      lower: Array<SQLGen>,\n      upper: Array<SQLGen>,\n    },\n    orderBy: Array<[SQLGen, boolean]>,\n    orderIsUnique: boolean,\n    limit: ?NumberGen,\n    offset: ?NumberGen,\n    first: ?number,\n    last: ?number,\n    beforeLock: {\n      [string]: Array<() => void>,\n    },\n    cursorComparator: ?CursorComparator,\n  };\n  compiledData: {\n    cursorPrefix: Array<string>,\n    select: Array<[SQL, RawAlias]>,\n    selectCursor: ?SQL,\n    from: ?[SQL, SQLAlias],\n    join: Array<SQL>,\n    where: Array<SQL>,\n    whereBound: {\n      lower: Array<SQL>,\n      upper: Array<SQL>,\n    },\n    orderBy: Array<[SQL, boolean]>,\n    orderIsUnique: boolean,\n    limit: ?number,\n    offset: ?number,\n    first: ?number,\n    last: ?number,\n    cursorComparator: ?CursorComparator,\n  };\n\n  constructor() {\n    this.locks = {};\n    this.finalized = false;\n    this.data = {\n      // TODO: refactor `cursorPrefix`, it shouldn't be here (or should at least have getters/setters)\n      cursorPrefix: [\"natural\"],\n      select: [],\n      selectCursor: null,\n      from: null,\n      join: [],\n      where: [],\n      whereBound: {\n        lower: [],\n        upper: [],\n      },\n      orderBy: [],\n      orderIsUnique: false,\n      limit: null,\n      offset: null,\n      first: null,\n      last: null,\n      beforeLock: {},\n      cursorComparator: null,\n    };\n    this.compiledData = {\n      cursorPrefix: [\"natural\"],\n      select: [],\n      selectCursor: null,\n      from: null,\n      join: [],\n      where: [],\n      whereBound: {\n        lower: [],\n        upper: [],\n      },\n      orderBy: [],\n      orderIsUnique: false,\n      limit: null,\n      offset: null,\n      first: null,\n      last: null,\n      cursorComparator: null,\n    };\n    this.beforeLock(\"select\", () => {\n      this.lock(\"selectCursor\");\n      if (this.compiledData.selectCursor) {\n        this.select(this.compiledData.selectCursor, \"__cursor\");\n      }\n    });\n    // 'whereBound' and 'natural' order might set offset/limit\n    this.beforeLock(\"where\", () => {\n      this.lock(\"whereBound\");\n    });\n    this.beforeLock(\"offset\", () => {\n      this.lock(\"whereBound\");\n    });\n    this.beforeLock(\"limit\", () => {\n      this.lock(\"whereBound\");\n    });\n    this.beforeLock(\"first\", () => {\n      this.lock(\"limit\");\n      this.lock(\"offset\");\n    });\n    this.beforeLock(\"last\", () => {\n      this.lock(\"limit\");\n      this.lock(\"offset\");\n    });\n  }\n\n  // ----------------------------------------\n\n  beforeLock(field: string, fn: () => void) {\n    this.checkLock(field);\n    this.data.beforeLock[field] = this.data.beforeLock[field] || [];\n    this.data.beforeLock[field].push(fn);\n  }\n  setCursorComparator(fn: CursorComparator) {\n    this.checkLock(\"cursorComparator\");\n    this.data.cursorComparator = fn;\n    this.lock(\"cursorComparator\");\n  }\n  addCursorCondition(cursorValue: CursorValue, isAfter: boolean) {\n    this.beforeLock(\"whereBound\", () => {\n      this.lock(\"cursorComparator\");\n      if (!this.compiledData.cursorComparator) {\n        throw new Error(\"No cursor comparator was set!\");\n      }\n      this.compiledData.cursorComparator(cursorValue, isAfter);\n    });\n  }\n  select(exprGen: SQLGen, alias: RawAlias) {\n    this.checkLock(\"select\");\n    if (typeof alias === \"string\") {\n      // To protect against vulnerabilities such as\n      //\n      // https://github.com/brianc/node-postgres/issues/1408\n      //\n      // we need to ensure column names are safe. Turns out that GraphQL\n      // aliases are fairly strict (`[_A-Za-z][_0-9A-Za-z]*`) anyway:\n      //\n      // https://github.com/graphql/graphql-js/blob/680685dd14bd52c6475305e150e5f295ead2aa7e/src/language/lexer.js#L551-L581\n      //\n      // so this should not cause any issues in practice.\n      if (/^[_A-Za-z][_0-9A-Za-z]*$/.test(alias) !== true) {\n        throw new Error(`Disallowed alias '${alias}'.`);\n      }\n    }\n    this.data.select.push([exprGen, alias]);\n  }\n  selectCursor(exprGen: SQLGen) {\n    this.checkLock(\"selectCursor\");\n    this.data.selectCursor = exprGen;\n  }\n  from(expr: SQLGen, alias?: SQLAlias = sql.identifier(Symbol())) {\n    this.checkLock(\"from\");\n    if (!expr) {\n      throw new Error(\"No from table source!\");\n    }\n    if (!alias) {\n      throw new Error(\"No from alias!\");\n    }\n    this.data.from = [expr, alias];\n    this.lock(\"from\");\n  }\n  // XXX: join\n  where(exprGen: SQLGen) {\n    this.checkLock(\"where\");\n    this.data.where.push(exprGen);\n  }\n  whereBound(exprGen: SQLGen, isLower: boolean) {\n    if (typeof isLower !== \"boolean\") {\n      throw new Error(\"isLower must be specified as a boolean\");\n    }\n    this.checkLock(\"whereBound\");\n    this.data.whereBound[isLower ? \"lower\" : \"upper\"].push(exprGen);\n  }\n  setOrderIsUnique() {\n    this.data.orderIsUnique = true;\n  }\n  orderBy(exprGen: SQLGen, ascending: boolean = true) {\n    this.checkLock(\"orderBy\");\n    this.data.orderBy.push([exprGen, ascending]);\n  }\n  limit(limitGen: NumberGen) {\n    this.checkLock(\"limit\");\n\n    if (this.data.limit != null) {\n      throw new Error(\"Must only set limit once\");\n    }\n    this.data.limit = limitGen;\n  }\n  offset(offsetGen: NumberGen) {\n    this.checkLock(\"offset\");\n    if (this.data.offset != null) {\n      throw new Error(\"Must only set offset once\");\n    }\n    this.data.offset = offsetGen;\n  }\n  first(first: number) {\n    this.checkLock(\"first\");\n    if (this.data.first != null) {\n      throw new Error(\"Must only set first once\");\n    }\n    this.data.first = first;\n  }\n  last(last: number) {\n    this.checkLock(\"last\");\n    if (this.data.last != null) {\n      throw new Error(\"Must only set last once\");\n    }\n    this.data.last = last;\n  }\n\n  // ----------------------------------------\n\n  isOrderUnique(lock?: boolean = true) {\n    if (lock) {\n      this.lock(\"orderBy\");\n      this.lock(\"orderIsUnique\");\n      return this.compiledData.orderIsUnique;\n    } else {\n      // This is useful inside `beforeLock(\"orderBy\", ...)` calls\n      return this.data.orderIsUnique;\n    }\n  }\n  getTableExpression(): SQL {\n    this.lock(\"from\");\n    if (!this.compiledData.from) {\n      throw new Error(\"No from table has been supplied\");\n    }\n    return this.compiledData.from[0];\n  }\n  getTableAlias(): SQL {\n    this.lock(\"from\");\n    if (!this.compiledData.from) {\n      throw new Error(\"No from table has been supplied\");\n    }\n    return this.compiledData.from[1];\n  }\n  getSelectCursor() {\n    this.lock(\"selectCursor\");\n    return this.compiledData.selectCursor;\n  }\n  getOffset() {\n    this.lock(\"offset\");\n    return this.compiledData.offset || 0;\n  }\n  getFinalLimitAndOffset() {\n    this.lock(\"offset\");\n    this.lock(\"limit\");\n    this.lock(\"first\");\n    this.lock(\"last\");\n    let limit = this.compiledData.limit;\n    let offset = this.compiledData.offset || 0;\n    let flip = false;\n    if (this.compiledData.first != null) {\n      if (limit != null) {\n        limit = Math.min(limit, this.compiledData.first);\n      } else {\n        limit = this.compiledData.first;\n      }\n    }\n    if (this.compiledData.last != null) {\n      if (offset > 0 && limit != null) {\n        throw new Error(\n          \"Issue within pagination, please report your query to graphile-build\"\n        );\n      }\n      if (limit != null) {\n        if (this.compiledData.last < limit) {\n          offset = limit - this.compiledData.last;\n          limit = this.compiledData.last;\n        } else {\n          // no need to change anything\n        }\n      } else if (offset > 0) {\n        throw new Error(\"Cannot combine 'last' and 'offset'\");\n      } else {\n        if (this.compiledData.orderBy.length > 0) {\n          flip = true;\n          limit = this.compiledData.last;\n        } else {\n          throw new Error(\"Cannot do last of an unordered set\");\n        }\n      }\n    }\n    return {\n      limit,\n      offset,\n      flip,\n    };\n  }\n  getFinalOffset() {\n    return this.getFinalLimitAndOffset().offset;\n  }\n  getFinalLimit() {\n    return this.getFinalLimitAndOffset().limit;\n  }\n  getOrderByExpressionsAndDirections() {\n    this.lock(\"orderBy\");\n    return this.compiledData.orderBy;\n  }\n  getSelectFieldsCount() {\n    this.lockEverything();\n    return this.compiledData.select.length;\n  }\n  buildSelectFields() {\n    this.lockEverything();\n    return sql.join(\n      this.compiledData.select.map(\n        ([sqlFragment, alias]) =>\n          sql.fragment`to_json(${sqlFragment}) as ${sql.identifier(alias)}`\n      ),\n      \", \"\n    );\n  }\n  buildSelectJson({ addNullCase }: { addNullCase?: boolean }) {\n    this.lockEverything();\n    let buildObject = this.compiledData.select.length\n      ? sql.fragment`json_build_object(${sql.join(\n          this.compiledData.select.map(\n            ([sqlFragment, alias]) =>\n              sql.fragment`${sql.literal(alias)}, ${sqlFragment}`\n          ),\n          \", \"\n        )})`\n      : sql.fragment`to_json(${this.getTableAlias()}.*)`;\n    if (addNullCase) {\n      buildObject = sql.fragment`(case when ${this.getTableAlias()} is not distinct from null then null else ${buildObject} end)`;\n    }\n    return buildObject;\n  }\n  buildWhereBoundClause(isLower: boolean) {\n    this.lock(\"whereBound\");\n    const clauses = this.compiledData.whereBound[isLower ? \"lower\" : \"upper\"];\n    if (clauses.length) {\n      return sql.fragment`(${sql.join(clauses, \") and (\")})`;\n    } else {\n      return sql.literal(true);\n    }\n  }\n  buildWhereClause(\n    includeLowerBound: boolean,\n    includeUpperBound: boolean,\n    { addNullCase }: { addNullCase?: boolean }\n  ) {\n    this.lock(\"where\");\n    const clauses = [\n      ...(addNullCase\n        ? /*\n           * Okay... so this is quite interesting. When we're talking about\n           * composite types, `(foo is not null)` and `not (foo is null)` are\n           * NOT equivalent! Here's why:\n           *\n           * `(foo is null)`\n           *   true if every field of the row is null\n           *\n           * `(foo is not null)`\n           *   true if every field of the row is not null\n           *\n           * `not (foo is null)`\n           *   true if there's at least one field that is not null\n           *\n           * So don't \"simplify\" the line below! We're probably checking if\n           * the result of a function call returning a compound type was\n           * indeed null.\n           */\n          [sql.fragment`not (${this.getTableAlias()} is null)`]\n        : []),\n      ...this.compiledData.where,\n      ...(includeLowerBound ? [this.buildWhereBoundClause(true)] : []),\n      ...(includeUpperBound ? [this.buildWhereBoundClause(false)] : []),\n    ];\n    return clauses.length\n      ? sql.fragment`(${sql.join(clauses, \") and (\")})`\n      : sql.fragment`1 = 1`;\n  }\n  build(\n    options: {\n      asJson?: boolean,\n      asJsonAggregate?: boolean,\n      onlyJsonField?: boolean,\n      addNullCase?: boolean,\n    } = {}\n  ) {\n    const {\n      asJson = false,\n      asJsonAggregate = false,\n      onlyJsonField = false,\n      addNullCase = false,\n    } = options;\n\n    this.lockEverything();\n    if (onlyJsonField) {\n      return this.buildSelectJson({ addNullCase });\n    }\n    const { limit, offset, flip } = this.getFinalLimitAndOffset();\n    const fields =\n      asJson || asJsonAggregate\n        ? sql.fragment`${this.buildSelectJson({ addNullCase })} as object`\n        : this.buildSelectFields();\n\n    let fragment = sql.fragment`\n      select ${fields}\n      ${this.compiledData.from &&\n        sql.fragment`from ${\n          this.compiledData.from[0]\n        } as ${this.getTableAlias()}`}\n      ${this.compiledData.join.length && sql.join(this.compiledData.join, \" \")}\n      where ${this.buildWhereClause(true, true, options)}\n      ${\n        this.compiledData.orderBy.length\n          ? sql.fragment`order by ${sql.join(\n              this.compiledData.orderBy.map(\n                ([expr, ascending]) =>\n                  sql.fragment`${expr} ${\n                    Number(ascending) ^ Number(flip)\n                      ? sql.fragment`ASC`\n                      : sql.fragment`DESC`\n                  }`\n              ),\n              \",\"\n            )}`\n          : \"\"\n      }\n      ${isSafeInteger(limit) && sql.fragment`limit ${sql.literal(limit)}`}\n      ${offset && sql.fragment`offset ${sql.literal(offset)}`}\n    `;\n    if (flip) {\n      const flipAlias = Symbol();\n      fragment = sql.fragment`\n        with ${sql.identifier(flipAlias)} as (\n          ${fragment}\n        )\n        select *\n        from ${sql.identifier(flipAlias)}\n        order by (row_number() over (partition by 1)) desc\n        `;\n    }\n    if (asJsonAggregate) {\n      const aggAlias = Symbol();\n      fragment = sql.fragment`select json_agg(${sql.identifier(\n        aggAlias,\n        \"object\"\n      )}) from (${fragment}) as ${sql.identifier(aggAlias)}`;\n      fragment = sql.fragment`select coalesce((${fragment}), '[]'::json)`;\n    }\n    return fragment;\n  }\n\n  // ----------------------------------------\n\n  _finalize() {\n    this.finalized = true;\n  }\n  lock(type: string) {\n    if (this.locks[type]) return;\n    const getContext = () => ({\n      queryBuilder: this,\n    });\n    const beforeLocks = this.data.beforeLock[type];\n    this.data.beforeLock[type] = [];\n    for (const fn of beforeLocks || []) {\n      fn();\n    }\n    this.locks[type] = isDev ? new Error(\"Initally locked here\").stack : true;\n    if (type === \"cursorComparator\") {\n      // It's meant to be a function\n      this.compiledData[type] = this.data[type];\n    } else if (type === \"whereBound\") {\n      // Handle properties separately\n      this.compiledData[type].lower = callIfNecessaryArray(\n        this.data[type].lower,\n        getContext()\n      );\n      this.compiledData[type].upper = callIfNecessaryArray(\n        this.data[type].upper,\n        getContext()\n      );\n    } else if (type === \"select\") {\n      // Assume that duplicate fields must be identical, don't output the same key multiple times\n      const seenFields = [];\n      this.compiledData[type] = this.data[type].reduce((memo, [a, b]) => {\n        if (seenFields.indexOf(b) < 0) {\n          seenFields.push(b);\n          memo.push([callIfNecessary(a, getContext()), b]);\n        }\n        return memo;\n      }, []);\n    } else if (type === \"orderBy\") {\n      this.compiledData[type] = this.data[type].map(([a, b]) => [\n        callIfNecessary(a, getContext()),\n        b,\n      ]);\n    } else if (type === \"from\") {\n      if (this.data.from) {\n        const f = this.data.from;\n        this.compiledData.from = [callIfNecessary(f[0], getContext()), f[1]];\n      }\n    } else if (type === \"join\" || type === \"where\") {\n      this.compiledData[type] = callIfNecessaryArray(\n        this.data[type],\n        getContext()\n      );\n    } else if (type === \"selectCursor\") {\n      this.compiledData[type] = callIfNecessary(this.data[type], getContext());\n    } else if (type === \"cursorPrefix\") {\n      this.compiledData[type] = this.data[type];\n    } else if (type === \"orderIsUnique\") {\n      this.compiledData[type] = this.data[type];\n    } else if (type === \"limit\") {\n      this.compiledData[type] = callIfNecessary(this.data[type], getContext());\n    } else if (type === \"offset\") {\n      this.compiledData[type] = callIfNecessary(this.data[type], getContext());\n    } else if (type === \"first\") {\n      this.compiledData[type] = this.data[type];\n    } else if (type === \"last\") {\n      this.compiledData[type] = this.data[type];\n    } else {\n      throw new Error(`Wasn't expecting to lock '${type}'`);\n    }\n  }\n  checkLock(type: string) {\n    if (this.locks[type]) {\n      if (typeof this.locks[type] === \"string\") {\n        throw new Error(\n          `'${type}' has already been locked\\n    ` +\n            this.locks[type].replace(/\\n/g, \"\\n    \") +\n            \"\\n\"\n        );\n      }\n      throw new Error(`'${type}' has already been locked`);\n    }\n  }\n  lockEverything() {\n    this._finalize();\n    // We must execute everything after `from` so we have the alias to reference\n    this.lock(\"from\");\n    this.lock(\"join\");\n    this.lock(\"orderBy\");\n    // We must execute where after orderBy because cursor queries require all orderBy columns\n    this.lock(\"cursorComparator\");\n    this.lock(\"whereBound\");\n    this.lock(\"where\");\n    // 'where' -> 'whereBound' can affect 'offset'/'limit'\n    this.lock(\"offset\");\n    this.lock(\"limit\");\n    this.lock(\"first\");\n    this.lock(\"last\");\n    // We must execute select after orderBy otherwise we cannot generate a cursor\n    this.lock(\"selectCursor\");\n    this.lock(\"select\");\n  }\n}\n\nexport default QueryBuilder;\n"]}