"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _symbol = require("babel-runtime/core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _QueryBuilder = require("./QueryBuilder");

var _QueryBuilder2 = _interopRequireDefault(_QueryBuilder);

var _pgSql = require("pg-sql2");

var _pgSql2 = _interopRequireDefault(_pgSql);

var _isSafeInteger = require("lodash/isSafeInteger");

var _isSafeInteger2 = _interopRequireDefault(_isSafeInteger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (from, fromAlias, resolveData, options, withBuilder) {
  var pgQuery = resolveData.pgQuery,
      reallyRawCursorPrefix = resolveData.pgCursorPrefix,
      pgCalculateTotalCount = resolveData.pgCalculateTotalCount,
      calculateHasNextPage = resolveData.calculateHasNextPage,
      calculateHasPreviousPage = resolveData.calculateHasPreviousPage,
      explicitlyUsesCursor = resolveData.usesCursor;


  var usesCursor = explicitlyUsesCursor && explicitlyUsesCursor.length > 0 || calculateHasNextPage && calculateHasNextPage.length > 0 || calculateHasPreviousPage && calculateHasPreviousPage.length > 0 || false;
  var rawCursorPrefix = reallyRawCursorPrefix && reallyRawCursorPrefix.filter(function (_) {
    return _;
  });

  var queryBuilder = new _QueryBuilder2.default();
  queryBuilder.from(from, fromAlias ? fromAlias : undefined);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(pgQuery || []), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fn = _step.value;

      fn(queryBuilder, resolveData);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (withBuilder) {
    withBuilder(queryBuilder);
  }

  function generateNextPrevPageSql(sqlQueryAlias, canHaveCursorInWhere, queryHasBefore, queryHasFirst) {
    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var invert = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    // if invert is true queryHasBefore means queryHasAfter; queryHasFirst means queryHasLast; etc
    var sqlCommon = _pgSql2.default.fragment`
      select 1
      from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}
      where ${queryBuilder.buildWhereClause(!invert, invert, options)}
    `;
    if (!queryHasBefore && !queryHasFirst && (!invert || offset === 0)) {
      // There can be no next page since there's no upper bound
      return _pgSql2.default.literal(false);
    } else if (queryHasBefore && (!invert || offset === 0)) {
      // Simply see if there are any records after the before cursor
      return _pgSql2.default.fragment`exists(
        ${sqlCommon}
        and not (${queryBuilder.buildWhereBoundClause(invert)})
      )`;
    } else if (canHaveCursorInWhere && (!invert || offset === 0)) {
      // Query must have "first"
      // Drop the limit, see if there are any records that aren't already in the list we've fetched
      return _pgSql2.default.fragment`exists(
        ${sqlCommon}
        and (${queryBuilder.getSelectCursor()})::text not in (select __cursor::text from ${sqlQueryAlias})
        ${offset === 0 ? _pgSql2.default.blank : _pgSql2.default.fragment`offset ${_pgSql2.default.value(offset)}`}
      )`;
    } else {
      if (!invert) {
        // Skip over the already known entries, are there any left?
        return _pgSql2.default.fragment`exists(
          ${sqlCommon}
          offset (select coalesce((select count(*) from ${sqlQueryAlias}), 0) + ${_pgSql2.default.value(offset)})
        )`;
      } else {
        // Things get somewhat more complex here... Let's just assume if offset > 0 there's a previous page.
        if (offset > 0) {
          return _pgSql2.default.literal(true);
        }
        // And here (offset === 0 && invert) so we'd have hit an earlier case; since we haven't there must be no previous page.
        return _pgSql2.default.literal(false);
      }
    }
  }
  var getPgCursorPrefix = function getPgCursorPrefix() {
    return rawCursorPrefix && rawCursorPrefix.length > 0 ? rawCursorPrefix : queryBuilder.data.cursorPrefix.map(function (val) {
      return _pgSql2.default.literal(val);
    });
  };
  if (options.withPagination || options.withPaginationAsFields || options.withCursor) {
    // Sometimes we need a __cursor even if it's not a collection; e.g. to get the edge field on a mutation
    if (usesCursor) {
      queryBuilder.selectCursor(function () {
        var orderBy = queryBuilder.getOrderByExpressionsAndDirections().map(function (_ref) {
          var _ref2 = (0, _slicedToArray3.default)(_ref, 1),
              expr = _ref2[0];

          return expr;
        });
        if (queryBuilder.isOrderUnique() && orderBy.length > 0) {
          return _pgSql2.default.fragment`json_build_array(${_pgSql2.default.join([].concat((0, _toConsumableArray3.default)(getPgCursorPrefix()), [_pgSql2.default.fragment`json_build_array(${_pgSql2.default.join(orderBy, ", ")})`]), ", ")})`;
        } else {
          return _pgSql2.default.fragment`json_build_array(${_pgSql2.default.join(getPgCursorPrefix(), ", ")}, (row_number() over (partition by 1)))`;
        }
      });
    }
  }
  if (options.withPagination || options.withPaginationAsFields) {
    queryBuilder.setCursorComparator(function (cursorValue, isAfter) {
      var orderByExpressionsAndDirections = queryBuilder.getOrderByExpressionsAndDirections();
      if (orderByExpressionsAndDirections.length > 0 && queryBuilder.isOrderUnique()) {
        var sqlCursors = cursorValue[getPgCursorPrefix().length].map(function (val) {
          return _pgSql2.default.value(val);
        });
        if (!Array.isArray(sqlCursors)) {
          queryBuilder.whereBound(_pgSql2.default.literal(false), isAfter);
        }
        var sqlFilter = _pgSql2.default.fragment`false`;
        for (var i = orderByExpressionsAndDirections.length - 1; i >= 0; i--) {
          var _orderByExpressionsAn = (0, _slicedToArray3.default)(orderByExpressionsAndDirections[i], 2),
              sqlExpression = _orderByExpressionsAn[0],
              ascending = _orderByExpressionsAn[1];
          // If ascending and isAfter then >
          // If ascending and isBefore then <


          var comparison = Number(ascending) ^ Number(!isAfter) ? _pgSql2.default.fragment`>` : _pgSql2.default.fragment`<`;

          var sqlOldFilter = sqlFilter;
          sqlFilter = _pgSql2.default.fragment`
          (
            (
              ${sqlExpression} ${comparison} ${sqlCursors[i] || _pgSql2.default.null}
            )
          OR
            (
              (
                ${sqlExpression} = ${sqlCursors[i] || _pgSql2.default.null}
              AND
                ${sqlOldFilter}
              )
            )
          )
          `;
        }
        queryBuilder.whereBound(sqlFilter, isAfter);
      } else if (cursorValue[0] === "natural" && (0, _isSafeInteger2.default)(cursorValue[1]) && cursorValue[1] >= 0) {
        if (isAfter) {
          queryBuilder.offset(function () {
            return cursorValue[1];
          });
        } else {
          queryBuilder.limit(function () {
            var offset = queryBuilder.getOffset();
            return Math.max(0, cursorValue[1] - offset - 1);
          });
        }
      } else {
        throw new Error("Cannot use cursors without orderBy");
      }
    });

    var query = queryBuilder.build(options);
    var haveFields = queryBuilder.getSelectFieldsCount() > 0;
    var sqlQueryAlias = _pgSql2.default.identifier((0, _symbol2.default)());
    var sqlSummaryAlias = _pgSql2.default.identifier((0, _symbol2.default)());
    //
    // Tables should ALWAYS push their PK onto the order stack, if this isn't
    // present then we're either dealing with a view or a table without a PK.
    // Either way, we don't have anything to guarantee uniqueness so we need to
    // fall back to limit/offset.
    //
    // TODO: support unique keys in PgAllRows etc
    // TODO: add a warning for cursor-based pagination when using the fallback
    // TODO: if it is a view maybe add a warning encouraging pgViewUniqueKey
    var canHaveCursorInWhere = queryBuilder.getOrderByExpressionsAndDirections().length > 0 && queryBuilder.isOrderUnique();
    var queryHasBefore = queryBuilder.compiledData.whereBound.upper.length > 0;
    var queryHasAfter = queryBuilder.compiledData.whereBound.lower.length > 0;
    var queryHasZeroLimit = queryBuilder.getFinalLimit() === 0;
    var queryHasFirst = (0, _isSafeInteger2.default)(queryBuilder.compiledData.first);
    var queryHasLast = (0, _isSafeInteger2.default)(queryBuilder.compiledData.last);
    var hasNextPage = queryHasZeroLimit ? _pgSql2.default.literal(false) : generateNextPrevPageSql(sqlQueryAlias, canHaveCursorInWhere, queryHasBefore, queryHasFirst, queryBuilder.getFinalOffset() || 0);
    var hasPreviousPage = queryHasZeroLimit ? _pgSql2.default.literal(false) : generateNextPrevPageSql(sqlQueryAlias, canHaveCursorInWhere, queryHasAfter, queryHasLast, queryBuilder.getFinalOffset() || 0, true);

    var totalCount = _pgSql2.default.fragment`(
      select count(*)
      from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}
      where ${queryBuilder.buildWhereClause(false, false, options)}
    )`;
    var sqlWith = haveFields ? _pgSql2.default.fragment`with ${sqlQueryAlias} as (${query}), ${sqlSummaryAlias} as (select json_agg(to_json(${sqlQueryAlias})) as data from ${sqlQueryAlias})` : _pgSql2.default.fragment``;
    var sqlFrom = _pgSql2.default.fragment``;
    var fields = [];
    if (haveFields) {
      fields.push([_pgSql2.default.fragment`coalesce((select ${sqlSummaryAlias}.data from ${sqlSummaryAlias}), '[]'::json)`, "data"]);
      if (calculateHasNextPage) {
        fields.push([hasNextPage, "hasNextPage"]);
      }
      if (calculateHasPreviousPage) {
        fields.push([hasPreviousPage, "hasPreviousPage"]);
      }
    }
    if (pgCalculateTotalCount) {
      fields.push([totalCount, "totalCount"]);
    }
    if (options.withPaginationAsFields) {
      return _pgSql2.default.fragment`${sqlWith} select ${_pgSql2.default.join(fields.map(function (_ref3) {
        var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
            expr = _ref4[0],
            alias = _ref4[1];

        return _pgSql2.default.fragment`${expr} as ${_pgSql2.default.identifier(alias)}`;
      }), ", ")} ${sqlFrom}`;
    } else {
      return _pgSql2.default.fragment`${sqlWith} select json_build_object(${_pgSql2.default.join(fields.map(function (_ref5) {
        var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),
            expr = _ref6[0],
            alias = _ref6[1];

        return _pgSql2.default.fragment`${_pgSql2.default.literal(alias)}, ${expr}`;
      }), ", ")}) ${sqlFrom}`;
    }
  } else {
    var _query = queryBuilder.build(options);
    return _query;
  }
};
//# sourceMappingURL=queryFromResolveData.js.map